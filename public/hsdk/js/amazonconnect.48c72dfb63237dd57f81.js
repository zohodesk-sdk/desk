(window.deskappJsonp=window.deskappJsonp||[]).push([[56],{"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/amazon-connect-v1.0.5.js":function(n,e){n.exports='/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module \'"+o+"\'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports={\n  "version": "2.0",\n  "metadata": {\n    "apiVersion": "2014-06-30",\n    "endpointPrefix": "cognito-identity",\n    "jsonVersion": "1.1",\n    "protocol": "json",\n    "serviceFullName": "Amazon Cognito Identity",\n    "signatureVersion": "v4",\n    "targetPrefix": "AWSCognitoIdentityService"\n  },\n  "operations": {\n    "CreateIdentityPool": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolName",\n          "AllowUnauthenticatedIdentities"\n        ],\n        "members": {\n          "IdentityPoolName": {},\n          "AllowUnauthenticatedIdentities": {\n            "type": "boolean"\n          },\n          "SupportedLoginProviders": {\n            "shape": "S4"\n          },\n          "DeveloperProviderName": {},\n          "OpenIdConnectProviderARNs": {\n            "shape": "S8"\n          },\n          "CognitoIdentityProviders": {\n            "shape": "Sa"\n          },\n          "SamlProviderARNs": {\n            "shape": "Se"\n          }\n        }\n      },\n      "output": {\n        "shape": "Sf"\n      }\n    },\n    "DeleteIdentities": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityIdsToDelete"\n        ],\n        "members": {\n          "IdentityIdsToDelete": {\n            "type": "list",\n            "member": {}\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "UnprocessedIdentityIds": {\n            "type": "list",\n            "member": {\n              "type": "structure",\n              "members": {\n                "IdentityId": {},\n                "ErrorCode": {}\n              }\n            }\n          }\n        }\n      }\n    },\n    "DeleteIdentityPool": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId"\n        ],\n        "members": {\n          "IdentityPoolId": {}\n        }\n      }\n    },\n    "DescribeIdentity": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityId"\n        ],\n        "members": {\n          "IdentityId": {}\n        }\n      },\n      "output": {\n        "shape": "Sq"\n      }\n    },\n    "DescribeIdentityPool": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId"\n        ],\n        "members": {\n          "IdentityPoolId": {}\n        }\n      },\n      "output": {\n        "shape": "Sf"\n      }\n    },\n    "GetCredentialsForIdentity": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityId"\n        ],\n        "members": {\n          "IdentityId": {},\n          "Logins": {\n            "shape": "Sv"\n          },\n          "CustomRoleArn": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityId": {},\n          "Credentials": {\n            "type": "structure",\n            "members": {\n              "AccessKeyId": {},\n              "SecretKey": {},\n              "SessionToken": {},\n              "Expiration": {\n                "type": "timestamp"\n              }\n            }\n          }\n        }\n      }\n    },\n    "GetId": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId"\n        ],\n        "members": {\n          "AccountId": {},\n          "IdentityPoolId": {},\n          "Logins": {\n            "shape": "Sv"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityId": {}\n        }\n      }\n    },\n    "GetIdentityPoolRoles": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId"\n        ],\n        "members": {\n          "IdentityPoolId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityPoolId": {},\n          "Roles": {\n            "shape": "S17"\n          }\n        }\n      }\n    },\n    "GetOpenIdToken": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityId"\n        ],\n        "members": {\n          "IdentityId": {},\n          "Logins": {\n            "shape": "Sv"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityId": {},\n          "Token": {}\n        }\n      }\n    },\n    "GetOpenIdTokenForDeveloperIdentity": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId",\n          "Logins"\n        ],\n        "members": {\n          "IdentityPoolId": {},\n          "IdentityId": {},\n          "Logins": {\n            "shape": "Sv"\n          },\n          "TokenDuration": {\n            "type": "long"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityId": {},\n          "Token": {}\n        }\n      }\n    },\n    "ListIdentities": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId",\n          "MaxResults"\n        ],\n        "members": {\n          "IdentityPoolId": {},\n          "MaxResults": {\n            "type": "integer"\n          },\n          "NextToken": {},\n          "HideDisabled": {\n            "type": "boolean"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityPoolId": {},\n          "Identities": {\n            "type": "list",\n            "member": {\n              "shape": "Sq"\n            }\n          },\n          "NextToken": {}\n        }\n      }\n    },\n    "ListIdentityPools": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "MaxResults"\n        ],\n        "members": {\n          "MaxResults": {\n            "type": "integer"\n          },\n          "NextToken": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityPools": {\n            "type": "list",\n            "member": {\n              "type": "structure",\n              "members": {\n                "IdentityPoolId": {},\n                "IdentityPoolName": {}\n              }\n            }\n          },\n          "NextToken": {}\n        }\n      }\n    },\n    "LookupDeveloperIdentity": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId"\n        ],\n        "members": {\n          "IdentityPoolId": {},\n          "IdentityId": {},\n          "DeveloperUserIdentifier": {},\n          "MaxResults": {\n            "type": "integer"\n          },\n          "NextToken": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityId": {},\n          "DeveloperUserIdentifierList": {\n            "type": "list",\n            "member": {}\n          },\n          "NextToken": {}\n        }\n      }\n    },\n    "MergeDeveloperIdentities": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "SourceUserIdentifier",\n          "DestinationUserIdentifier",\n          "DeveloperProviderName",\n          "IdentityPoolId"\n        ],\n        "members": {\n          "SourceUserIdentifier": {},\n          "DestinationUserIdentifier": {},\n          "DeveloperProviderName": {},\n          "IdentityPoolId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "IdentityId": {}\n        }\n      }\n    },\n    "SetIdentityPoolRoles": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityPoolId",\n          "Roles"\n        ],\n        "members": {\n          "IdentityPoolId": {},\n          "Roles": {\n            "shape": "S17"\n          }\n        }\n      }\n    },\n    "UnlinkDeveloperIdentity": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityId",\n          "IdentityPoolId",\n          "DeveloperProviderName",\n          "DeveloperUserIdentifier"\n        ],\n        "members": {\n          "IdentityId": {},\n          "IdentityPoolId": {},\n          "DeveloperProviderName": {},\n          "DeveloperUserIdentifier": {}\n        }\n      }\n    },\n    "UnlinkIdentity": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "IdentityId",\n          "Logins",\n          "LoginsToRemove"\n        ],\n        "members": {\n          "IdentityId": {},\n          "Logins": {\n            "shape": "Sv"\n          },\n          "LoginsToRemove": {\n            "shape": "Sr"\n          }\n        }\n      }\n    },\n    "UpdateIdentityPool": {\n      "input": {\n        "shape": "Sf"\n      },\n      "output": {\n        "shape": "Sf"\n      }\n    }\n  },\n  "shapes": {\n    "S4": {\n      "type": "map",\n      "key": {},\n      "value": {}\n    },\n    "S8": {\n      "type": "list",\n      "member": {}\n    },\n    "Sa": {\n      "type": "list",\n      "member": {\n        "type": "structure",\n        "members": {\n          "ProviderName": {},\n          "ClientId": {}\n        }\n      }\n    },\n    "Se": {\n      "type": "list",\n      "member": {}\n    },\n    "Sf": {\n      "type": "structure",\n      "required": [\n        "IdentityPoolId",\n        "IdentityPoolName",\n        "AllowUnauthenticatedIdentities"\n      ],\n      "members": {\n        "IdentityPoolId": {},\n        "IdentityPoolName": {},\n        "AllowUnauthenticatedIdentities": {\n          "type": "boolean"\n        },\n        "SupportedLoginProviders": {\n          "shape": "S4"\n        },\n        "DeveloperProviderName": {},\n        "OpenIdConnectProviderARNs": {\n          "shape": "S8"\n        },\n        "CognitoIdentityProviders": {\n          "shape": "Sa"\n        },\n        "SamlProviderARNs": {\n          "shape": "Se"\n        }\n      }\n    },\n    "Sq": {\n      "type": "structure",\n      "members": {\n        "IdentityId": {},\n        "Logins": {\n          "shape": "Sr"\n        },\n        "CreationDate": {\n          "type": "timestamp"\n        },\n        "LastModifiedDate": {\n          "type": "timestamp"\n        }\n      }\n    },\n    "Sr": {\n      "type": "list",\n      "member": {}\n    },\n    "Sv": {\n      "type": "map",\n      "key": {},\n      "value": {}\n    },\n    "S17": {\n      "type": "map",\n      "key": {},\n      "value": {}\n    }\n  }\n}\n},{}],2:[function(require,module,exports){\nmodule.exports={\n  "version": "2.0",\n  "metadata": {\n    "apiVersion": "2017-02-15",\n    "endpointPrefix": "connect",\n    "jsonVersion": "1.0",\n    "protocol": "json",\n    "serviceAbbreviation": "Connect",\n    "serviceFullName": "AmazonConnectCTIService",\n    "signatureVersion": "v4",\n    "targetPrefix": "AmazonConnectCTIService",\n    "uid": "connect-2017-02-15"\n  },\n  "operations": {\n    "AcceptContact": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "ConferenceConnections": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "CreateAdditionalConnection": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "endpoint"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "endpoint": {\n            "shape": "Sa"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "CreateOutboundContact": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "endpoint"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "endpoint": {\n            "shape": "Sa"\n          },\n          "queueARN": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "DestroyConnection": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "connectionId"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "connectionId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "GetAgentConfiguration": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "required": [\n          "configuration"\n        ],\n        "members": {\n          "configuration": {\n            "shape": "Sr"\n          }\n        }\n      }\n    },\n    "GetAgentPermissions": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "nextToken": {},\n          "maxResults": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "required": [\n          "permissions"\n        ],\n        "members": {\n          "permissions": {\n            "type": "list",\n            "member": {}\n          },\n          "nextToken": {}\n        }\n      }\n    },\n    "GetAgentSnapshot": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "nextToken": {},\n          "timeout": {\n            "type": "long"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "required": [\n          "snapshot",\n          "nextToken"\n        ],\n        "members": {\n          "snapshot": {\n            "type": "structure",\n            "required": [\n              "state",\n              "contacts",\n              "snapshotTimestamp"\n            ],\n            "members": {\n              "state": {\n                "shape": "S16"\n              },\n              "contacts": {\n                "type": "list",\n                "member": {\n                  "type": "structure",\n                  "required": [\n                    "contactId",\n                    "type",\n                    "state",\n                    "queue",\n                    "queueTimestamp",\n                    "connections",\n                    "attributes"\n                  ],\n                  "members": {\n                    "contactId": {},\n                    "initialContactId": {},\n                    "type": {},\n                    "state": {\n                      "type": "structure",\n                      "required": [\n                        "type",\n                        "timestamp"\n                      ],\n                      "members": {\n                        "type": {},\n                        "timestamp": {\n                          "type": "timestamp"\n                        }\n                      }\n                    },\n                    "queue": {\n                      "shape": "Sg"\n                    },\n                    "queueTimestamp": {\n                      "type": "timestamp"\n                    },\n                    "connections": {\n                      "type": "list",\n                      "member": {\n                        "type": "structure",\n                        "required": [\n                          "connectionId",\n                          "endpoint",\n                          "state",\n                          "type",\n                          "initial"\n                        ],\n                        "members": {\n                          "connectionId": {},\n                          "endpoint": {\n                            "shape": "Sa"\n                          },\n                          "state": {\n                            "type": "structure",\n                            "required": [\n                              "type",\n                              "timestamp"\n                            ],\n                            "members": {\n                              "type": {},\n                              "timestamp": {\n                                "type": "timestamp"\n                              }\n                            }\n                          },\n                          "type": {},\n                          "initial": {\n                            "type": "boolean"\n                          },\n                          "softphoneMediaInfo": {\n                            "type": "structure",\n                            "members": {\n                              "callType": {},\n                              "autoAccept": {\n                                "type": "boolean"\n                              },\n                              "mediaLegContextToken": {},\n                              "callContextToken": {},\n                              "callConfigJson": {}\n                            }\n                          }\n                        }\n                      }\n                    },\n                    "attributes": {\n                      "shape": "S1n"\n                    }\n                  }\n                }\n              },\n              "snapshotTimestamp": {\n                "type": "timestamp"\n              }\n            }\n          },\n          "nextToken": {}\n        }\n      }\n    },\n    "GetAgentStates": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "nextToken": {},\n          "maxResults": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "required": [\n          "states"\n        ],\n        "members": {\n          "states": {\n            "type": "list",\n            "member": {\n              "shape": "S16"\n            }\n          },\n          "nextToken": {}\n        }\n      }\n    },\n    "GetDialableCountryCodes": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "nextToken": {},\n          "maxResults": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "required": [\n          "countryCodes"\n        ],\n        "members": {\n          "countryCodes": {\n            "type": "list",\n            "member": {}\n          },\n          "nextToken": {}\n        }\n      }\n    },\n    "GetEndpoints": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "queueARNs"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "queueARNs": {\n            "type": "list",\n            "member": {}\n          },\n          "nextToken": {},\n          "maxResults": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "endpoints": {\n            "type": "list",\n            "member": {\n              "shape": "Sa"\n            }\n          },\n          "nextToken": {}\n        }\n      }\n    },\n    "GetNewAuthToken": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "refreshToken"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "refreshToken": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {\n          "newAuthToken": {},\n          "expirationDateTime": {\n            "type": "timestamp"\n          }\n        }\n      }\n    },\n    "GetRoutingProfileQueues": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "routingProfileARN"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "routingProfileARN": {},\n          "nextToken": {},\n          "maxResults": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "required": [\n          "queues"\n        ],\n        "members": {\n          "queues": {\n            "type": "list",\n            "member": {\n              "shape": "Sg"\n            }\n          },\n          "nextToken": {}\n        }\n      }\n    },\n    "HoldConnection": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "connectionId"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "connectionId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "NotifyContactIssue": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "issueCode": {},\n          "description": {},\n          "clientLogs": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "PutAgentState": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "state"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "state": {\n            "shape": "S16"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "ResumeConnection": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "connectionId"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "connectionId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "SendClientLogs": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "logEvents"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "logEvents": {\n            "type": "list",\n            "member": {\n              "type": "structure",\n              "members": {\n                "timestamp": {\n                  "type": "timestamp"\n                },\n                "component": {},\n                "message": {}\n              }\n            }\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "SendDigits": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "connectionId",\n          "digits"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "connectionId": {},\n          "digits": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "SendSoftphoneCallMetrics": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "softphoneStreamStatistics"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "softphoneStreamStatistics": {\n            "shape": "S2m"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "SendSoftphoneCallReport": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "report"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "report": {\n            "type": "structure",\n            "members": {\n              "callStartTime": {\n                "type": "timestamp"\n              },\n              "callEndTime": {\n                "type": "timestamp"\n              },\n              "softphoneStreamStatistics": {\n                "shape": "S2m"\n              },\n              "gumTimeMillis": {\n                "type": "long"\n              },\n              "initializationTimeMillis": {\n                "type": "long"\n              },\n              "iceCollectionTimeMillis": {\n                "type": "long"\n              },\n              "signallingConnectTimeMillis": {\n                "type": "long"\n              },\n              "handshakeTimeMillis": {\n                "type": "long"\n              },\n              "preTalkTimeMillis": {\n                "type": "long"\n              },\n              "talkTimeMillis": {\n                "type": "long"\n              },\n              "cleanupTimeMillis": {\n                "type": "long"\n              },\n              "iceCollectionFailure": {\n                "type": "boolean"\n              },\n              "signallingConnectionFailure": {\n                "type": "boolean"\n              },\n              "handshakeFailure": {\n                "type": "boolean"\n              },\n              "gumOtherFailure": {\n                "type": "boolean"\n              },\n              "gumTimeoutFailure": {\n                "type": "boolean"\n              },\n              "createOfferFailure": {\n                "type": "boolean"\n              },\n              "setLocalDescriptionFailure": {\n                "type": "boolean"\n              },\n              "userBusyFailure": {\n                "type": "boolean"\n              },\n              "invalidRemoteSDPFailure": {\n                "type": "boolean"\n              },\n              "noRemoteIceCandidateFailure": {\n                "type": "boolean"\n              },\n              "setRemoteDescriptionFailure": {\n                "type": "boolean"\n              }\n            }\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "ToggleActiveConnections": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "connectionId"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "connectionId": {}\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "UpdateAgentConfiguration": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "configuration"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "configuration": {\n            "shape": "Sr"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    },\n    "UpdateContactAttributes": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "authentication",\n          "contactId",\n          "attributes"\n        ],\n        "members": {\n          "authentication": {\n            "shape": "S2"\n          },\n          "contactId": {},\n          "attributes": {\n            "shape": "S1n"\n          }\n        }\n      },\n      "output": {\n        "type": "structure",\n        "members": {}\n      }\n    }\n  },\n  "shapes": {\n    "S2": {\n      "type": "structure",\n      "members": {\n        "agentARN": {},\n        "authToken": {}\n      }\n    },\n    "Sa": {\n      "type": "structure",\n      "required": [\n        "type"\n      ],\n      "members": {\n        "endpointARN": {},\n        "type": {},\n        "name": {},\n        "phoneNumber": {},\n        "agentLogin": {},\n        "queue": {\n          "shape": "Sg"\n        }\n      }\n    },\n    "Sg": {\n      "type": "structure",\n      "members": {\n        "queueARN": {},\n        "name": {}\n      }\n    },\n    "Sr": {\n      "type": "structure",\n      "required": [\n        "name",\n        "softphoneEnabled",\n        "softphoneAutoAccept",\n        "extension",\n        "routingProfile"\n      ],\n      "members": {\n        "name": {},\n        "softphoneEnabled": {\n          "type": "boolean"\n        },\n        "softphoneAutoAccept": {\n          "type": "boolean"\n        },\n        "extension": {},\n        "routingProfile": {\n          "type": "structure",\n          "members": {\n            "name": {},\n            "routingProfileARN": {},\n            "defaultOutboundQueue": {\n              "shape": "Sg"\n            }\n          }\n        }\n      }\n    },\n    "S16": {\n      "type": "structure",\n      "required": [\n        "type",\n        "name"\n      ],\n      "members": {\n        "agentStateARN": {},\n        "type": {},\n        "name": {},\n        "startTimestamp": {\n          "type": "timestamp"\n        }\n      }\n    },\n    "S1n": {\n      "type": "map",\n      "key": {},\n      "value": {\n        "type": "structure",\n        "required": [\n          "name"\n        ],\n        "members": {\n          "name": {},\n          "value": {}\n        }\n      }\n    },\n    "S2m": {\n      "type": "list",\n      "member": {\n        "type": "structure",\n        "members": {\n          "timestamp": {\n            "type": "timestamp"\n          },\n          "softphoneStreamType": {},\n          "packetCount": {\n            "type": "long"\n          },\n          "packetsLost": {\n            "type": "long"\n          },\n          "audioLevel": {\n            "type": "double"\n          }\n        }\n      }\n    }\n  }\n}\n},{}],3:[function(require,module,exports){\nmodule.exports={\n  "acm": {\n    "name": "ACM",\n    "cors": true\n  },\n  "apigateway": {\n    "name": "APIGateway",\n    "cors": true\n  },\n  "applicationautoscaling": {\n    "prefix": "application-autoscaling",\n    "name": "ApplicationAutoScaling",\n    "cors": true\n  },\n  "autoscaling": {\n    "name": "AutoScaling",\n    "cors": true\n  },\n  "budgets": {\n    "name": "Budgets"\n  },\n  "cloudformation": {\n    "name": "CloudFormation",\n    "cors": true\n  },\n  "cloudfront": {\n    "name": "CloudFront",\n    "versions": [\n      "2013-05-12*",\n      "2013-11-11*",\n      "2014-05-31*",\n      "2014-10-21*",\n      "2014-11-06*",\n      "2015-04-17*",\n      "2015-07-27*",\n      "2015-09-17*",\n      "2016-01-13*",\n      "2016-01-28*",\n      "2016-08-01*",\n      "2016-08-20*",\n      "2016-09-07*"\n    ],\n    "cors": true\n  },\n  "cloudhsm": {\n    "name": "CloudHSM",\n    "cors": true\n  },\n  "cloudsearch": {\n    "name": "CloudSearch"\n  },\n  "cloudsearchdomain": {\n    "name": "CloudSearchDomain"\n  },\n  "cloudtrail": {\n    "name": "CloudTrail",\n    "cors": true\n  },\n  "cloudwatch": {\n    "prefix": "monitoring",\n    "name": "CloudWatch",\n    "cors": true\n  },\n  "cloudwatchevents": {\n    "prefix": "events",\n    "name": "CloudWatchEvents",\n    "versions": [\n      "2014-02-03*"\n    ],\n    "cors": true\n  },\n  "cloudwatchlogs": {\n    "prefix": "logs",\n    "name": "CloudWatchLogs",\n    "cors": true\n  },\n  "codecommit": {\n    "name": "CodeCommit",\n    "cors": true\n  },\n  "codedeploy": {\n    "name": "CodeDeploy",\n    "cors": true\n  },\n  "codepipeline": {\n    "name": "CodePipeline",\n    "cors": true\n  },\n  "cognitoidentity": {\n    "prefix": "cognito-identity",\n    "name": "CognitoIdentity",\n    "cors": true\n  },\n  "cognitoidentityserviceprovider": {\n    "prefix": "cognito-idp",\n    "name": "CognitoIdentityServiceProvider",\n    "cors": true\n  },\n  "cognitosync": {\n    "prefix": "cognito-sync",\n    "name": "CognitoSync",\n    "cors": true\n  },\n  "configservice": {\n    "prefix": "config",\n    "name": "ConfigService",\n    "cors": true\n  },\n  "connect": {\n    "name":  "Connect",\n    "cors":  true\n  },\n  "datapipeline": {\n    "name": "DataPipeline"\n  },\n  "devicefarm": {\n    "name": "DeviceFarm",\n    "cors": true\n  },\n  "directconnect": {\n    "name": "DirectConnect",\n    "cors": true\n  },\n  "directoryservice": {\n    "prefix": "ds",\n    "name": "DirectoryService"\n  },\n  "discovery": {\n    "name": "Discovery"\n  },\n  "dms": {\n    "name": "DMS"\n  },\n  "dynamodb": {\n    "name": "DynamoDB",\n    "cors": true\n  },\n  "dynamodbstreams": {\n    "prefix": "streams.dynamodb",\n    "name": "DynamoDBStreams",\n    "cors": true\n  },\n  "ec2": {\n    "name": "EC2",\n    "versions": [\n      "2013-06-15*",\n      "2013-10-15*",\n      "2014-02-01*",\n      "2014-05-01*",\n      "2014-06-15*",\n      "2014-09-01*",\n      "2014-10-01*",\n      "2015-03-01*",\n      "2015-04-15*",\n      "2015-10-01*",\n      "2016-04-01*"\n    ],\n    "cors": true\n  },\n  "ecr": {\n    "name": "ECR",\n    "cors": true\n  },\n  "ecs": {\n    "name": "ECS",\n    "cors": true\n  },\n  "efs": {\n    "prefix": "elasticfilesystem",\n    "name": "EFS"\n  },\n  "elasticache": {\n    "name": "ElastiCache",\n    "versions": [\n      "2012-11-15*",\n      "2014-03-24*",\n      "2014-07-15*",\n      "2014-09-30*"\n    ],\n    "cors": true\n  },\n  "elasticbeanstalk": {\n    "name": "ElasticBeanstalk",\n    "cors": true\n  },\n  "elb": {\n    "prefix": "elasticloadbalancing",\n    "name": "ELB",\n    "cors": true\n  },\n  "elbv2": {\n    "prefix": "elasticloadbalancingv2",\n    "name": "ELBv2",\n    "cors": true\n  },\n  "emr": {\n    "prefix": "elasticmapreduce",\n    "name": "EMR",\n    "cors": true\n  },\n  "es": {\n    "name": "ES"\n  },\n  "elastictranscoder": {\n    "name": "ElasticTranscoder",\n    "cors": true\n  },\n  "firehose": {\n    "name": "Firehose",\n    "cors": true\n  },\n  "gamelift": {\n    "name": "GameLift",\n    "cors": true\n  },\n  "glacier": {\n    "name": "Glacier"\n  },\n  "iam": {\n    "name": "IAM"\n  },\n  "importexport": {\n    "name": "ImportExport"\n  },\n  "inspector": {\n    "name": "Inspector",\n    "versions": [\n      "2015-08-18*"\n    ],\n    "cors": true\n  },\n  "iot": {\n    "name": "Iot",\n    "cors": true\n  },\n  "iotdata": {\n    "prefix": "iot-data",\n    "name": "IotData",\n    "cors": true\n  },\n  "kinesis": {\n    "name": "Kinesis",\n    "cors": true\n  },\n  "kinesisanalytics": {\n    "name": "KinesisAnalytics"\n  },\n  "kms": {\n    "name": "KMS",\n    "cors": true\n  },\n  "lambda": {\n    "name": "Lambda",\n    "cors": true\n  },\n  "machinelearning": {\n    "name": "MachineLearning",\n    "cors": true\n  },\n  "marketplacecommerceanalytics": {\n    "name": "MarketplaceCommerceAnalytics",\n    "cors": true\n  },\n  "marketplacemetering": {\n    "prefix": "meteringmarketplace",\n    "name": "MarketplaceMetering"\n  },\n  "mobileanalytics": {\n    "name": "MobileAnalytics",\n    "cors": true\n  },\n  "opsworks": {\n    "name": "OpsWorks",\n    "cors": true\n  },\n  "rds": {\n    "name": "RDS",\n    "versions": [\n      "2014-09-01*"\n    ],\n    "cors": true\n  },\n  "redshift": {\n    "name": "Redshift",\n    "cors": true\n  },\n  "route53": {\n    "name": "Route53",\n    "cors": true\n  },\n  "route53domains": {\n    "name": "Route53Domains",\n    "cors": true\n  },\n  "s3": {\n    "name": "S3",\n    "dualstackAvailable": true,\n    "cors": true\n  },\n  "servicecatalog": {\n    "name": "ServiceCatalog",\n    "cors": true\n  },\n  "ses": {\n    "prefix": "email",\n    "name": "SES",\n    "cors": true\n  },\n  "simpledb": {\n    "prefix": "sdb",\n    "name": "SimpleDB"\n  },\n  "sms": {\n    "name": "SMS"\n  },\n  "snowball": {\n    "name": "Snowball"\n  },\n  "sns": {\n    "name": "SNS",\n    "cors": true\n  },\n  "sqs": {\n    "name": "SQS",\n    "cors": true\n  },\n  "ssm": {\n    "name": "SSM",\n    "cors": true\n  },\n  "storagegateway": {\n    "name": "StorageGateway",\n    "cors": true\n  },\n  "sts": {\n    "name": "STS",\n    "cors": true\n  },\n  "support": {\n    "name": "Support"\n  },\n  "swf": {\n    "name": "SWF"\n  },\n  "waf": {\n    "name": "WAF",\n    "cors": true\n  },\n  "workspaces": {\n    "name": "WorkSpaces"\n  }\n}\n\n},{}],4:[function(require,module,exports){\nmodule.exports={\n  "version": "2.0",\n  "metadata": {\n    "apiVersion": "2011-06-15",\n    "endpointPrefix": "sts",\n    "globalEndpoint": "sts.amazonaws.com",\n    "protocol": "query",\n    "serviceAbbreviation": "AWS STS",\n    "serviceFullName": "AWS Security Token Service",\n    "signatureVersion": "v4",\n    "xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"\n  },\n  "operations": {\n    "AssumeRole": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "RoleArn",\n          "RoleSessionName"\n        ],\n        "members": {\n          "RoleArn": {},\n          "RoleSessionName": {},\n          "Policy": {},\n          "DurationSeconds": {\n            "type": "integer"\n          },\n          "ExternalId": {},\n          "SerialNumber": {},\n          "TokenCode": {}\n        }\n      },\n      "output": {\n        "resultWrapper": "AssumeRoleResult",\n        "type": "structure",\n        "members": {\n          "Credentials": {\n            "shape": "Sa"\n          },\n          "AssumedRoleUser": {\n            "shape": "Sf"\n          },\n          "PackedPolicySize": {\n            "type": "integer"\n          }\n        }\n      }\n    },\n    "AssumeRoleWithSAML": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "RoleArn",\n          "PrincipalArn",\n          "SAMLAssertion"\n        ],\n        "members": {\n          "RoleArn": {},\n          "PrincipalArn": {},\n          "SAMLAssertion": {},\n          "Policy": {},\n          "DurationSeconds": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "resultWrapper": "AssumeRoleWithSAMLResult",\n        "type": "structure",\n        "members": {\n          "Credentials": {\n            "shape": "Sa"\n          },\n          "AssumedRoleUser": {\n            "shape": "Sf"\n          },\n          "PackedPolicySize": {\n            "type": "integer"\n          },\n          "Subject": {},\n          "SubjectType": {},\n          "Issuer": {},\n          "Audience": {},\n          "NameQualifier": {}\n        }\n      }\n    },\n    "AssumeRoleWithWebIdentity": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "RoleArn",\n          "RoleSessionName",\n          "WebIdentityToken"\n        ],\n        "members": {\n          "RoleArn": {},\n          "RoleSessionName": {},\n          "WebIdentityToken": {},\n          "ProviderId": {},\n          "Policy": {},\n          "DurationSeconds": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "resultWrapper": "AssumeRoleWithWebIdentityResult",\n        "type": "structure",\n        "members": {\n          "Credentials": {\n            "shape": "Sa"\n          },\n          "SubjectFromWebIdentityToken": {},\n          "AssumedRoleUser": {\n            "shape": "Sf"\n          },\n          "PackedPolicySize": {\n            "type": "integer"\n          },\n          "Provider": {},\n          "Audience": {}\n        }\n      }\n    },\n    "DecodeAuthorizationMessage": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "EncodedMessage"\n        ],\n        "members": {\n          "EncodedMessage": {}\n        }\n      },\n      "output": {\n        "resultWrapper": "DecodeAuthorizationMessageResult",\n        "type": "structure",\n        "members": {\n          "DecodedMessage": {}\n        }\n      }\n    },\n    "GetCallerIdentity": {\n      "input": {\n        "type": "structure",\n        "members": {}\n      },\n      "output": {\n        "resultWrapper": "GetCallerIdentityResult",\n        "type": "structure",\n        "members": {\n          "UserId": {},\n          "Account": {},\n          "Arn": {}\n        }\n      }\n    },\n    "GetFederationToken": {\n      "input": {\n        "type": "structure",\n        "required": [\n          "Name"\n        ],\n        "members": {\n          "Name": {},\n          "Policy": {},\n          "DurationSeconds": {\n            "type": "integer"\n          }\n        }\n      },\n      "output": {\n        "resultWrapper": "GetFederationTokenResult",\n        "type": "structure",\n        "members": {\n          "Credentials": {\n            "shape": "Sa"\n          },\n          "FederatedUser": {\n            "type": "structure",\n            "required": [\n              "FederatedUserId",\n              "Arn"\n            ],\n            "members": {\n              "FederatedUserId": {},\n              "Arn": {}\n            }\n          },\n          "PackedPolicySize": {\n            "type": "integer"\n          }\n        }\n      }\n    },\n    "GetSessionToken": {\n      "input": {\n        "type": "structure",\n        "members": {\n          "DurationSeconds": {\n            "type": "integer"\n          },\n          "SerialNumber": {},\n          "TokenCode": {}\n        }\n      },\n      "output": {\n        "resultWrapper": "GetSessionTokenResult",\n        "type": "structure",\n        "members": {\n          "Credentials": {\n            "shape": "Sa"\n          }\n        }\n      }\n    }\n  },\n  "shapes": {\n    "Sa": {\n      "type": "structure",\n      "required": [\n        "AccessKeyId",\n        "SecretAccessKey",\n        "SessionToken",\n        "Expiration"\n      ],\n      "members": {\n        "AccessKeyId": {},\n        "SecretAccessKey": {},\n        "SessionToken": {},\n        "Expiration": {\n          "type": "timestamp"\n        }\n      }\n    },\n    "Sf": {\n      "type": "structure",\n      "required": [\n        "AssumedRoleId",\n        "Arn"\n      ],\n      "members": {\n        "AssumedRoleId": {},\n        "Arn": {}\n      }\n    }\n  }\n}\n},{}],5:[function(require,module,exports){\nrequire(\'../lib/node_loader\');\nvar AWS = require(\'../lib/core\');\nvar Service = require(\'../lib/service\');\nvar apiLoader = require(\'../lib/api_loader\');\n\napiLoader.services[\'cognitoidentity\'] = {};\nAWS.CognitoIdentity = Service.defineService(\'cognitoidentity\', [\'2014-06-30\']);\nrequire(\'../lib/services/cognitoidentity\');\nObject.defineProperty(apiLoader.services[\'cognitoidentity\'], \'2014-06-30\', {\n  get: function get() {\n    var model = require(\'../apis/cognito-identity-2014-06-30.min.json\');\n    return model;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nmodule.exports = AWS.CognitoIdentity;\n\n},{"../apis/cognito-identity-2014-06-30.min.json":1,"../lib/api_loader":7,"../lib/core":10,"../lib/node_loader":8,"../lib/service":41,"../lib/services/cognitoidentity":42}],6:[function(require,module,exports){\nrequire(\'../lib/node_loader\');\nvar AWS = require(\'../lib/core\');\nvar Service = require(\'../lib/service\');\nvar apiLoader = require(\'../lib/api_loader\');\n\napiLoader.services[\'sts\'] = {};\nAWS.STS = Service.defineService(\'sts\', [\'2011-06-15\']);\nrequire(\'../lib/services/sts\');\nObject.defineProperty(apiLoader.services[\'sts\'], \'2011-06-15\', {\n  get: function get() {\n    var model = require(\'../apis/sts-2011-06-15.min.json\');\n    return model;\n  },\n  enumerable: true,\n  configurable: true\n});\n\nmodule.exports = AWS.STS;\n\n},{"../apis/sts-2011-06-15.min.json":4,"../lib/api_loader":7,"../lib/core":10,"../lib/node_loader":8,"../lib/service":41,"../lib/services/sts":43}],7:[function(require,module,exports){\nvar AWS = require(\'./core\');\n\nAWS.apiLoader = function(svc, version) {\n  if (!AWS.apiLoader.services.hasOwnProperty(svc)) {\n    throw new Error(\'InvalidService: Failed to load api for \' + svc);\n  }\n  return AWS.apiLoader.services[svc][version];\n};\n\nAWS.apiLoader.services = {};\n\nmodule.exports = AWS.apiLoader;\n},{"./core":10}],8:[function(require,module,exports){\n(function (process){\nvar util = require(\'./util\');\n\nutil.crypto.lib = require(\'crypto-browserify\');\nutil.Buffer = require(\'buffer/\').Buffer;\nutil.url = require(\'url/\');\nutil.querystring = require(\'querystring/\');\n\nvar AWS = require(\'./core\');\n\nrequire(\'./api_loader\');\n\nAWS.XML.Parser = require(\'./xml/browser_parser\');\n\nrequire(\'./http/xhr\');\n\nif (typeof process === \'undefined\') {\n  process = {\n    browser: true\n  };\n}\n}).call(this,require(\'_process\'))\n},{"./api_loader":7,"./core":10,"./http/xhr":19,"./util":52,"./xml/browser_parser":53,"_process":117,"buffer/":58,"crypto-browserify":60,"querystring/":124,"url/":125}],9:[function(require,module,exports){\nvar AWS = require(\'./core\');\nrequire(\'./credentials\');\nrequire(\'./credentials/credential_provider_chain\');\nvar PromisesDependency;\n\n\nAWS.Config = AWS.util.inherit({\n\n\n\n  constructor: function Config(options) {\n    if (options === undefined) options = {};\n    options = this.extractCredentials(options);\n\n    AWS.util.each.call(this, this.keys, function (key, value) {\n      this.set(key, options[key], value);\n    });\n  },\n\n\n\n\n  getCredentials: function getCredentials(callback) {\n    var self = this;\n\n    function finish(err) {\n      callback(err, err ? null : self.credentials);\n    }\n\n    function credError(msg, err) {\n      return new AWS.util.error(err || new Error(), {\n        code: \'CredentialsError\', message: msg\n      });\n    }\n\n    function getAsyncCredentials() {\n      self.credentials.get(function(err) {\n        if (err) {\n          var msg = \'Could not load credentials from \' +\n            self.credentials.constructor.name;\n          err = credError(msg, err);\n        }\n        finish(err);\n      });\n    }\n\n    function getStaticCredentials() {\n      var err = null;\n      if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {\n        err = credError(\'Missing credentials\');\n      }\n      finish(err);\n    }\n\n    if (self.credentials) {\n      if (typeof self.credentials.get === \'function\') {\n        getAsyncCredentials();\n      } else { // static credentials\n        getStaticCredentials();\n      }\n    } else if (self.credentialProvider) {\n      self.credentialProvider.resolve(function(err, creds) {\n        if (err) {\n          err = credError(\'Could not load credentials from any providers\', err);\n        }\n        self.credentials = creds;\n        finish(err);\n      });\n    } else {\n      finish(credError(\'No credentials to load\'));\n    }\n  },\n\n\n\n\n  update: function update(options, allowUnknownKeys) {\n    allowUnknownKeys = allowUnknownKeys || false;\n    options = this.extractCredentials(options);\n    AWS.util.each.call(this, options, function (key, value) {\n      if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||\n          AWS.Service.hasService(key)) {\n        this.set(key, value);\n      }\n    });\n  },\n\n\n  loadFromPath: function loadFromPath(path) {\n    this.clear();\n\n    var options = JSON.parse(AWS.util.readFileSync(path));\n    var fileSystemCreds = new AWS.FileSystemCredentials(path);\n    var chain = new AWS.CredentialProviderChain();\n    chain.providers.unshift(fileSystemCreds);\n    chain.resolve(function (err, creds) {\n      if (err) throw err;\n      else options.credentials = creds;\n    });\n\n    this.constructor(options);\n\n    return this;\n  },\n\n\n  clear: function clear() {\n\n    AWS.util.each.call(this, this.keys, function (key) {\n      delete this[key];\n    });\n\n    this.set(\'credentials\', undefined);\n    this.set(\'credentialProvider\', undefined);\n  },\n\n\n  set: function set(property, value, defaultValue) {\n    if (value === undefined) {\n      if (defaultValue === undefined) {\n        defaultValue = this.keys[property];\n      }\n      if (typeof defaultValue === \'function\') {\n        this[property] = defaultValue.call(this);\n      } else {\n        this[property] = defaultValue;\n      }\n    } else if (property === \'httpOptions\' && this[property]) {\n      this[property] = AWS.util.merge(this[property], value);\n    } else {\n      this[property] = value;\n    }\n  },\n\n\n  keys: {\n    credentials: null,\n    credentialProvider: null,\n    region: null,\n    logger: null,\n    apiVersions: {},\n    apiVersion: null,\n    endpoint: undefined,\n    httpOptions: {\n      timeout: 120000\n    },\n    maxRetries: undefined,\n    maxRedirects: 10,\n    paramValidation: true,\n    sslEnabled: true,\n    s3ForcePathStyle: false,\n    s3BucketEndpoint: false,\n    s3DisableBodySigning: true,\n    computeChecksums: true,\n    convertResponseTypes: true,\n    correctClockSkew: false,\n    customUserAgent: null,\n    dynamoDbCrc32: true,\n    systemClockOffset: 0,\n    signatureVersion: null,\n    signatureCache: true,\n    retryDelayOptions: {\n      base: 100\n    },\n    useAccelerateEndpoint: false\n  },\n\n\n  extractCredentials: function extractCredentials(options) {\n    if (options.accessKeyId && options.secretAccessKey) {\n      options = AWS.util.copy(options);\n      options.credentials = new AWS.Credentials(options);\n    }\n    return options;\n  },\n\n\n  setPromisesDependency: function setPromisesDependency(dep) {\n    PromisesDependency = dep;\n    var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];\n    if (AWS.S3 && AWS.S3.ManagedUpload) constructors.push(AWS.S3.ManagedUpload);\n    AWS.util.addPromises(constructors, dep);\n  },\n\n\n  getPromisesDependency: function getPromisesDependency() {\n    return PromisesDependency;\n  }\n});\n\n\nAWS.config = new AWS.Config();\n\n},{"./core":10,"./credentials":11,"./credentials/credential_provider_chain":13}],10:[function(require,module,exports){\n\nvar AWS = { util: require(\'./util\') };\n\n\nvar _hidden = {}; _hidden.toString(); // hack to parse macro\n\nmodule.exports = AWS;\n\nAWS.util.update(AWS, {\n\n\n  VERSION: \'2.7.0\',\n\n\n  Signers: {},\n\n\n  Protocol: {\n    Json: require(\'./protocol/json\'),\n    Query: require(\'./protocol/query\'),\n    Rest: require(\'./protocol/rest\'),\n    RestJson: require(\'./protocol/rest_json\'),\n    RestXml: require(\'./protocol/rest_xml\')\n  },\n\n\n  XML: {\n    Builder: require(\'./xml/builder\'),\n    Parser: null // conditionally set based on environment\n  },\n\n\n  JSON: {\n    Builder: require(\'./json/builder\'),\n    Parser: require(\'./json/parser\')\n  },\n\n\n  Model: {\n    Api: require(\'./model/api\'),\n    Operation: require(\'./model/operation\'),\n    Shape: require(\'./model/shape\'),\n    Paginator: require(\'./model/paginator\'),\n    ResourceWaiter: require(\'./model/resource_waiter\')\n  },\n\n  util: require(\'./util\'),\n\n\n  apiLoader: function() { throw new Error(\'No API loader set\'); }\n});\n\nrequire(\'./service\');\n\nrequire(\'./credentials\');\nrequire(\'./credentials/credential_provider_chain\');\nrequire(\'./credentials/temporary_credentials\');\nrequire(\'./credentials/web_identity_credentials\');\nrequire(\'./credentials/cognito_identity_credentials\');\nrequire(\'./credentials/saml_credentials\');\n\nrequire(\'./config\');\nrequire(\'./http\');\nrequire(\'./sequential_executor\');\nrequire(\'./event_listeners\');\nrequire(\'./request\');\nrequire(\'./response\');\nrequire(\'./resource_waiter\');\nrequire(\'./signers/request_signer\');\nrequire(\'./param_validator\');\n\n\nAWS.events = new AWS.SequentialExecutor();\n\n},{"./config":9,"./credentials":11,"./credentials/cognito_identity_credentials":12,"./credentials/credential_provider_chain":13,"./credentials/saml_credentials":14,"./credentials/temporary_credentials":15,"./credentials/web_identity_credentials":16,"./event_listeners":17,"./http":18,"./json/builder":20,"./json/parser":21,"./model/api":22,"./model/operation":24,"./model/paginator":25,"./model/resource_waiter":26,"./model/shape":27,"./param_validator":28,"./protocol/json":29,"./protocol/query":30,"./protocol/rest":31,"./protocol/rest_json":32,"./protocol/rest_xml":33,"./request":37,"./resource_waiter":38,"./response":39,"./sequential_executor":40,"./service":41,"./signers/request_signer":45,"./util":52,"./xml/builder":54}],11:[function(require,module,exports){\nvar AWS = require(\'./core\');\n\n\nAWS.Credentials = AWS.util.inherit({\n\n  constructor: function Credentials() {\n    AWS.util.hideProperties(this, [\'secretAccessKey\']);\n\n    this.expired = false;\n    this.expireTime = null;\n    if (arguments.length === 1 && typeof arguments[0] === \'object\') {\n      var creds = arguments[0].credentials || arguments[0];\n      this.accessKeyId = creds.accessKeyId;\n      this.secretAccessKey = creds.secretAccessKey;\n      this.sessionToken = creds.sessionToken;\n    } else {\n      this.accessKeyId = arguments[0];\n      this.secretAccessKey = arguments[1];\n      this.sessionToken = arguments[2];\n    }\n  },\n\n\n  expiryWindow: 15,\n\n\n  needsRefresh: function needsRefresh() {\n    var currentTime = AWS.util.date.getDate().getTime();\n    var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);\n\n    if (this.expireTime && adjustedTime > this.expireTime) {\n      return true;\n    } else {\n      return this.expired || !this.accessKeyId || !this.secretAccessKey;\n    }\n  },\n\n\n  get: function get(callback) {\n    var self = this;\n    if (this.needsRefresh()) {\n      this.refresh(function(err) {\n        if (!err) self.expired = false; // reset expired flag\n        if (callback) callback(err);\n      });\n    } else if (callback) {\n      callback();\n    }\n  },\n\n\n\n\n\n\n  refresh: function refresh(callback) {\n    this.expired = false;\n    callback();\n  }\n});\n\n\nAWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.getPromise = AWS.util.promisifyMethod(\'get\', PromiseDependency);\n  this.prototype.refreshPromise = AWS.util.promisifyMethod(\'refresh\', PromiseDependency);\n};\n\n\nAWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.getPromise;\n  delete this.prototype.refreshPromise;\n};\n\nAWS.util.addPromises(AWS.Credentials);\n\n},{"./core":10}],12:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar CognitoIdentity = require(\'../../clients/cognitoidentity\');\nvar STS = require(\'../../clients/sts\');\n\n\nAWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {\n\n  localStorageKey: {\n    id: \'aws.cognito.identity-id.\',\n    providers: \'aws.cognito.identity-providers.\'\n  },\n\n\n  constructor: function CognitoIdentityCredentials(params) {\n    AWS.Credentials.call(this);\n    this.expired = true;\n    this.params = params;\n    this.data = null;\n    this.identityId = null;\n    this.loadCachedId();\n  },\n\n\n  refresh: function refresh(callback) {\n    var self = this;\n    self.createClients();\n    self.data = null;\n    self.identityId = null;\n    self.getId(function(err) {\n      if (!err) {\n        if (!self.params.RoleArn) {\n          self.getCredentialsForIdentity(callback);\n        } else {\n          self.getCredentialsFromSTS(callback);\n        }\n      } else {\n        self.clearIdOnNotAuthorized(err);\n        callback(err);\n      }\n    });\n  },\n\n\n  clearCachedId: function clearCache() {\n    this.identityId = null;\n    delete this.params.IdentityId;\n\n    var poolId = this.params.IdentityPoolId;\n    var loginId = this.params.LoginId || \'\';\n    delete this.storage[this.localStorageKey.id + poolId + loginId];\n    delete this.storage[this.localStorageKey.providers + poolId + loginId];\n  },\n\n\n  clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {\n    var self = this;\n    if (err.code == \'NotAuthorizedException\') {\n      self.clearCachedId();\n    }\n  },\n\n\n  getId: function getId(callback) {\n    var self = this;\n    if (typeof self.params.IdentityId === \'string\') {\n      return callback(null, self.params.IdentityId);\n    }\n\n    self.cognito.getId(function(err, data) {\n      if (!err && data.IdentityId) {\n        self.params.IdentityId = data.IdentityId;\n        callback(null, data.IdentityId);\n      } else {\n        callback(err);\n      }\n    });\n  },\n\n\n\n  loadCredentials: function loadCredentials(data, credentials) {\n    if (!data || !credentials) return;\n    credentials.expired = false;\n    credentials.accessKeyId = data.Credentials.AccessKeyId;\n    credentials.secretAccessKey = data.Credentials.SecretKey;\n    credentials.sessionToken = data.Credentials.SessionToken;\n    credentials.expireTime = data.Credentials.Expiration;\n  },\n\n\n  getCredentialsForIdentity: function getCredentialsForIdentity(callback) {\n    var self = this;\n    self.cognito.getCredentialsForIdentity(function(err, data) {\n      if (!err) {\n        self.cacheId(data);\n        self.data = data;\n        self.loadCredentials(self.data, self);\n      } else {\n        self.clearIdOnNotAuthorized(err);\n      }\n      callback(err);\n    });\n  },\n\n\n  getCredentialsFromSTS: function getCredentialsFromSTS(callback) {\n    var self = this;\n    self.cognito.getOpenIdToken(function(err, data) {\n      if (!err) {\n        self.cacheId(data);\n        self.params.WebIdentityToken = data.Token;\n        self.webIdentityCredentials.refresh(function(webErr) {\n          if (!webErr) {\n            self.data = self.webIdentityCredentials.data;\n            self.sts.credentialsFrom(self.data, self);\n          }\n          callback(webErr);\n        });\n      } else {\n        self.clearIdOnNotAuthorized(err);\n        callback(err);\n      }\n    });\n  },\n\n\n  loadCachedId: function loadCachedId() {\n    var self = this;\n\n    if (AWS.util.isBrowser() && !self.params.IdentityId) {\n      var id = self.getStorage(\'id\');\n      if (id && self.params.Logins) {\n        var actualProviders = Object.keys(self.params.Logins);\n        var cachedProviders =\n          (self.getStorage(\'providers\') || \'\').split(\',\');\n\n        var intersect = cachedProviders.filter(function(n) {\n          return actualProviders.indexOf(n) !== -1;\n        });\n        if (intersect.length !== 0) {\n          self.params.IdentityId = id;\n        }\n      } else if (id) {\n        self.params.IdentityId = id;\n      }\n    }\n  },\n\n\n  createClients: function() {\n    this.webIdentityCredentials = this.webIdentityCredentials ||\n      new AWS.WebIdentityCredentials(this.params);\n    this.cognito = this.cognito ||\n      new CognitoIdentity({params: this.params});\n    this.sts = this.sts || new STS();\n  },\n\n\n  cacheId: function cacheId(data) {\n    this.identityId = data.IdentityId;\n    this.params.IdentityId = this.identityId;\n\n    if (AWS.util.isBrowser()) {\n      this.setStorage(\'id\', data.IdentityId);\n\n      if (this.params.Logins) {\n        this.setStorage(\'providers\', Object.keys(this.params.Logins).join(\',\'));\n      }\n    }\n  },\n\n\n  getStorage: function getStorage(key) {\n    return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || \'\')];\n  },\n\n\n  setStorage: function setStorage(key, val) {\n    try {\n      this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || \'\')] = val;\n    } catch (_) {}\n  },\n\n\n  storage: (function() {\n    try {\n      return AWS.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === \'object\' ?\n             window.localStorage : {};\n    } catch (_) {\n      return {};\n    }\n  })()\n});\n\n},{"../../clients/cognitoidentity":5,"../../clients/sts":6,"../core":10}],13:[function(require,module,exports){\nvar AWS = require(\'../core\');\n\n\nAWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {\n\n\n  constructor: function CredentialProviderChain(providers) {\n    if (providers) {\n      this.providers = providers;\n    } else {\n      this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);\n    }\n  },\n\n\n\n\n  resolve: function resolve(callback) {\n    if (this.providers.length === 0) {\n      callback(new Error(\'No providers\'));\n      return this;\n    }\n\n    var index = 0;\n    var providers = this.providers.slice(0);\n\n    function resolveNext(err, creds) {\n      if ((!err && creds) || index === providers.length) {\n        callback(err, creds);\n        return;\n      }\n\n      var provider = providers[index++];\n      if (typeof provider === \'function\') {\n        creds = provider.call();\n      } else {\n        creds = provider;\n      }\n\n      if (creds.get) {\n        creds.get(function(getErr) {\n          resolveNext(getErr, getErr ? null : creds);\n        });\n      } else {\n        resolveNext(null, creds);\n      }\n    }\n\n    resolveNext();\n    return this;\n  }\n});\n\n\nAWS.CredentialProviderChain.defaultProviders = [];\n\n\nAWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.resolvePromise = AWS.util.promisifyMethod(\'resolve\', PromiseDependency);\n};\n\n\nAWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.resolvePromise;\n};\n\nAWS.util.addPromises(AWS.CredentialProviderChain);\n\n},{"../core":10}],14:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar STS = require(\'../../clients/sts\');\n\n\nAWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {\n\n  constructor: function SAMLCredentials(params) {\n    AWS.Credentials.call(this);\n    this.expired = true;\n    this.params = params;\n  },\n\n\n  refresh: function refresh(callback) {\n    var self = this;\n    self.createClients();\n    if (!callback) callback = function(err) { if (err) throw err; };\n\n    self.service.assumeRoleWithSAML(function (err, data) {\n      if (!err) {\n        self.service.credentialsFrom(data, self);\n      }\n      callback(err);\n    });\n  },\n\n\n  createClients: function() {\n    this.service = this.service || new STS({params: this.params});\n  }\n\n});\n\n},{"../../clients/sts":6,"../core":10}],15:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar STS = require(\'../../clients/sts\');\n\n\nAWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {\n\n  constructor: function TemporaryCredentials(params) {\n    AWS.Credentials.call(this);\n    this.loadMasterCredentials();\n    this.expired = true;\n\n    this.params = params || {};\n    if (this.params.RoleArn) {\n      this.params.RoleSessionName =\n        this.params.RoleSessionName || \'temporary-credentials\';\n    }\n  },\n\n\n  refresh: function refresh(callback) {\n    var self = this;\n    self.createClients();\n    if (!callback) callback = function(err) { if (err) throw err; };\n\n    self.service.config.credentials = self.masterCredentials;\n    var operation = self.params.RoleArn ?\n      self.service.assumeRole : self.service.getSessionToken;\n    operation.call(self.service, function (err, data) {\n      if (!err) {\n        self.service.credentialsFrom(data, self);\n      }\n      callback(err);\n    });\n  },\n\n\n  loadMasterCredentials: function loadMasterCredentials() {\n    this.masterCredentials = AWS.config.credentials;\n    while (this.masterCredentials.masterCredentials) {\n      this.masterCredentials = this.masterCredentials.masterCredentials;\n    }\n  },\n\n\n  createClients: function() {\n    this.service = this.service || new STS({params: this.params});\n  }\n\n});\n\n},{"../../clients/sts":6,"../core":10}],16:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar STS = require(\'../../clients/sts\');\n\n\nAWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {\n\n  constructor: function WebIdentityCredentials(params) {\n    AWS.Credentials.call(this);\n    this.expired = true;\n    this.params = params;\n    this.params.RoleSessionName = this.params.RoleSessionName || \'web-identity\';\n    this.data = null;\n  },\n\n\n  refresh: function refresh(callback) {\n    var self = this;\n    self.createClients();\n    if (!callback) callback = function(err) { if (err) throw err; };\n\n    self.service.assumeRoleWithWebIdentity(function (err, data) {\n      self.data = null;\n      if (!err) {\n        self.data = data;\n        self.service.credentialsFrom(data, self);\n      }\n      callback(err);\n    });\n  },\n\n\n  createClients: function() {\n    this.service = this.service || new STS({params: this.params});\n  }\n\n});\n\n},{"../../clients/sts":6,"../core":10}],17:[function(require,module,exports){\nvar AWS = require(\'./core\');\nvar SequentialExecutor = require(\'./sequential_executor\');\n\n\nAWS.EventListeners = {\n\n  Core: {} /* doc hack */\n};\n\nAWS.EventListeners = {\n  Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {\n    addAsync(\'VALIDATE_CREDENTIALS\', \'validate\',\n        function VALIDATE_CREDENTIALS(req, done) {\n      if (!req.service.api.signatureVersion) return done(); // none\n      req.service.config.getCredentials(function(err) {\n        if (err) {\n          req.response.error = AWS.util.error(err,\n            {code: \'CredentialsError\', message: \'Missing credentials in config\'});\n        }\n        done();\n      });\n    });\n\n    add(\'VALIDATE_REGION\', \'validate\', function VALIDATE_REGION(req) {\n      if (!req.service.config.region && !req.service.isGlobalEndpoint) {\n        req.response.error = AWS.util.error(new Error(),\n          {code: \'ConfigError\', message: \'Missing region in config\'});\n      }\n    });\n\n    add(\'VALIDATE_PARAMETERS\', \'validate\', function VALIDATE_PARAMETERS(req) {\n      var rules = req.service.api.operations[req.operation].input;\n      var validation = req.service.config.paramValidation;\n      new AWS.ParamValidator(validation).validate(rules, req.params);\n    });\n\n    addAsync(\'COMPUTE_SHA256\', \'afterBuild\', function COMPUTE_SHA256(req, done) {\n      req.haltHandlersOnError();\n      if (!req.service.api.signatureVersion) return done(); // none\n      if (req.service.getSignerClass(req) === AWS.Signers.V4) {\n        var body = req.httpRequest.body || \'\';\n        AWS.util.computeSha256(body, function(err, sha) {\n          if (err) {\n            done(err);\n          }\n          else {\n            req.httpRequest.headers[\'X-Amz-Content-Sha256\'] = sha;\n            done();\n          }\n        });\n      } else {\n        done();\n      }\n    });\n\n    add(\'SET_CONTENT_LENGTH\', \'afterBuild\', function SET_CONTENT_LENGTH(req) {\n      if (req.httpRequest.headers[\'Content-Length\'] === undefined) {\n        var length = AWS.util.string.byteLength(req.httpRequest.body);\n        req.httpRequest.headers[\'Content-Length\'] = length;\n      }\n    });\n\n    add(\'SET_HTTP_HOST\', \'afterBuild\', function SET_HTTP_HOST(req) {\n      req.httpRequest.headers[\'Host\'] = req.httpRequest.endpoint.host;\n    });\n\n    add(\'RESTART\', \'restart\', function RESTART() {\n      var err = this.response.error;\n      if (!err || !err.retryable) return;\n\n      this.httpRequest = new AWS.HttpRequest(\n        this.service.endpoint,\n        this.service.region\n      );\n\n      if (this.response.retryCount < this.service.config.maxRetries) {\n        this.response.retryCount++;\n      } else {\n        this.response.error = null;\n      }\n    });\n\n    addAsync(\'SIGN\', \'sign\', function SIGN(req, done) {\n      var service = req.service;\n      if (!service.api.signatureVersion) return done(); // none\n\n      service.config.getCredentials(function (err, credentials) {\n        if (err) {\n          req.response.error = err;\n          return done();\n        }\n\n        try {\n          var date = AWS.util.date.getDate();\n          var SignerClass = service.getSignerClass(req);\n          var signer = new SignerClass(req.httpRequest,\n            service.api.signingName || service.api.endpointPrefix,\n           service.config.signatureCache);\n          signer.setServiceClientId(service._clientId);\n\n          delete req.httpRequest.headers[\'Authorization\'];\n          delete req.httpRequest.headers[\'Date\'];\n          delete req.httpRequest.headers[\'X-Amz-Date\'];\n\n          signer.addAuthorization(credentials, date);\n          req.signedAt = date;\n        } catch (e) {\n          req.response.error = e;\n        }\n        done();\n      });\n    });\n\n    add(\'VALIDATE_RESPONSE\', \'validateResponse\', function VALIDATE_RESPONSE(resp) {\n      if (this.service.successfulResponse(resp, this)) {\n        resp.data = {};\n        resp.error = null;\n      } else {\n        resp.data = null;\n        resp.error = AWS.util.error(new Error(),\n          {code: \'UnknownError\', message: \'An unknown error occurred.\'});\n      }\n    });\n\n    addAsync(\'SEND\', \'send\', function SEND(resp, done) {\n      resp.httpResponse._abortCallback = done;\n      resp.error = null;\n      resp.data = null;\n\n      function callback(httpResp) {\n        resp.httpResponse.stream = httpResp;\n\n        httpResp.on(\'headers\', function onHeaders(statusCode, headers) {\n          resp.request.emit(\'httpHeaders\', [statusCode, headers, resp]);\n\n          if (!resp.httpResponse.streaming) {\n            if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check\n              httpResp.on(\'readable\', function onReadable() {\n                var data = httpResp.read();\n                if (data !== null) {\n                  resp.request.emit(\'httpData\', [data, resp]);\n                }\n              });\n            } else { // legacy streams API\n              httpResp.on(\'data\', function onData(data) {\n                resp.request.emit(\'httpData\', [data, resp]);\n              });\n            }\n          }\n        });\n\n        httpResp.on(\'end\', function onEnd() {\n          resp.request.emit(\'httpDone\');\n          done();\n        });\n      }\n\n      function progress(httpResp) {\n        httpResp.on(\'sendProgress\', function onSendProgress(value) {\n          resp.request.emit(\'httpUploadProgress\', [value, resp]);\n        });\n\n        httpResp.on(\'receiveProgress\', function onReceiveProgress(value) {\n          resp.request.emit(\'httpDownloadProgress\', [value, resp]);\n        });\n      }\n\n      function error(err) {\n        resp.error = AWS.util.error(err, {\n          code: \'NetworkingError\',\n          region: resp.request.httpRequest.region,\n          hostname: resp.request.httpRequest.endpoint.hostname,\n          retryable: true\n        });\n        resp.request.emit(\'httpError\', [resp.error, resp], function() {\n          done();\n        });\n      }\n\n      function executeSend() {\n        var http = AWS.HttpClient.getInstance();\n        var httpOptions = resp.request.service.config.httpOptions || {};\n        try {\n          var stream = http.handleRequest(resp.request.httpRequest, httpOptions,\n                                          callback, error);\n          progress(stream);\n        } catch (err) {\n          error(err);\n        }\n      }\n\n      var timeDiff = (AWS.util.date.getDate() - this.signedAt) / 1000;\n      if (timeDiff >= 60 * 10) { // if we signed 10min ago, re-sign\n        this.emit(\'sign\', [this], function(err) {\n          if (err) done(err);\n          else executeSend();\n        });\n      } else {\n        executeSend();\n      }\n    });\n\n    add(\'HTTP_HEADERS\', \'httpHeaders\',\n        function HTTP_HEADERS(statusCode, headers, resp) {\n      resp.httpResponse.statusCode = statusCode;\n      resp.httpResponse.headers = headers;\n      resp.httpResponse.body = new AWS.util.Buffer(\'\');\n      resp.httpResponse.buffers = [];\n      resp.httpResponse.numBytes = 0;\n      var dateHeader = headers.date || headers.Date;\n      if (dateHeader) {\n        var serverTime = Date.parse(dateHeader);\n        if (resp.request.service.config.correctClockSkew\n            && AWS.util.isClockSkewed(serverTime)) {\n          AWS.util.applyClockOffset(serverTime);\n        }\n      }\n    });\n\n    add(\'HTTP_DATA\', \'httpData\', function HTTP_DATA(chunk, resp) {\n      if (chunk) {\n        if (AWS.util.isNode()) {\n          resp.httpResponse.numBytes += chunk.length;\n\n          var total = resp.httpResponse.headers[\'content-length\'];\n          var progress = { loaded: resp.httpResponse.numBytes, total: total };\n          resp.request.emit(\'httpDownloadProgress\', [progress, resp]);\n        }\n\n        resp.httpResponse.buffers.push(new AWS.util.Buffer(chunk));\n      }\n    });\n\n    add(\'HTTP_DONE\', \'httpDone\', function HTTP_DONE(resp) {\n      if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {\n        var body = AWS.util.buffer.concat(resp.httpResponse.buffers);\n        resp.httpResponse.body = body;\n      }\n      delete resp.httpResponse.numBytes;\n      delete resp.httpResponse.buffers;\n    });\n\n    add(\'FINALIZE_ERROR\', \'retry\', function FINALIZE_ERROR(resp) {\n      if (resp.httpResponse.statusCode) {\n        resp.error.statusCode = resp.httpResponse.statusCode;\n        if (resp.error.retryable === undefined) {\n          resp.error.retryable = this.service.retryableError(resp.error, this);\n        }\n      }\n    });\n\n    add(\'INVALIDATE_CREDENTIALS\', \'retry\', function INVALIDATE_CREDENTIALS(resp) {\n      if (!resp.error) return;\n      switch (resp.error.code) {\n        case \'RequestExpired\': // EC2 only\n        case \'ExpiredTokenException\':\n        case \'ExpiredToken\':\n          resp.error.retryable = true;\n          resp.request.service.config.credentials.expired = true;\n      }\n    });\n\n    add(\'EXPIRED_SIGNATURE\', \'retry\', function EXPIRED_SIGNATURE(resp) {\n      var err = resp.error;\n      if (!err) return;\n      if (typeof err.code === \'string\' && typeof err.message === \'string\') {\n        if (err.code.match(/Signature/) && err.message.match(/expired/)) {\n          resp.error.retryable = true;\n        }\n      }\n    });\n\n    add(\'CLOCK_SKEWED\', \'retry\', function CLOCK_SKEWED(resp) {\n      if (!resp.error) return;\n      if (this.service.clockSkewError(resp.error)\n          && this.service.config.correctClockSkew\n          && AWS.config.isClockSkewed) {\n        resp.error.retryable = true;\n      }\n    });\n\n    add(\'REDIRECT\', \'retry\', function REDIRECT(resp) {\n      if (resp.error && resp.error.statusCode >= 300 &&\n          resp.error.statusCode < 400 && resp.httpResponse.headers[\'location\']) {\n        this.httpRequest.endpoint =\n          new AWS.Endpoint(resp.httpResponse.headers[\'location\']);\n        this.httpRequest.headers[\'Host\'] = this.httpRequest.endpoint.host;\n        resp.error.redirect = true;\n        resp.error.retryable = true;\n      }\n    });\n\n    add(\'RETRY_CHECK\', \'retry\', function RETRY_CHECK(resp) {\n      if (resp.error) {\n        if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {\n          resp.error.retryDelay = 0;\n        } else if (resp.retryCount < resp.maxRetries) {\n          resp.error.retryDelay = this.service.retryDelays(resp.retryCount) || 0;\n        }\n      }\n    });\n\n    addAsync(\'RESET_RETRY_STATE\', \'afterRetry\', function RESET_RETRY_STATE(resp, done) {\n      var delay, willRetry = false;\n\n      if (resp.error) {\n        delay = resp.error.retryDelay || 0;\n        if (resp.error.retryable && resp.retryCount < resp.maxRetries) {\n          resp.retryCount++;\n          willRetry = true;\n        } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {\n          resp.redirectCount++;\n          willRetry = true;\n        }\n      }\n\n      if (willRetry) {\n        resp.error = null;\n        setTimeout(done, delay);\n      } else {\n        done();\n      }\n    });\n  }),\n\n  CorePost: new SequentialExecutor().addNamedListeners(function(add) {\n    add(\'EXTRACT_REQUEST_ID\', \'extractData\', AWS.util.extractRequestId);\n    add(\'EXTRACT_REQUEST_ID\', \'extractError\', AWS.util.extractRequestId);\n\n    add(\'ENOTFOUND_ERROR\', \'httpError\', function ENOTFOUND_ERROR(err) {\n      if (err.code === \'NetworkingError\' && err.errno === \'ENOTFOUND\') {\n        var message = \'Inaccessible host: `\' + err.hostname +\n          \'\\\'. This service may not be available in the `\' + err.region +\n          \'\\\' region.\';\n        this.response.error = AWS.util.error(new Error(message), {\n          code: \'UnknownEndpoint\',\n          region: err.region,\n          hostname: err.hostname,\n          retryable: true,\n          originalError: err\n        });\n      }\n    });\n  }),\n\n  Logger: new SequentialExecutor().addNamedListeners(function(add) {\n    add(\'LOG_REQUEST\', \'complete\', function LOG_REQUEST(resp) {\n      var req = resp.request;\n      var logger = req.service.config.logger;\n      if (!logger) return;\n\n      function buildMessage() {\n        var time = AWS.util.date.getDate().getTime();\n        var delta = (time - req.startTime.getTime()) / 1000;\n        var ansi = logger.isTTY ? true : false;\n        var status = resp.httpResponse.statusCode;\n        var params = require(\'util\').inspect(req.params, true, null);\n\n        var message = \'\';\n        if (ansi) message += \'\\x1B[33m\';\n        message += \'[AWS \' + req.service.serviceIdentifier + \' \' + status;\n        message += \' \' + delta.toString() + \'s \' + resp.retryCount + \' retries]\';\n        if (ansi) message += \'\\x1B[0;1m\';\n        message += \' \' + AWS.util.string.lowerFirst(req.operation);\n        message += \'(\' + params + \')\';\n        if (ansi) message += \'\\x1B[0m\';\n        return message;\n      }\n\n      var line = buildMessage();\n      if (typeof logger.log === \'function\') {\n        logger.log(line);\n      } else if (typeof logger.write === \'function\') {\n        logger.write(line + \'\\n\');\n      }\n    });\n  }),\n\n  Json: new SequentialExecutor().addNamedListeners(function(add) {\n    var svc = require(\'./protocol/json\');\n    add(\'BUILD\', \'build\', svc.buildRequest);\n    add(\'EXTRACT_DATA\', \'extractData\', svc.extractData);\n    add(\'EXTRACT_ERROR\', \'extractError\', svc.extractError);\n  }),\n\n  Rest: new SequentialExecutor().addNamedListeners(function(add) {\n    var svc = require(\'./protocol/rest\');\n    add(\'BUILD\', \'build\', svc.buildRequest);\n    add(\'EXTRACT_DATA\', \'extractData\', svc.extractData);\n    add(\'EXTRACT_ERROR\', \'extractError\', svc.extractError);\n  }),\n\n  RestJson: new SequentialExecutor().addNamedListeners(function(add) {\n    var svc = require(\'./protocol/rest_json\');\n    add(\'BUILD\', \'build\', svc.buildRequest);\n    add(\'EXTRACT_DATA\', \'extractData\', svc.extractData);\n    add(\'EXTRACT_ERROR\', \'extractError\', svc.extractError);\n  }),\n\n  RestXml: new SequentialExecutor().addNamedListeners(function(add) {\n    var svc = require(\'./protocol/rest_xml\');\n    add(\'BUILD\', \'build\', svc.buildRequest);\n    add(\'EXTRACT_DATA\', \'extractData\', svc.extractData);\n    add(\'EXTRACT_ERROR\', \'extractError\', svc.extractError);\n  }),\n\n  Query: new SequentialExecutor().addNamedListeners(function(add) {\n    var svc = require(\'./protocol/query\');\n    add(\'BUILD\', \'build\', svc.buildRequest);\n    add(\'EXTRACT_DATA\', \'extractData\', svc.extractData);\n    add(\'EXTRACT_ERROR\', \'extractError\', svc.extractError);\n  })\n};\n\n},{"./core":10,"./protocol/json":29,"./protocol/query":30,"./protocol/rest":31,"./protocol/rest_json":32,"./protocol/rest_xml":33,"./sequential_executor":40,"util":128}],18:[function(require,module,exports){\nvar AWS = require(\'./core\');\nvar inherit = AWS.util.inherit;\n\n\nAWS.Endpoint = inherit({\n\n\n  constructor: function Endpoint(endpoint, config) {\n    AWS.util.hideProperties(this, [\'slashes\', \'auth\', \'hash\', \'search\', \'query\']);\n\n    if (typeof endpoint === \'undefined\' || endpoint === null) {\n      throw new Error(\'Invalid endpoint: \' + endpoint);\n    } else if (typeof endpoint !== \'string\') {\n      return AWS.util.copy(endpoint);\n    }\n\n    if (!endpoint.match(/^http/)) {\n      var useSSL = config && config.sslEnabled !== undefined ?\n        config.sslEnabled : AWS.config.sslEnabled;\n      endpoint = (useSSL ? \'https\' : \'http\') + \'://\' + endpoint;\n    }\n\n    AWS.util.update(this, AWS.util.urlParse(endpoint));\n\n    if (this.port) {\n      this.port = parseInt(this.port, 10);\n    } else {\n      this.port = this.protocol === \'https:\' ? 443 : 80;\n    }\n  }\n\n});\n\n\nAWS.HttpRequest = inherit({\n\n\n  constructor: function HttpRequest(endpoint, region, customUserAgent) {\n    endpoint = new AWS.Endpoint(endpoint);\n    this.method = \'POST\';\n    this.path = endpoint.path || \'/\';\n    this.headers = {};\n    this.body = \'\';\n    this.endpoint = endpoint;\n    this.region = region;\n    this.setUserAgent(customUserAgent);\n  },\n\n\n  setUserAgent: function setUserAgent(customUserAgent) {\n    var prefix = AWS.util.isBrowser() ? \'X-Amz-\' : \'\';\n    var customSuffix = \'\';\n    if (typeof customUserAgent === \'string\' && customUserAgent) {\n      customSuffix += \' \' + customUserAgent;\n    }\n    this.headers[prefix + \'User-Agent\'] = AWS.util.userAgent() + customSuffix;\n  },\n\n\n  pathname: function pathname() {\n    return this.path.split(\'?\', 1)[0];\n  },\n\n\n  search: function search() {\n    var query = this.path.split(\'?\', 2)[1];\n    if (query) {\n      query = AWS.util.queryStringParse(query);\n      return AWS.util.queryParamsToString(query);\n    }\n    return \'\';\n  }\n\n});\n\n\nAWS.HttpResponse = inherit({\n\n\n  constructor: function HttpResponse() {\n    this.statusCode = undefined;\n    this.headers = {};\n    this.body = undefined;\n    this.streaming = false;\n    this.stream = null;\n  },\n\n\n  createUnbufferedStream: function createUnbufferedStream() {\n    this.streaming = true;\n    return this.stream;\n  }\n});\n\n\nAWS.HttpClient = inherit({});\n\n\nAWS.HttpClient.getInstance = function getInstance() {\n  if (this.singleton === undefined) {\n    this.singleton = new this();\n  }\n  return this.singleton;\n};\n\n},{"./core":10}],19:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar EventEmitter = require(\'events\').EventEmitter;\nrequire(\'../http\');\n\n\nAWS.XHRClient = AWS.util.inherit({\n  handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {\n    var self = this;\n    var endpoint = httpRequest.endpoint;\n    var emitter = new EventEmitter();\n    var href = endpoint.protocol + \'//\' + endpoint.hostname;\n    if (endpoint.port !== 80 && endpoint.port !== 443) {\n      href += \':\' + endpoint.port;\n    }\n    href += httpRequest.path;\n\n    var xhr = new XMLHttpRequest(), headersEmitted = false;\n    httpRequest.stream = xhr;\n\n    xhr.addEventListener(\'readystatechange\', function() {\n      try {\n        if (xhr.status === 0) return; // 0 code is invalid\n      } catch (e) { return; }\n\n      if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {\n        try { xhr.responseType = \'arraybuffer\'; } catch (e) {}\n        emitter.statusCode = xhr.status;\n        emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());\n        emitter.emit(\'headers\', emitter.statusCode, emitter.headers);\n        headersEmitted = true;\n      }\n      if (this.readyState === this.DONE) {\n        self.finishRequest(xhr, emitter);\n      }\n    }, false);\n    xhr.upload.addEventListener(\'progress\', function (evt) {\n      emitter.emit(\'sendProgress\', evt);\n    });\n    xhr.addEventListener(\'progress\', function (evt) {\n      emitter.emit(\'receiveProgress\', evt);\n    }, false);\n    xhr.addEventListener(\'timeout\', function () {\n      errCallback(AWS.util.error(new Error(\'Timeout\'), {code: \'TimeoutError\'}));\n    }, false);\n    xhr.addEventListener(\'error\', function () {\n      errCallback(AWS.util.error(new Error(\'Network Failure\'), {\n        code: \'NetworkingError\'\n      }));\n    }, false);\n    /** BEGIN HOT-FIX: DO NOT REMOVE https://issues.amazon.com/issues/JS-358 */\n    xhr.addEventListener(\'abort\', function () {\n      errCallback(AWS.util.error(new Error(\'Connection aborted\'), {\n        code: \'RequestAborted\'\n      }));\n    }, false);\n    /** END */\n\n    callback(emitter);\n    xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);\n    AWS.util.each(httpRequest.headers, function (key, value) {\n      if (key !== \'Content-Length\' && key !== \'User-Agent\' && key !== \'Host\') {\n        xhr.setRequestHeader(key, value);\n      }\n    });\n\n    if (httpOptions.timeout && httpOptions.xhrAsync !== false) {\n      xhr.timeout = httpOptions.timeout;\n    }\n\n    if (httpOptions.xhrWithCredentials) {\n      xhr.withCredentials = true;\n    }\n\n    try {\n      xhr.send(httpRequest.body);\n    } catch (err) {\n      if (httpRequest.body && typeof httpRequest.body.buffer === \'object\') {\n        xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly\n      } else {\n        throw err;\n      }\n    }\n\n    return emitter;\n  },\n\n  parseHeaders: function parseHeaders(rawHeaders) {\n    var headers = {};\n    AWS.util.arrayEach(rawHeaders.split(/\\r?\\n/), function (line) {\n      var key = line.split(\':\', 1)[0];\n      var value = line.substring(key.length + 2);\n      if (key.length > 0) headers[key.toLowerCase()] = value;\n    });\n    return headers;\n  },\n\n  finishRequest: function finishRequest(xhr, emitter) {\n    var buffer;\n    if (xhr.responseType === \'arraybuffer\' && xhr.response) {\n      var ab = xhr.response;\n      buffer = new AWS.util.Buffer(ab.byteLength);\n      var view = new Uint8Array(ab);\n      for (var i = 0; i < buffer.length; ++i) {\n        buffer[i] = view[i];\n      }\n    }\n\n    try {\n      if (!buffer && typeof xhr.responseText === \'string\') {\n        buffer = new AWS.util.Buffer(xhr.responseText);\n      }\n    } catch (e) {}\n\n    if (buffer) emitter.emit(\'data\', buffer);\n    emitter.emit(\'end\');\n  }\n});\n\n\nAWS.HttpClient.prototype = AWS.XHRClient.prototype;\n\n\nAWS.HttpClient.streamsApiVersion = 1;\n\n},{"../core":10,"../http":18,"events":65}],20:[function(require,module,exports){\nvar util = require(\'../util\');\n\nfunction JsonBuilder() { }\n\nJsonBuilder.prototype.build = function(value, shape) {\n  return JSON.stringify(translate(value, shape));\n};\n\nfunction translate(value, shape) {\n  if (!shape || value === undefined || value === null) return undefined;\n\n  switch (shape.type) {\n    case \'structure\': return translateStructure(value, shape);\n    case \'map\': return translateMap(value, shape);\n    case \'list\': return translateList(value, shape);\n    default: return translateScalar(value, shape);\n  }\n}\n\nfunction translateStructure(structure, shape) {\n  var struct = {};\n  util.each(structure, function(name, value) {\n    var memberShape = shape.members[name];\n    if (memberShape) {\n      if (memberShape.location !== \'body\') return;\n      var locationName = memberShape.isLocationName ? memberShape.name : name;\n      var result = translate(value, memberShape);\n      if (result !== undefined) struct[locationName] = result;\n    }\n  });\n  return struct;\n}\n\nfunction translateList(list, shape) {\n  var out = [];\n  util.arrayEach(list, function(value) {\n    var result = translate(value, shape.member);\n    if (result !== undefined) out.push(result);\n  });\n  return out;\n}\n\nfunction translateMap(map, shape) {\n  var out = {};\n  util.each(map, function(key, value) {\n    var result = translate(value, shape.value);\n    if (result !== undefined) out[key] = result;\n  });\n  return out;\n}\n\nfunction translateScalar(value, shape) {\n  return shape.toWireFormat(value);\n}\n\nmodule.exports = JsonBuilder;\n\n},{"../util":52}],21:[function(require,module,exports){\nvar util = require(\'../util\');\n\nfunction JsonParser() { }\n\nJsonParser.prototype.parse = function(value, shape) {\n  return translate(JSON.parse(value), shape);\n};\n\nfunction translate(value, shape) {\n  if (!shape || value === undefined) return undefined;\n\n  switch (shape.type) {\n    case \'structure\': return translateStructure(value, shape);\n    case \'map\': return translateMap(value, shape);\n    case \'list\': return translateList(value, shape);\n    default: return translateScalar(value, shape);\n  }\n}\n\nfunction translateStructure(structure, shape) {\n  if (structure == null) return undefined;\n\n  var struct = {};\n  var shapeMembers = shape.members;\n  util.each(shapeMembers, function(name, memberShape) {\n    var locationName = memberShape.isLocationName ? memberShape.name : name;\n    if (Object.prototype.hasOwnProperty.call(structure, locationName)) {\n      var value = structure[locationName];\n      var result = translate(value, memberShape);\n      if (result !== undefined) struct[name] = result;\n    }\n  });\n  return struct;\n}\n\nfunction translateList(list, shape) {\n  if (list == null) return undefined;\n\n  var out = [];\n  util.arrayEach(list, function(value) {\n    var result = translate(value, shape.member);\n    if (result === undefined) out.push(null);\n    else out.push(result);\n  });\n  return out;\n}\n\nfunction translateMap(map, shape) {\n  if (map == null) return undefined;\n\n  var out = {};\n  util.each(map, function(key, value) {\n    var result = translate(value, shape.value);\n    if (result === undefined) out[key] = null;\n    else out[key] = result;\n  });\n  return out;\n}\n\nfunction translateScalar(value, shape) {\n  return shape.toType(value);\n}\n\nmodule.exports = JsonParser;\n\n},{"../util":52}],22:[function(require,module,exports){\nvar Collection = require(\'./collection\');\nvar Operation = require(\'./operation\');\nvar Shape = require(\'./shape\');\nvar Paginator = require(\'./paginator\');\nvar ResourceWaiter = require(\'./resource_waiter\');\n\nvar util = require(\'../util\');\nvar property = util.property;\nvar memoizedProperty = util.memoizedProperty;\n\nfunction Api(api, options) {\n  api = api || {};\n  options = options || {};\n  options.api = this;\n\n  api.metadata = api.metadata || {};\n\n  property(this, \'isApi\', true, false);\n  property(this, \'apiVersion\', api.metadata.apiVersion);\n  property(this, \'endpointPrefix\', api.metadata.endpointPrefix);\n  property(this, \'signingName\', api.metadata.signingName);\n  property(this, \'globalEndpoint\', api.metadata.globalEndpoint);\n  property(this, \'signatureVersion\', api.metadata.signatureVersion);\n  property(this, \'jsonVersion\', api.metadata.jsonVersion);\n  property(this, \'targetPrefix\', api.metadata.targetPrefix);\n  property(this, \'protocol\', api.metadata.protocol);\n  property(this, \'timestampFormat\', api.metadata.timestampFormat);\n  property(this, \'xmlNamespaceUri\', api.metadata.xmlNamespace);\n  property(this, \'abbreviation\', api.metadata.serviceAbbreviation);\n  property(this, \'fullName\', api.metadata.serviceFullName);\n\n  memoizedProperty(this, \'className\', function() {\n    var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;\n    if (!name) return null;\n\n    name = name.replace(/^Amazon|AWS\\s*|\\(.*|\\s+|\\W+/g, \'\');\n    if (name === \'ElasticLoadBalancing\') name = \'ELB\';\n    return name;\n  });\n\n  property(this, \'operations\', new Collection(api.operations, options, function(name, operation) {\n    return new Operation(name, operation, options);\n  }, util.string.lowerFirst));\n\n  property(this, \'shapes\', new Collection(api.shapes, options, function(name, shape) {\n    return Shape.create(shape, options);\n  }));\n\n  property(this, \'paginators\', new Collection(api.paginators, options, function(name, paginator) {\n    return new Paginator(name, paginator, options);\n  }));\n\n  property(this, \'waiters\', new Collection(api.waiters, options, function(name, waiter) {\n    return new ResourceWaiter(name, waiter, options);\n  }, util.string.lowerFirst));\n\n  if (options.documentation) {\n    property(this, \'documentation\', api.documentation);\n    property(this, \'documentationUrl\', api.documentationUrl);\n  }\n}\n\nmodule.exports = Api;\n\n},{"../util":52,"./collection":23,"./operation":24,"./paginator":25,"./resource_waiter":26,"./shape":27}],23:[function(require,module,exports){\nvar memoizedProperty = require(\'../util\').memoizedProperty;\n\nfunction memoize(name, value, fn, nameTr) {\n  memoizedProperty(this, nameTr(name), function() {\n    return fn(name, value);\n  });\n}\n\nfunction Collection(iterable, options, fn, nameTr) {\n  nameTr = nameTr || String;\n  var self = this;\n\n  for (var id in iterable) {\n    if (Object.prototype.hasOwnProperty.call(iterable, id)) {\n      memoize.call(self, id, iterable[id], fn, nameTr);\n    }\n  }\n}\n\nmodule.exports = Collection;\n\n},{"../util":52}],24:[function(require,module,exports){\nvar Shape = require(\'./shape\');\n\nvar util = require(\'../util\');\nvar property = util.property;\nvar memoizedProperty = util.memoizedProperty;\n\nfunction Operation(name, operation, options) {\n  options = options || {};\n\n  property(this, \'name\', operation.name || name);\n  property(this, \'api\', options.api, false);\n\n  operation.http = operation.http || {};\n  property(this, \'httpMethod\', operation.http.method || \'POST\');\n  property(this, \'httpPath\', operation.http.requestUri || \'/\');\n  property(this, \'authtype\', operation.authtype || \'\');\n\n  memoizedProperty(this, \'input\', function() {\n    if (!operation.input) {\n      return new Shape.create({type: \'structure\'}, options);\n    }\n    return Shape.create(operation.input, options);\n  });\n\n  memoizedProperty(this, \'output\', function() {\n    if (!operation.output) {\n      return new Shape.create({type: \'structure\'}, options);\n    }\n    return Shape.create(operation.output, options);\n  });\n\n  memoizedProperty(this, \'errors\', function() {\n    var list = [];\n    if (!operation.errors) return null;\n\n    for (var i = 0; i < operation.errors.length; i++) {\n      list.push(Shape.create(operation.errors[i], options));\n    }\n\n    return list;\n  });\n\n  memoizedProperty(this, \'paginator\', function() {\n    return options.api.paginators[name];\n  });\n\n  if (options.documentation) {\n    property(this, \'documentation\', operation.documentation);\n    property(this, \'documentationUrl\', operation.documentationUrl);\n  }\n}\n\nmodule.exports = Operation;\n\n},{"../util":52,"./shape":27}],25:[function(require,module,exports){\nvar property = require(\'../util\').property;\n\nfunction Paginator(name, paginator) {\n  property(this, \'inputToken\', paginator.input_token);\n  property(this, \'limitKey\', paginator.limit_key);\n  property(this, \'moreResults\', paginator.more_results);\n  property(this, \'outputToken\', paginator.output_token);\n  property(this, \'resultKey\', paginator.result_key);\n}\n\nmodule.exports = Paginator;\n\n},{"../util":52}],26:[function(require,module,exports){\nvar util = require(\'../util\');\nvar property = util.property;\n\nfunction ResourceWaiter(name, waiter, options) {\n  options = options || {};\n  property(this, \'name\', name);\n  property(this, \'api\', options.api, false);\n\n  if (waiter.operation) {\n    property(this, \'operation\', util.string.lowerFirst(waiter.operation));\n  }\n\n  var self = this;\n  var keys = [\n    \'type\',\n    \'description\',\n    \'delay\',\n    \'maxAttempts\',\n    \'acceptors\'\n  ];\n\n  keys.forEach(function(key) {\n    var value = waiter[key];\n    if (value) {\n      property(self, key, value);\n    }\n  });\n}\n\nmodule.exports = ResourceWaiter;\n\n},{"../util":52}],27:[function(require,module,exports){\nvar Collection = require(\'./collection\');\n\nvar util = require(\'../util\');\n\nfunction property(obj, name, value) {\n  if (value !== null && value !== undefined) {\n    util.property.apply(this, arguments);\n  }\n}\n\nfunction memoizedProperty(obj, name) {\n  if (!obj.constructor.prototype[name]) {\n    util.memoizedProperty.apply(this, arguments);\n  }\n}\n\nfunction Shape(shape, options, memberName) {\n  options = options || {};\n\n  property(this, \'shape\', shape.shape);\n  property(this, \'api\', options.api, false);\n  property(this, \'type\', shape.type);\n  property(this, \'enum\', shape.enum);\n  property(this, \'min\', shape.min);\n  property(this, \'max\', shape.max);\n  property(this, \'pattern\', shape.pattern);\n  property(this, \'location\', shape.location || this.location || \'body\');\n  property(this, \'name\', this.name || shape.xmlName || shape.queryName ||\n    shape.locationName || memberName);\n  property(this, \'isStreaming\', shape.streaming || this.isStreaming || false);\n  property(this, \'isComposite\', shape.isComposite || false);\n  property(this, \'isShape\', true, false);\n  property(this, \'isQueryName\', shape.queryName ? true : false, false);\n  property(this, \'isLocationName\', shape.locationName ? true : false, false);\n\n  if (options.documentation) {\n    property(this, \'documentation\', shape.documentation);\n    property(this, \'documentationUrl\', shape.documentationUrl);\n  }\n\n  if (shape.xmlAttribute) {\n    property(this, \'isXmlAttribute\', shape.xmlAttribute || false);\n  }\n\n  property(this, \'defaultValue\', null);\n  this.toWireFormat = function(value) {\n    if (value === null || value === undefined) return \'\';\n    return value;\n  };\n  this.toType = function(value) { return value; };\n}\n\n\nShape.normalizedTypes = {\n  character: \'string\',\n  double: \'float\',\n  long: \'integer\',\n  short: \'integer\',\n  biginteger: \'integer\',\n  bigdecimal: \'float\',\n  blob: \'binary\'\n};\n\n\nShape.types = {\n  \'structure\': StructureShape,\n  \'list\': ListShape,\n  \'map\': MapShape,\n  \'boolean\': BooleanShape,\n  \'timestamp\': TimestampShape,\n  \'float\': FloatShape,\n  \'integer\': IntegerShape,\n  \'string\': StringShape,\n  \'base64\': Base64Shape,\n  \'binary\': BinaryShape\n};\n\nShape.resolve = function resolve(shape, options) {\n  if (shape.shape) {\n    var refShape = options.api.shapes[shape.shape];\n    if (!refShape) {\n      throw new Error(\'Cannot find shape reference: \' + shape.shape);\n    }\n\n    return refShape;\n  } else {\n    return null;\n  }\n};\n\nShape.create = function create(shape, options, memberName) {\n  if (shape.isShape) return shape;\n\n  var refShape = Shape.resolve(shape, options);\n  if (refShape) {\n    var filteredKeys = Object.keys(shape);\n    if (!options.documentation) {\n      filteredKeys = filteredKeys.filter(function(name) {\n        return !name.match(/documentation/);\n      });\n    }\n    if (filteredKeys === [\'shape\']) { // no inline customizations\n      return refShape;\n    }\n\n    var InlineShape = function() {\n      refShape.constructor.call(this, shape, options, memberName);\n    };\n    InlineShape.prototype = refShape;\n    return new InlineShape();\n  } else {\n    if (!shape.type) {\n      if (shape.members) shape.type = \'structure\';\n      else if (shape.member) shape.type = \'list\';\n      else if (shape.key) shape.type = \'map\';\n      else shape.type = \'string\';\n    }\n\n    var origType = shape.type;\n    if (Shape.normalizedTypes[shape.type]) {\n      shape.type = Shape.normalizedTypes[shape.type];\n    }\n\n    if (Shape.types[shape.type]) {\n      return new Shape.types[shape.type](shape, options, memberName);\n    } else {\n      throw new Error(\'Unrecognized shape type: \' + origType);\n    }\n  }\n};\n\nfunction CompositeShape(shape) {\n  Shape.apply(this, arguments);\n  property(this, \'isComposite\', true);\n\n  if (shape.flattened) {\n    property(this, \'flattened\', shape.flattened || false);\n  }\n}\n\nfunction StructureShape(shape, options) {\n  var requiredMap = null, firstInit = !this.isShape;\n\n  CompositeShape.apply(this, arguments);\n\n  if (firstInit) {\n    property(this, \'defaultValue\', function() { return {}; });\n    property(this, \'members\', {});\n    property(this, \'memberNames\', []);\n    property(this, \'required\', []);\n    property(this, \'isRequired\', function() { return false; });\n  }\n\n  if (shape.members) {\n    property(this, \'members\', new Collection(shape.members, options, function(name, member) {\n      return Shape.create(member, options, name);\n    }));\n    memoizedProperty(this, \'memberNames\', function() {\n      return shape.xmlOrder || Object.keys(shape.members);\n    });\n  }\n\n  if (shape.required) {\n    property(this, \'required\', shape.required);\n    property(this, \'isRequired\', function(name) {\n      if (!requiredMap) {\n        requiredMap = {};\n        for (var i = 0; i < shape.required.length; i++) {\n          requiredMap[shape.required[i]] = true;\n        }\n      }\n\n      return requiredMap[name];\n    }, false, true);\n  }\n\n  property(this, \'resultWrapper\', shape.resultWrapper || null);\n\n  if (shape.payload) {\n    property(this, \'payload\', shape.payload);\n  }\n\n  if (typeof shape.xmlNamespace === \'string\') {\n    property(this, \'xmlNamespaceUri\', shape.xmlNamespace);\n  } else if (typeof shape.xmlNamespace === \'object\') {\n    property(this, \'xmlNamespacePrefix\', shape.xmlNamespace.prefix);\n    property(this, \'xmlNamespaceUri\', shape.xmlNamespace.uri);\n  }\n}\n\nfunction ListShape(shape, options) {\n  var self = this, firstInit = !this.isShape;\n  CompositeShape.apply(this, arguments);\n\n  if (firstInit) {\n    property(this, \'defaultValue\', function() { return []; });\n  }\n\n  if (shape.member) {\n    memoizedProperty(this, \'member\', function() {\n      return Shape.create(shape.member, options);\n    });\n  }\n\n  if (this.flattened) {\n    var oldName = this.name;\n    memoizedProperty(this, \'name\', function() {\n      return self.member.name || oldName;\n    });\n  }\n}\n\nfunction MapShape(shape, options) {\n  var firstInit = !this.isShape;\n  CompositeShape.apply(this, arguments);\n\n  if (firstInit) {\n    property(this, \'defaultValue\', function() { return {}; });\n    property(this, \'key\', Shape.create({type: \'string\'}, options));\n    property(this, \'value\', Shape.create({type: \'string\'}, options));\n  }\n\n  if (shape.key) {\n    memoizedProperty(this, \'key\', function() {\n      return Shape.create(shape.key, options);\n    });\n  }\n  if (shape.value) {\n    memoizedProperty(this, \'value\', function() {\n      return Shape.create(shape.value, options);\n    });\n  }\n}\n\nfunction TimestampShape(shape) {\n  var self = this;\n  Shape.apply(this, arguments);\n\n  if (this.location === \'header\') {\n    property(this, \'timestampFormat\', \'rfc822\');\n  } else if (shape.timestampFormat) {\n    property(this, \'timestampFormat\', shape.timestampFormat);\n  } else if (this.api) {\n    if (this.api.timestampFormat) {\n      property(this, \'timestampFormat\', this.api.timestampFormat);\n    } else {\n      switch (this.api.protocol) {\n        case \'json\':\n        case \'rest-json\':\n          property(this, \'timestampFormat\', \'unixTimestamp\');\n          break;\n        case \'rest-xml\':\n        case \'query\':\n        case \'ec2\':\n          property(this, \'timestampFormat\', \'iso8601\');\n          break;\n      }\n    }\n  }\n\n  this.toType = function(value) {\n    if (value === null || value === undefined) return null;\n    if (typeof value.toUTCString === \'function\') return value;\n    return typeof value === \'string\' || typeof value === \'number\' ?\n           util.date.parseTimestamp(value) : null;\n  };\n\n  this.toWireFormat = function(value) {\n    return util.date.format(value, self.timestampFormat);\n  };\n}\n\nfunction StringShape() {\n  Shape.apply(this, arguments);\n\n  if (this.api) {\n    switch (this.api.protocol) {\n      case \'rest-xml\':\n      case \'query\':\n      case \'ec2\':\n        this.toType = function(value) { return value || \'\'; };\n    }\n  }\n}\n\nfunction FloatShape() {\n  Shape.apply(this, arguments);\n\n  this.toType = function(value) {\n    if (value === null || value === undefined) return null;\n    return parseFloat(value);\n  };\n  this.toWireFormat = this.toType;\n}\n\nfunction IntegerShape() {\n  Shape.apply(this, arguments);\n\n  this.toType = function(value) {\n    if (value === null || value === undefined) return null;\n    return parseInt(value, 10);\n  };\n  this.toWireFormat = this.toType;\n}\n\nfunction BinaryShape() {\n  Shape.apply(this, arguments);\n  this.toType = util.base64.decode;\n  this.toWireFormat = util.base64.encode;\n}\n\nfunction Base64Shape() {\n  BinaryShape.apply(this, arguments);\n}\n\nfunction BooleanShape() {\n  Shape.apply(this, arguments);\n\n  this.toType = function(value) {\n    if (typeof value === \'boolean\') return value;\n    if (value === null || value === undefined) return null;\n    return value === \'true\';\n  };\n}\n\n\nShape.shapes = {\n  StructureShape: StructureShape,\n  ListShape: ListShape,\n  MapShape: MapShape,\n  StringShape: StringShape,\n  BooleanShape: BooleanShape,\n  Base64Shape: Base64Shape\n};\n\nmodule.exports = Shape;\n\n},{"../util":52,"./collection":23}],28:[function(require,module,exports){\nvar AWS = require(\'./core\');\n\n\nAWS.ParamValidator = AWS.util.inherit({\n\n  constructor: function ParamValidator(validation) {\n    if (validation === true || validation === undefined) {\n      validation = {\'min\': true};\n    }\n    this.validation = validation;\n  },\n\n  validate: function validate(shape, params, context) {\n    this.errors = [];\n    this.validateMember(shape, params || {}, context || \'params\');\n\n    if (this.errors.length > 1) {\n      var msg = this.errors.join(\'\\n* \');\n      msg = \'There were \' + this.errors.length +\n        \' validation errors:\\n* \' + msg;\n      throw AWS.util.error(new Error(msg),\n        {code: \'MultipleValidationErrors\', errors: this.errors});\n    } else if (this.errors.length === 1) {\n      throw this.errors[0];\n    } else {\n      return true;\n    }\n  },\n\n  fail: function fail(code, message) {\n    this.errors.push(AWS.util.error(new Error(message), {code: code}));\n  },\n\n  validateStructure: function validateStructure(shape, params, context) {\n    this.validateType(params, context, [\'object\'], \'structure\');\n\n    var paramName;\n    for (var i = 0; shape.required && i < shape.required.length; i++) {\n      paramName = shape.required[i];\n      var value = params[paramName];\n      if (value === undefined || value === null) {\n        this.fail(\'MissingRequiredParameter\',\n          \'Missing required key \\\'\' + paramName + \'\\\' in \' + context);\n      }\n    }\n\n    for (paramName in params) {\n      if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;\n\n      var paramValue = params[paramName],\n          memberShape = shape.members[paramName];\n\n      if (memberShape !== undefined) {\n        var memberContext = [context, paramName].join(\'.\');\n        this.validateMember(memberShape, paramValue, memberContext);\n      } else {\n        this.fail(\'UnexpectedParameter\',\n          \'Unexpected key \\\'\' + paramName + \'\\\' found in \' + context);\n      }\n    }\n\n    return true;\n  },\n\n  validateMember: function validateMember(shape, param, context) {\n    switch (shape.type) {\n      case \'structure\':\n        return this.validateStructure(shape, param, context);\n      case \'list\':\n        return this.validateList(shape, param, context);\n      case \'map\':\n        return this.validateMap(shape, param, context);\n      default:\n        return this.validateScalar(shape, param, context);\n    }\n  },\n\n  validateList: function validateList(shape, params, context) {\n    if (this.validateType(params, context, [Array])) {\n      this.validateRange(shape, params.length, context, \'list member count\');\n      for (var i = 0; i < params.length; i++) {\n        this.validateMember(shape.member, params[i], context + \'[\' + i + \']\');\n      }\n    }\n  },\n\n  validateMap: function validateMap(shape, params, context) {\n    if (this.validateType(params, context, [\'object\'], \'map\')) {\n      var mapCount = 0;\n      for (var param in params) {\n        if (!Object.prototype.hasOwnProperty.call(params, param)) continue;\n        this.validateMember(shape.key, param,\n                            context + \'[key=\\\'\' + param + \'\\\']\')\n        this.validateMember(shape.value, params[param],\n                            context + \'[\\\'\' + param + \'\\\']\');\n        mapCount++;\n      }\n      this.validateRange(shape, mapCount, context, \'map member count\');\n    }\n  },\n\n  validateScalar: function validateScalar(shape, value, context) {\n    switch (shape.type) {\n      case null:\n      case undefined:\n      case \'string\':\n        return this.validateString(shape, value, context);\n      case \'base64\':\n      case \'binary\':\n        return this.validatePayload(value, context);\n      case \'integer\':\n      case \'float\':\n        return this.validateNumber(shape, value, context);\n      case \'boolean\':\n        return this.validateType(value, context, [\'boolean\']);\n      case \'timestamp\':\n        return this.validateType(value, context, [Date,\n          /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$/, \'number\'],\n          \'Date object, ISO-8601 string, or a UNIX timestamp\');\n      default:\n        return this.fail(\'UnkownType\', \'Unhandled type \' +\n                         shape.type + \' for \' + context);\n    }\n  },\n\n  validateString: function validateString(shape, value, context) {\n    if (this.validateType(value, context, [\'string\'])) {\n      this.validateEnum(shape, value, context);\n      this.validateRange(shape, value.length, context, \'string length\');\n      this.validatePattern(shape, value, context);\n    }\n  },\n\n  validatePattern: function validatePattern(shape, value, context) {\n    if (this.validation[\'pattern\'] && shape[\'pattern\'] !== undefined) {\n      if (!(new RegExp(shape[\'pattern\'])).test(value)) {\n        this.fail(\'PatternMatchError\', \'Provided value "\' + value + \'" \'\n          + \'does not match regex pattern /\' + shape[\'pattern\'] + \'/ for \'\n          + context);\n      }\n    }\n  },\n\n  validateRange: function validateRange(shape, value, context, descriptor) {\n    if (this.validation[\'min\']) {\n      if (shape[\'min\'] !== undefined && value < shape[\'min\']) {\n        this.fail(\'MinRangeError\', \'Expected \' + descriptor + \' >= \'\n          + shape[\'min\'] + \', but found \' + value + \' for \' + context);\n      }\n    }\n    if (this.validation[\'max\']) {\n      if (shape[\'max\'] !== undefined && value > shape[\'max\']) {\n        this.fail(\'MaxRangeError\', \'Expected \' + descriptor + \' <= \'\n          + shape[\'max\'] + \', but found \' + value + \' for \' + context);\n      }\n    }\n  },\n\n  validateEnum: function validateRange(shape, value, context) {\n    if (this.validation[\'enum\'] && shape[\'enum\'] !== undefined) {\n      if (shape[\'enum\'].indexOf(value) === -1) {\n        this.fail(\'EnumError\', \'Found string value of \' + value + \', but \'\n          + \'expected \' + shape[\'enum\'].join(\'|\') + \' for \' + context);\n      }\n    }\n  },\n\n  validateType: function validateType(value, context, acceptedTypes, type) {\n    if (value === null || value === undefined) return false;\n\n    var foundInvalidType = false;\n    for (var i = 0; i < acceptedTypes.length; i++) {\n      if (typeof acceptedTypes[i] === \'string\') {\n        if (typeof value === acceptedTypes[i]) return true;\n      } else if (acceptedTypes[i] instanceof RegExp) {\n        if ((value || \'\').toString().match(acceptedTypes[i])) return true;\n      } else {\n        if (value instanceof acceptedTypes[i]) return true;\n        if (AWS.util.isType(value, acceptedTypes[i])) return true;\n        if (!type && !foundInvalidType) acceptedTypes = acceptedTypes.slice();\n        acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);\n      }\n      foundInvalidType = true;\n    }\n\n    var acceptedType = type;\n    if (!acceptedType) {\n      acceptedType = acceptedTypes.join(\', \').replace(/,([^,]+)$/, \', or$1\');\n    }\n\n    var vowel = acceptedType.match(/^[aeiou]/i) ? \'n\' : \'\';\n    this.fail(\'InvalidParameterType\', \'Expected \' + context + \' to be a\' +\n              vowel + \' \' + acceptedType);\n    return false;\n  },\n\n  validateNumber: function validateNumber(shape, value, context) {\n    if (value === null || value === undefined) return;\n    if (typeof value === \'string\') {\n      var castedValue = parseFloat(value);\n      if (castedValue.toString() === value) value = castedValue;\n    }\n    if (this.validateType(value, context, [\'number\'])) {\n      this.validateRange(shape, value, context, \'numeric value\');\n    }\n  },\n\n  validatePayload: function validatePayload(value, context) {\n    if (value === null || value === undefined) return;\n    if (typeof value === \'string\') return;\n    if (value && typeof value.byteLength === \'number\') return; // typed arrays\n    if (AWS.util.isNode()) { // special check for buffer/stream in Node.js\n      var Stream = AWS.util.stream.Stream;\n      if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;\n    }\n\n    var types = [\'Buffer\', \'Stream\', \'File\', \'Blob\', \'ArrayBuffer\', \'DataView\'];\n    if (value) {\n      for (var i = 0; i < types.length; i++) {\n        if (AWS.util.isType(value, types[i])) return;\n        if (AWS.util.typeName(value.constructor) === types[i]) return;\n      }\n    }\n\n    this.fail(\'InvalidParameterType\', \'Expected \' + context + \' to be a \' +\n      \'string, Buffer, Stream, Blob, or typed array object\');\n  }\n});\n\n},{"./core":10}],29:[function(require,module,exports){\nvar util = require(\'../util\');\nvar JsonBuilder = require(\'../json/builder\');\nvar JsonParser = require(\'../json/parser\');\n\nfunction buildRequest(req) {\n  var httpRequest = req.httpRequest;\n  var api = req.service.api;\n  var target = api.targetPrefix + \'.\' + api.operations[req.operation].name;\n  var version = api.jsonVersion || \'1.0\';\n  var input = api.operations[req.operation].input;\n  var builder = new JsonBuilder();\n\n  if (version === 1) version = \'1.0\';\n  httpRequest.body = builder.build(req.params || {}, input);\n  httpRequest.headers[\'Content-Type\'] = \'application/x-amz-json-\' + version;\n  httpRequest.headers[\'X-Amz-Target\'] = target;\n}\n\nfunction extractError(resp) {\n  var error = {};\n  var httpResponse = resp.httpResponse;\n\n  error.code = httpResponse.headers[\'x-amzn-errortype\'] || \'UnknownError\';\n  if (typeof error.code === \'string\') {\n    error.code = error.code.split(\':\')[0];\n  }\n\n  if (httpResponse.body.length > 0) {\n    var e = JSON.parse(httpResponse.body.toString());\n    if (e.__type || e.code) {\n      error.code = (e.__type || e.code).split(\'#\').pop();\n    }\n    if (error.code === \'RequestEntityTooLarge\') {\n      error.message = \'Request body must be less than 1 MB\';\n    } else {\n      error.message = (e.message || e.Message || null);\n    }\n  } else {\n    error.statusCode = httpResponse.statusCode;\n    error.message = httpResponse.statusCode.toString();\n  }\n\n  resp.error = util.error(new Error(), error);\n}\n\nfunction extractData(resp) {\n  var body = resp.httpResponse.body.toString() || \'{}\';\n  if (resp.request.service.config.convertResponseTypes === false) {\n    resp.data = JSON.parse(body);\n  } else {\n    var operation = resp.request.service.api.operations[resp.request.operation];\n    var shape = operation.output || {};\n    var parser = new JsonParser();\n    resp.data = parser.parse(body, shape);\n  }\n}\n\nmodule.exports = {\n  buildRequest: buildRequest,\n  extractError: extractError,\n  extractData: extractData\n};\n\n},{"../json/builder":20,"../json/parser":21,"../util":52}],30:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar util = require(\'../util\');\nvar QueryParamSerializer = require(\'../query/query_param_serializer\');\nvar Shape = require(\'../model/shape\');\n\nfunction buildRequest(req) {\n  var operation = req.service.api.operations[req.operation];\n  var httpRequest = req.httpRequest;\n  httpRequest.headers[\'Content-Type\'] =\n    \'application/x-www-form-urlencoded; charset=utf-8\';\n  httpRequest.params = {\n    Version: req.service.api.apiVersion,\n    Action: operation.name\n  };\n\n  var builder = new QueryParamSerializer();\n  builder.serialize(req.params, operation.input, function(name, value) {\n    httpRequest.params[name] = value;\n  });\n  httpRequest.body = util.queryParamsToString(httpRequest.params);\n}\n\nfunction extractError(resp) {\n  var data, body = resp.httpResponse.body.toString();\n  if (body.match(\'<UnknownOperationException\')) {\n    data = {\n      Code: \'UnknownOperation\',\n      Message: \'Unknown operation \' + resp.request.operation\n    };\n  } else {\n    data = new AWS.XML.Parser().parse(body);\n  }\n\n  if (data.requestId && !resp.requestId) resp.requestId = data.requestId;\n  if (data.Errors) data = data.Errors;\n  if (data.Error) data = data.Error;\n  if (data.Code) {\n    resp.error = util.error(new Error(), {\n      code: data.Code,\n      message: data.Message\n    });\n  } else {\n    resp.error = util.error(new Error(), {\n      code: resp.httpResponse.statusCode,\n      message: null\n    });\n  }\n}\n\nfunction extractData(resp) {\n  var req = resp.request;\n  var operation = req.service.api.operations[req.operation];\n  var shape = operation.output || {};\n  var origRules = shape;\n\n  if (origRules.resultWrapper) {\n    var tmp = Shape.create({type: \'structure\'});\n    tmp.members[origRules.resultWrapper] = shape;\n    tmp.memberNames = [origRules.resultWrapper];\n    util.property(shape, \'name\', shape.resultWrapper);\n    shape = tmp;\n  }\n\n  var parser = new AWS.XML.Parser();\n\n  if (shape && shape.members && !shape.members._XAMZRequestId) {\n    var requestIdShape = Shape.create(\n      { type: \'string\' },\n      { api: { protocol: \'query\' } },\n      \'requestId\'\n    );\n    shape.members._XAMZRequestId = requestIdShape;\n  }\n\n  var data = parser.parse(resp.httpResponse.body.toString(), shape);\n  resp.requestId = data._XAMZRequestId || data.requestId;\n\n  if (data._XAMZRequestId) delete data._XAMZRequestId;\n\n  if (origRules.resultWrapper) {\n    if (data[origRules.resultWrapper]) {\n      util.update(data, data[origRules.resultWrapper]);\n      delete data[origRules.resultWrapper];\n    }\n  }\n\n  resp.data = data;\n}\n\nmodule.exports = {\n  buildRequest: buildRequest,\n  extractError: extractError,\n  extractData: extractData\n};\n\n},{"../core":10,"../model/shape":27,"../query/query_param_serializer":34,"../util":52}],31:[function(require,module,exports){\nvar util = require(\'../util\');\n\nfunction populateMethod(req) {\n  req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;\n}\n\nfunction populateURI(req) {\n  var operation = req.service.api.operations[req.operation];\n  var input = operation.input;\n  var uri = [req.httpRequest.endpoint.path, operation.httpPath].join(\'/\');\n  uri = uri.replace(/\\/+/g, \'/\');\n\n  var queryString = {}, queryStringSet = false;\n  util.each(input.members, function (name, member) {\n    var paramValue = req.params[name];\n    if (paramValue === null || paramValue === undefined) return;\n    if (member.location === \'uri\') {\n      var regex = new RegExp(\'\\\\{\' + member.name + \'(\\\\+)?\\\\}\');\n      uri = uri.replace(regex, function(_, plus) {\n        var fn = plus ? util.uriEscapePath : util.uriEscape;\n        return fn(String(paramValue));\n      });\n    } else if (member.location === \'querystring\') {\n      queryStringSet = true;\n\n      if (member.type === \'list\') {\n        queryString[member.name] = paramValue.map(function(val) {\n          return util.uriEscape(String(val));\n        });\n      } else if (member.type === \'map\') {\n        util.each(paramValue, function(key, value) {\n          if (Array.isArray(value)) {\n            queryString[key] = value.map(function(val) {\n              return util.uriEscape(String(val));\n            });\n          } else {\n            queryString[key] = util.uriEscape(String(value));\n          }\n        });\n      } else {\n        queryString[member.name] = util.uriEscape(String(paramValue));\n      }\n    }\n  });\n\n  if (queryStringSet) {\n    uri += (uri.indexOf(\'?\') >= 0 ? \'&\' : \'?\');\n    var parts = [];\n    util.arrayEach(Object.keys(queryString).sort(), function(key) {\n      if (!Array.isArray(queryString[key])) {\n        queryString[key] = [queryString[key]];\n      }\n      for (var i = 0; i < queryString[key].length; i++) {\n        parts.push(util.uriEscape(String(key)) + \'=\' + queryString[key][i]);\n      }\n    });\n    uri += parts.join(\'&\');\n  }\n\n  req.httpRequest.path = uri;\n}\n\nfunction populateHeaders(req) {\n  var operation = req.service.api.operations[req.operation];\n  util.each(operation.input.members, function (name, member) {\n    var value = req.params[name];\n    if (value === null || value === undefined) return;\n\n    if (member.location === \'headers\' && member.type === \'map\') {\n      util.each(value, function(key, memberValue) {\n        req.httpRequest.headers[member.name + key] = memberValue;\n      });\n    } else if (member.location === \'header\') {\n      value = member.toWireFormat(value).toString();\n      req.httpRequest.headers[member.name] = value;\n    }\n  });\n}\n\nfunction buildRequest(req) {\n  populateMethod(req);\n  populateURI(req);\n  populateHeaders(req);\n}\n\nfunction extractError() {\n}\n\nfunction extractData(resp) {\n  var req = resp.request;\n  var data = {};\n  var r = resp.httpResponse;\n  var operation = req.service.api.operations[req.operation];\n  var output = operation.output;\n\n  var headers = {};\n  util.each(r.headers, function (k, v) {\n    headers[k.toLowerCase()] = v;\n  });\n\n  util.each(output.members, function(name, member) {\n    var header = (member.name || name).toLowerCase();\n    if (member.location === \'headers\' && member.type === \'map\') {\n      data[name] = {};\n      var location = member.isLocationName ? member.name : \'\';\n      var pattern = new RegExp(\'^\' + location + \'(.+)\', \'i\');\n      util.each(r.headers, function (k, v) {\n        var result = k.match(pattern);\n        if (result !== null) {\n          data[name][result[1]] = v;\n        }\n      });\n    } else if (member.location === \'header\') {\n      if (headers[header] !== undefined) {\n        data[name] = headers[header];\n      }\n    } else if (member.location === \'statusCode\') {\n      data[name] = parseInt(r.statusCode, 10);\n    }\n  });\n\n  resp.data = data;\n}\n\nmodule.exports = {\n  buildRequest: buildRequest,\n  extractError: extractError,\n  extractData: extractData\n};\n\n},{"../util":52}],32:[function(require,module,exports){\nvar util = require(\'../util\');\nvar Rest = require(\'./rest\');\nvar Json = require(\'./json\');\nvar JsonBuilder = require(\'../json/builder\');\nvar JsonParser = require(\'../json/parser\');\n\nfunction populateBody(req) {\n  var builder = new JsonBuilder();\n  var input = req.service.api.operations[req.operation].input;\n\n  if (input.payload) {\n    var params = {};\n    var payloadShape = input.members[input.payload];\n    params = req.params[input.payload];\n    if (params === undefined) return;\n\n    if (payloadShape.type === \'structure\') {\n      req.httpRequest.body = builder.build(params, payloadShape);\n    } else { // non-JSON payload\n      req.httpRequest.body = params;\n    }\n  } else {\n    req.httpRequest.body = builder.build(req.params, input);\n  }\n}\n\nfunction buildRequest(req) {\n  Rest.buildRequest(req);\n\n  if ([\'GET\', \'HEAD\', \'DELETE\'].indexOf(req.httpRequest.method) < 0) {\n    populateBody(req);\n  }\n}\n\nfunction extractError(resp) {\n  Json.extractError(resp);\n}\n\nfunction extractData(resp) {\n  Rest.extractData(resp);\n\n  var req = resp.request;\n  var rules = req.service.api.operations[req.operation].output || {};\n  if (rules.payload) {\n    var payloadMember = rules.members[rules.payload];\n    var body = resp.httpResponse.body;\n    if (payloadMember.isStreaming) {\n      resp.data[rules.payload] = body;\n    } else if (payloadMember.type === \'structure\' || payloadMember.type === \'list\') {\n      var parser = new JsonParser();\n      resp.data[rules.payload] = parser.parse(body, payloadMember);\n    } else {\n      resp.data[rules.payload] = body.toString();\n    }\n  } else {\n    var data = resp.data;\n    Json.extractData(resp);\n    resp.data = util.merge(data, resp.data);\n  }\n}\n\nmodule.exports = {\n  buildRequest: buildRequest,\n  extractError: extractError,\n  extractData: extractData\n};\n\n},{"../json/builder":20,"../json/parser":21,"../util":52,"./json":29,"./rest":31}],33:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar util = require(\'../util\');\nvar Rest = require(\'./rest\');\n\nfunction populateBody(req) {\n  var input = req.service.api.operations[req.operation].input;\n  var builder = new AWS.XML.Builder();\n  var params = req.params;\n\n  var payload = input.payload;\n  if (payload) {\n    var payloadMember = input.members[payload];\n    params = params[payload];\n    if (params === undefined) return;\n\n    if (payloadMember.type === \'structure\') {\n      var rootElement = payloadMember.name;\n      req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);\n    } else { // non-xml payload\n      req.httpRequest.body = params;\n    }\n  } else {\n    req.httpRequest.body = builder.toXML(params, input, input.name ||\n      input.shape || util.string.upperFirst(req.operation) + \'Request\');\n  }\n}\n\nfunction buildRequest(req) {\n  Rest.buildRequest(req);\n\n  if ([\'GET\', \'HEAD\'].indexOf(req.httpRequest.method) < 0) {\n    populateBody(req);\n  }\n}\n\nfunction extractError(resp) {\n  Rest.extractError(resp);\n\n  var data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());\n  if (data.Errors) data = data.Errors;\n  if (data.Error) data = data.Error;\n  if (data.Code) {\n    resp.error = util.error(new Error(), {\n      code: data.Code,\n      message: data.Message\n    });\n  } else {\n    resp.error = util.error(new Error(), {\n      code: resp.httpResponse.statusCode,\n      message: null\n    });\n  }\n}\n\nfunction extractData(resp) {\n  Rest.extractData(resp);\n\n  var parser;\n  var req = resp.request;\n  var body = resp.httpResponse.body;\n  var operation = req.service.api.operations[req.operation];\n  var output = operation.output;\n\n  var payload = output.payload;\n  if (payload) {\n    var payloadMember = output.members[payload];\n    if (payloadMember.isStreaming) {\n      resp.data[payload] = body;\n    } else if (payloadMember.type === \'structure\') {\n      parser = new AWS.XML.Parser();\n      resp.data[payload] = parser.parse(body.toString(), payloadMember);\n    } else {\n      resp.data[payload] = body.toString();\n    }\n  } else if (body.length > 0) {\n    parser = new AWS.XML.Parser();\n    var data = parser.parse(body.toString(), output);\n    util.update(resp.data, data);\n  }\n}\n\nmodule.exports = {\n  buildRequest: buildRequest,\n  extractError: extractError,\n  extractData: extractData\n};\n\n},{"../core":10,"../util":52,"./rest":31}],34:[function(require,module,exports){\nvar util = require(\'../util\');\n\nfunction QueryParamSerializer() {\n}\n\nQueryParamSerializer.prototype.serialize = function(params, shape, fn) {\n  serializeStructure(\'\', params, shape, fn);\n};\n\nfunction ucfirst(shape) {\n  if (shape.isQueryName || shape.api.protocol !== \'ec2\') {\n    return shape.name;\n  } else {\n    return shape.name[0].toUpperCase() + shape.name.substr(1);\n  }\n}\n\nfunction serializeStructure(prefix, struct, rules, fn) {\n  util.each(rules.members, function(name, member) {\n    var value = struct[name];\n    if (value === null || value === undefined) return;\n\n    var memberName = ucfirst(member);\n    memberName = prefix ? prefix + \'.\' + memberName : memberName;\n    serializeMember(memberName, value, member, fn);\n  });\n}\n\nfunction serializeMap(name, map, rules, fn) {\n  var i = 1;\n  util.each(map, function (key, value) {\n    var prefix = rules.flattened ? \'.\' : \'.entry.\';\n    var position = prefix + (i++) + \'.\';\n    var keyName = position + (rules.key.name || \'key\');\n    var valueName = position + (rules.value.name || \'value\');\n    serializeMember(name + keyName, key, rules.key, fn);\n    serializeMember(name + valueName, value, rules.value, fn);\n  });\n}\n\nfunction serializeList(name, list, rules, fn) {\n  var memberRules = rules.member || {};\n\n  if (list.length === 0) {\n    fn.call(this, name, null);\n    return;\n  }\n\n  util.arrayEach(list, function (v, n) {\n    var suffix = \'.\' + (n + 1);\n    if (rules.api.protocol === \'ec2\') {\n      suffix = suffix + \'\'; // make linter happy\n    } else if (rules.flattened) {\n      if (memberRules.name) {\n        var parts = name.split(\'.\');\n        parts.pop();\n        parts.push(ucfirst(memberRules));\n        name = parts.join(\'.\');\n      }\n    } else {\n      suffix = \'.member\' + suffix;\n    }\n    serializeMember(name + suffix, v, memberRules, fn);\n  });\n}\n\nfunction serializeMember(name, value, rules, fn) {\n  if (value === null || value === undefined) return;\n  if (rules.type === \'structure\') {\n    serializeStructure(name, value, rules, fn);\n  } else if (rules.type === \'list\') {\n    serializeList(name, value, rules, fn);\n  } else if (rules.type === \'map\') {\n    serializeMap(name, value, rules, fn);\n  } else {\n    fn(name, rules.toWireFormat(value).toString());\n  }\n}\n\nmodule.exports = QueryParamSerializer;\n\n},{"../util":52}],35:[function(require,module,exports){\nmodule.exports={\n  "rules": {\n    "*/*": {\n      "endpoint": "{service}.{region}.amazonaws.com"\n    },\n    "cn-*/*": {\n      "endpoint": "{service}.{region}.amazonaws.com.cn"\n    },\n    "*/budgets": "globalSSL",\n    "*/cloudfront": "globalSSL",\n    "*/iam": "globalSSL",\n    "*/sts": "globalSSL",\n    "*/importexport": {\n      "endpoint": "{service}.amazonaws.com",\n      "signatureVersion": "v2",\n      "globalEndpoint": true\n    },\n    "*/route53": {\n      "endpoint": "https://{service}.amazonaws.com",\n      "signatureVersion": "v3https",\n      "globalEndpoint": true\n    },\n    "*/waf": "globalSSL",\n    "us-gov-*/iam": "globalGovCloud",\n    "us-gov-*/sts": {\n      "endpoint": "{service}.{region}.amazonaws.com"\n    },\n    "us-gov-west-1/s3": "s3dash",\n    "us-west-1/s3": "s3dash",\n    "us-west-2/s3": "s3dash",\n    "eu-west-1/s3": "s3dash",\n    "ap-southeast-1/s3": "s3dash",\n    "ap-southeast-2/s3": "s3dash",\n    "ap-northeast-1/s3": "s3dash",\n    "sa-east-1/s3": "s3dash",\n    "us-east-1/s3": {\n      "endpoint": "{service}.amazonaws.com",\n      "signatureVersion": "s3"\n    },\n    "us-east-1/sdb": {\n      "endpoint": "{service}.amazonaws.com",\n      "signatureVersion": "v2"\n    },\n    "*/sdb": {\n      "endpoint": "{service}.{region}.amazonaws.com",\n      "signatureVersion": "v2"\n    }\n  },\n\n  "patterns": {\n    "globalSSL": {\n      "endpoint": "https://{service}.amazonaws.com",\n      "globalEndpoint": true\n    },\n    "globalGovCloud": {\n      "endpoint": "{service}.us-gov.amazonaws.com"\n    },\n    "s3dash": {\n      "endpoint": "{service}-{region}.amazonaws.com",\n      "signatureVersion": "s3"\n    }\n  }\n}\n\n},{}],36:[function(require,module,exports){\nvar util = require(\'./util\');\nvar regionConfig = require(\'./region_config.json\');\n\nfunction generateRegionPrefix(region) {\n  if (!region) return null;\n\n  var parts = region.split(\'-\');\n  if (parts.length < 3) return null;\n  return parts.slice(0, parts.length - 2).join(\'-\') + \'-*\';\n}\n\nfunction derivedKeys(service) {\n  var region = service.config.region;\n  var regionPrefix = generateRegionPrefix(region);\n  var endpointPrefix = service.api.endpointPrefix;\n\n  return [\n    [region, endpointPrefix],\n    [regionPrefix, endpointPrefix],\n    [region, \'*\'],\n    [regionPrefix, \'*\'],\n    [\'*\', endpointPrefix],\n    [\'*\', \'*\']\n  ].map(function(item) {\n    return item[0] && item[1] ? item.join(\'/\') : null;\n  });\n}\n\nfunction applyConfig(service, config) {\n  util.each(config, function(key, value) {\n    if (key === \'globalEndpoint\') return;\n    if (service.config[key] === undefined || service.config[key] === null) {\n      service.config[key] = value;\n    }\n  });\n}\n\nfunction configureEndpoint(service) {\n  var keys = derivedKeys(service);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (!key) continue;\n\n    if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {\n      var config = regionConfig.rules[key];\n      if (typeof config === \'string\') {\n        config = regionConfig.patterns[config];\n      }\n\n      if (service.config.useDualstack && util.isDualstackAvailable(service)) {\n        config = util.copy(config);\n        config.endpoint = \'{service}.dualstack.{region}.amazonaws.com\';\n      }\n\n      service.isGlobalEndpoint = !!config.globalEndpoint;\n\n      if (!config.signatureVersion) config.signatureVersion = \'v4\';\n\n      applyConfig(service, config);\n      return;\n    }\n  }\n}\n\nmodule.exports = configureEndpoint;\n\n},{"./region_config.json":35,"./util":52}],37:[function(require,module,exports){\n(function (process){\nvar AWS = require(\'./core\');\nvar AcceptorStateMachine = require(\'./state_machine\');\nvar inherit = AWS.util.inherit;\nvar domain = AWS.util.domain;\nvar jmespath = require(\'jmespath\');\n\n\nvar hardErrorStates = {success: 1, error: 1, complete: 1};\n\nfunction isTerminalState(machine) {\n  return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);\n}\n\nvar fsm = new AcceptorStateMachine();\nfsm.setupStates = function() {\n  var transition = function(_, done) {\n    var self = this;\n    self._haltHandlersOnError = false;\n\n    self.emit(self._asm.currentState, function(err) {\n      if (err) {\n        if (isTerminalState(self)) {\n          if (domain && self.domain instanceof domain.Domain) {\n            err.domainEmitter = self;\n            err.domain = self.domain;\n            err.domainThrown = false;\n            self.domain.emit(\'error\', err);\n          } else {\n            throw err;\n          }\n        } else {\n          self.response.error = err;\n          done(err);\n        }\n      } else {\n        done(self.response.error);\n      }\n    });\n\n  };\n\n  this.addState(\'validate\', \'build\', \'error\', transition);\n  this.addState(\'build\', \'afterBuild\', \'restart\', transition);\n  this.addState(\'afterBuild\', \'sign\', \'restart\', transition);\n  this.addState(\'sign\', \'send\', \'retry\', transition);\n  this.addState(\'retry\', \'afterRetry\', \'afterRetry\', transition);\n  this.addState(\'afterRetry\', \'sign\', \'error\', transition);\n  this.addState(\'send\', \'validateResponse\', \'retry\', transition);\n  this.addState(\'validateResponse\', \'extractData\', \'extractError\', transition);\n  this.addState(\'extractError\', \'extractData\', \'retry\', transition);\n  this.addState(\'extractData\', \'success\', \'retry\', transition);\n  this.addState(\'restart\', \'build\', \'error\', transition);\n  this.addState(\'success\', \'complete\', \'complete\', transition);\n  this.addState(\'error\', \'complete\', \'complete\', transition);\n  this.addState(\'complete\', null, null, transition);\n};\nfsm.setupStates();\n\n\nAWS.Request = inherit({\n\n\n  constructor: function Request(service, operation, params) {\n    var endpoint = service.endpoint;\n    var region = service.config.region;\n    var customUserAgent = service.config.customUserAgent;\n\n    if (service.isGlobalEndpoint) region = \'us-east-1\';\n\n    this.domain = domain && domain.active;\n    this.service = service;\n    this.operation = operation;\n    this.params = params || {};\n    this.httpRequest = new AWS.HttpRequest(endpoint, region, customUserAgent);\n    this.startTime = AWS.util.date.getDate();\n\n    this.response = new AWS.Response(this);\n    this._asm = new AcceptorStateMachine(fsm.states, \'validate\');\n    this._haltHandlersOnError = false;\n\n    AWS.SequentialExecutor.call(this);\n    this.emit = this.emitEvent;\n  },\n\n\n\n\n  send: function send(callback) {\n    if (callback) {\n      this.on(\'complete\', function (resp) {\n        callback.call(resp, resp.error, resp.data);\n      });\n    }\n    this.runTo();\n\n    return this.response;\n  },\n\n\n\n\n  build: function build(callback) {\n    return this.runTo(\'send\', callback);\n  },\n\n\n  runTo: function runTo(state, done) {\n    this._asm.runTo(state, done, this);\n    return this;\n  },\n\n\n  abort: function abort() {\n    this.removeAllListeners(\'validateResponse\');\n    this.removeAllListeners(\'extractError\');\n    this.on(\'validateResponse\', function addAbortedError(resp) {\n      resp.error = AWS.util.error(new Error(\'Request aborted by user\'), {\n         code: \'RequestAbortedError\', retryable: false\n      });\n    });\n\n    if (this.httpRequest.stream) { // abort HTTP stream\n      this.httpRequest.stream.abort();\n      if (this.httpRequest._abortCallback) {\n         this.httpRequest._abortCallback();\n      } else {\n        this.removeAllListeners(\'send\'); // haven\'t sent yet, so let\'s not\n      }\n    }\n\n    return this;\n  },\n\n\n  eachPage: function eachPage(callback) {\n    callback = AWS.util.fn.makeAsync(callback, 3);\n\n    function wrappedCallback(response) {\n      callback.call(response, response.error, response.data, function (result) {\n        if (result === false) return;\n\n        if (response.hasNextPage()) {\n          response.nextPage().on(\'complete\', wrappedCallback).send();\n        } else {\n          callback.call(response, null, null, AWS.util.fn.noop);\n        }\n      });\n    }\n\n    this.on(\'complete\', wrappedCallback).send();\n  },\n\n\n  eachItem: function eachItem(callback) {\n    var self = this;\n    function wrappedCallback(err, data) {\n      if (err) return callback(err, null);\n      if (data === null) return callback(null, null);\n\n      var config = self.service.paginationConfig(self.operation);\n      var resultKey = config.resultKey;\n      if (Array.isArray(resultKey)) resultKey = resultKey[0];\n      var items = jmespath.search(data, resultKey);\n      var continueIteration = true;\n      AWS.util.arrayEach(items, function(item) {\n        continueIteration = callback(null, item);\n        if (continueIteration === false) {\n          return AWS.util.abort;\n        }\n      });\n      return continueIteration;\n    }\n\n    this.eachPage(wrappedCallback);\n  },\n\n\n  isPageable: function isPageable() {\n    return this.service.paginationConfig(this.operation) ? true : false;\n  },\n\n\n  createReadStream: function createReadStream() {\n    var streams = AWS.util.stream;\n    var req = this;\n    var stream = null;\n\n    if (AWS.HttpClient.streamsApiVersion === 2) {\n      stream = new streams.PassThrough();\n      req.send();\n    } else {\n      stream = new streams.Stream();\n      stream.readable = true;\n\n      stream.sent = false;\n      stream.on(\'newListener\', function(event) {\n        if (!stream.sent && event === \'data\') {\n          stream.sent = true;\n          process.nextTick(function() { req.send(); });\n        }\n      });\n    }\n\n    this.on(\'httpHeaders\', function streamHeaders(statusCode, headers, resp) {\n      if (statusCode < 300) {\n        req.removeListener(\'httpData\', AWS.EventListeners.Core.HTTP_DATA);\n        req.removeListener(\'httpError\', AWS.EventListeners.Core.HTTP_ERROR);\n        req.on(\'httpError\', function streamHttpError(error) {\n          resp.error = error;\n          resp.error.retryable = false;\n        });\n\n        var shouldCheckContentLength = false;\n        var expectedLen;\n        if (req.httpRequest.method !== \'HEAD\') {\n          expectedLen = parseInt(headers[\'content-length\'], 10);\n        }\n        if (expectedLen !== undefined && !isNaN(expectedLen) && expectedLen >= 0) {\n          shouldCheckContentLength = true;\n          var receivedLen = 0;\n        }\n\n        var checkContentLengthAndEmit = function checkContentLengthAndEmit() {\n          if (shouldCheckContentLength && receivedLen !== expectedLen) {\n            stream.emit(\'error\', AWS.util.error(\n              new Error(\'Stream content length mismatch. Received \' +\n                receivedLen + \' of \' + expectedLen + \' bytes.\'),\n              { code: \'StreamContentLengthMismatch\' }\n            ));\n          } else if (AWS.HttpClient.streamsApiVersion === 2) {\n            stream.end();\n          } else {\n            stream.emit(\'end\')\n          }\n        }\n\n        var httpStream = resp.httpResponse.createUnbufferedStream();\n\n        if (AWS.HttpClient.streamsApiVersion === 2) {\n          if (shouldCheckContentLength) {\n            var lengthAccumulator = new streams.PassThrough();\n            lengthAccumulator._write = function(chunk) {\n              if (chunk && chunk.length) {\n                receivedLen += chunk.length;\n              }\n              return streams.PassThrough.prototype._write.apply(this, arguments);\n            };\n\n            lengthAccumulator.on(\'end\', checkContentLengthAndEmit);\n            httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });\n          } else {\n            httpStream.pipe(stream);\n          }\n        } else {\n\n          if (shouldCheckContentLength) {\n            httpStream.on(\'data\', function(arg) {\n              if (arg && arg.length) {\n                receivedLen += arg.length;\n              }\n            });\n          }\n\n          httpStream.on(\'data\', function(arg) {\n            stream.emit(\'data\', arg);\n          });\n          httpStream.on(\'end\', checkContentLengthAndEmit);\n        }\n\n        httpStream.on(\'error\', function(err) {\n          shouldCheckContentLength = false;\n          stream.emit(\'error\', err);\n        });\n      }\n    });\n\n    this.on(\'error\', function(err) {\n      stream.emit(\'error\', err);\n    });\n\n    return stream;\n  },\n\n\n  emitEvent: function emit(eventName, args, done) {\n    if (typeof args === \'function\') { done = args; args = null; }\n    if (!done) done = function() { };\n    if (!args) args = this.eventParameters(eventName, this.response);\n\n    var origEmit = AWS.SequentialExecutor.prototype.emit;\n    origEmit.call(this, eventName, args, function (err) {\n      if (err) this.response.error = err;\n      done.call(this, err);\n    });\n  },\n\n\n  eventParameters: function eventParameters(eventName) {\n    switch (eventName) {\n      case \'restart\':\n      case \'validate\':\n      case \'sign\':\n      case \'build\':\n      case \'afterValidate\':\n      case \'afterBuild\':\n        return [this];\n      case \'error\':\n        return [this.response.error, this.response];\n      default:\n        return [this.response];\n    }\n  },\n\n\n  presign: function presign(expires, callback) {\n    if (!callback && typeof expires === \'function\') {\n      callback = expires;\n      expires = null;\n    }\n    return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);\n  },\n\n\n  isPresigned: function isPresigned() {\n    return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, \'presigned-expires\');\n  },\n\n\n  toUnauthenticated: function toUnauthenticated() {\n    this.removeListener(\'validate\', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);\n    this.removeListener(\'sign\', AWS.EventListeners.Core.SIGN);\n    return this;\n  },\n\n\n  toGet: function toGet() {\n    if (this.service.api.protocol === \'query\' ||\n        this.service.api.protocol === \'ec2\') {\n      this.removeListener(\'build\', this.buildAsGet);\n      this.addListener(\'build\', this.buildAsGet);\n    }\n    return this;\n  },\n\n\n  buildAsGet: function buildAsGet(request) {\n    request.httpRequest.method = \'GET\';\n    request.httpRequest.path = request.service.endpoint.path +\n                               \'?\' + request.httpRequest.body;\n    request.httpRequest.body = \'\';\n\n    delete request.httpRequest.headers[\'Content-Length\'];\n    delete request.httpRequest.headers[\'Content-Type\'];\n  },\n\n\n  haltHandlersOnError: function haltHandlersOnError() {\n    this._haltHandlersOnError = true;\n  }\n});\n\n\nAWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {\n  this.prototype.promise = function promise() {\n    var self = this;\n    return new PromiseDependency(function(resolve, reject) {\n      self.on(\'complete\', function(resp) {\n        if (resp.error) {\n          reject(resp.error);\n        } else {\n          resolve(resp.data);\n        }\n      });\n      self.runTo();\n    });\n  };\n};\n\n\nAWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {\n  delete this.prototype.promise;\n};\n\nAWS.util.addPromises(AWS.Request);\n\nAWS.util.mixin(AWS.Request, AWS.SequentialExecutor);\n\n}).call(this,require(\'_process\'))\n},{"./core":10,"./state_machine":51,"_process":117,"jmespath":68}],38:[function(require,module,exports){\n\n\nvar AWS = require(\'./core\');\nvar inherit = AWS.util.inherit;\nvar jmespath = require(\'jmespath\');\n\n\nfunction CHECK_ACCEPTORS(resp) {\n  var waiter = resp.request._waiter;\n  var acceptors = waiter.config.acceptors;\n  var acceptorMatched = false;\n  var state = \'retry\';\n\n  acceptors.forEach(function(acceptor) {\n    if (!acceptorMatched) {\n      var matcher = waiter.matchers[acceptor.matcher];\n      if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {\n        acceptorMatched = true;\n        state = acceptor.state;\n      }\n    }\n  });\n\n  if (!acceptorMatched && resp.error) state = \'failure\';\n\n  if (state === \'success\') {\n    waiter.setSuccess(resp);\n  } else {\n    waiter.setError(resp, state === \'retry\');\n  }\n}\n\n\nAWS.ResourceWaiter = inherit({\n\n  constructor: function constructor(service, state) {\n    this.service = service;\n    this.state = state;\n    this.loadWaiterConfig(this.state);\n  },\n\n  service: null,\n\n  state: null,\n\n  config: null,\n\n  matchers: {\n    path: function(resp, expected, argument) {\n      var result = jmespath.search(resp.data, argument);\n      return jmespath.strictDeepEqual(result,expected);\n    },\n\n    pathAll: function(resp, expected, argument) {\n      var results = jmespath.search(resp.data, argument);\n      if (!Array.isArray(results)) results = [results];\n      var numResults = results.length;\n      if (!numResults) return false;\n      for (var ind = 0 ; ind < numResults; ind++) {\n        if (!jmespath.strictDeepEqual(results[ind], expected)) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    pathAny: function(resp, expected, argument) {\n      var results = jmespath.search(resp.data, argument);\n      if (!Array.isArray(results)) results = [results];\n      var numResults = results.length;\n      for (var ind = 0 ; ind < numResults; ind++) {\n        if (jmespath.strictDeepEqual(results[ind], expected)) {\n          return true;\n        }\n      }\n      return false;\n    },\n\n    status: function(resp, expected) {\n      var statusCode = resp.httpResponse.statusCode;\n      return (typeof statusCode === \'number\') && (statusCode === expected);\n    },\n\n    error: function(resp, expected) {\n      if (typeof expected === \'string\' && resp.error) {\n        return expected === resp.error.code;\n      }\n      return expected === !!resp.error;\n    }\n  },\n\n  listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {\n    add(\'RETRY_CHECK\', \'retry\', function(resp) {\n      var waiter = resp.request._waiter;\n      if (resp.error && resp.error.code === \'ResourceNotReady\') {\n        resp.error.retryDelay = (waiter.config.delay || 0) * 1000;\n      }\n    });\n\n    add(\'CHECK_OUTPUT\', \'extractData\', CHECK_ACCEPTORS);\n\n    add(\'CHECK_ERROR\', \'extractError\', CHECK_ACCEPTORS);\n  }),\n\n\n  wait: function wait(params, callback) {\n    if (typeof params === \'function\') {\n      callback = params; params = undefined;\n    }\n\n    var request = this.service.makeRequest(this.config.operation, params);\n    request._waiter = this;\n    request.response.maxRetries = this.config.maxAttempts;\n    request.addListeners(this.listeners);\n\n    if (callback) request.send(callback);\n    return request;\n  },\n\n  setSuccess: function setSuccess(resp) {\n    resp.error = null;\n    resp.data = resp.data || {};\n    resp.request.removeAllListeners(\'extractData\');\n  },\n\n  setError: function setError(resp, retryable) {\n    resp.data = null;\n    resp.error = AWS.util.error(resp.error || new Error(), {\n      code: \'ResourceNotReady\',\n      message: \'Resource is not in the state \' + this.state,\n      retryable: retryable\n    });\n  },\n\n\n  loadWaiterConfig: function loadWaiterConfig(state) {\n    if (!this.service.api.waiters[state]) {\n      throw new AWS.util.error(new Error(), {\n        code: \'StateNotFoundError\',\n        message: \'State \' + state + \' not found.\'\n      });\n    }\n\n    this.config = this.service.api.waiters[state];\n  }\n});\n\n},{"./core":10,"jmespath":68}],39:[function(require,module,exports){\nvar AWS = require(\'./core\');\nvar inherit = AWS.util.inherit;\nvar jmespath = require(\'jmespath\');\n\n\nAWS.Response = inherit({\n\n\n  constructor: function Response(request) {\n    this.request = request;\n    this.data = null;\n    this.error = null;\n    this.retryCount = 0;\n    this.redirectCount = 0;\n    this.httpResponse = new AWS.HttpResponse();\n    if (request) {\n      this.maxRetries = request.service.numRetries();\n      this.maxRedirects = request.service.config.maxRedirects;\n    }\n  },\n\n\n  nextPage: function nextPage(callback) {\n    var config;\n    var service = this.request.service;\n    var operation = this.request.operation;\n    try {\n      config = service.paginationConfig(operation, true);\n    } catch (e) { this.error = e; }\n\n    if (!this.hasNextPage()) {\n      if (callback) callback(this.error, null);\n      else if (this.error) throw this.error;\n      return null;\n    }\n\n    var params = AWS.util.copy(this.request.params);\n    if (!this.nextPageTokens) {\n      return callback ? callback(null, null) : null;\n    } else {\n      var inputTokens = config.inputToken;\n      if (typeof inputTokens === \'string\') inputTokens = [inputTokens];\n      for (var i = 0; i < inputTokens.length; i++) {\n        params[inputTokens[i]] = this.nextPageTokens[i];\n      }\n      return service.makeRequest(this.request.operation, params, callback);\n    }\n  },\n\n\n  hasNextPage: function hasNextPage() {\n    this.cacheNextPageTokens();\n    if (this.nextPageTokens) return true;\n    if (this.nextPageTokens === undefined) return undefined;\n    else return false;\n  },\n\n\n  cacheNextPageTokens: function cacheNextPageTokens() {\n    if (Object.prototype.hasOwnProperty.call(this, \'nextPageTokens\')) return this.nextPageTokens;\n    this.nextPageTokens = undefined;\n\n    var config = this.request.service.paginationConfig(this.request.operation);\n    if (!config) return this.nextPageTokens;\n\n    this.nextPageTokens = null;\n    if (config.moreResults) {\n      if (!jmespath.search(this.data, config.moreResults)) {\n        return this.nextPageTokens;\n      }\n    }\n\n    var exprs = config.outputToken;\n    if (typeof exprs === \'string\') exprs = [exprs];\n    AWS.util.arrayEach.call(this, exprs, function (expr) {\n      var output = jmespath.search(this.data, expr);\n      if (output) {\n        this.nextPageTokens = this.nextPageTokens || [];\n        this.nextPageTokens.push(output);\n      }\n    });\n\n    return this.nextPageTokens;\n  }\n\n});\n\n},{"./core":10,"jmespath":68}],40:[function(require,module,exports){\nvar AWS = require(\'./core\');\n\n\nAWS.SequentialExecutor = AWS.util.inherit({\n\n  constructor: function SequentialExecutor() {\n    this._events = {};\n  },\n\n\n  listeners: function listeners(eventName) {\n    return this._events[eventName] ? this._events[eventName].slice(0) : [];\n  },\n\n  on: function on(eventName, listener) {\n    if (this._events[eventName]) {\n      this._events[eventName].push(listener);\n    } else {\n      this._events[eventName] = [listener];\n    }\n    return this;\n  },\n\n\n  onAsync: function onAsync(eventName, listener) {\n    listener._isAsync = true;\n    return this.on(eventName, listener);\n  },\n\n  removeListener: function removeListener(eventName, listener) {\n    var listeners = this._events[eventName];\n    if (listeners) {\n      var length = listeners.length;\n      var position = -1;\n      for (var i = 0; i < length; ++i) {\n        if (listeners[i] === listener) {\n          position = i;\n        }\n      }\n      if (position > -1) {\n        listeners.splice(position, 1);\n      }\n    }\n    return this;\n  },\n\n  removeAllListeners: function removeAllListeners(eventName) {\n    if (eventName) {\n      delete this._events[eventName];\n    } else {\n      this._events = {};\n    }\n    return this;\n  },\n\n\n  emit: function emit(eventName, eventArgs, doneCallback) {\n    if (!doneCallback) doneCallback = function() { };\n    var listeners = this.listeners(eventName);\n    var count = listeners.length;\n    this.callListeners(listeners, eventArgs, doneCallback);\n    return count > 0;\n  },\n\n\n  callListeners: function callListeners(listeners, args, doneCallback, prevError) {\n    var self = this;\n    var error = prevError || null;\n\n    function callNextListener(err) {\n      if (err) {\n        error = AWS.util.error(error || new Error(), err);\n        if (self._haltHandlersOnError) {\n          return doneCallback.call(self, error);\n        }\n      }\n      self.callListeners(listeners, args, doneCallback, error);\n    }\n\n    while (listeners.length > 0) {\n      var listener = listeners.shift();\n      if (listener._isAsync) { // asynchronous listener\n        listener.apply(self, args.concat([callNextListener]));\n        return; // stop here, callNextListener will continue\n      } else { // synchronous listener\n        try {\n          listener.apply(self, args);\n        } catch (err) {\n          error = AWS.util.error(error || new Error(), err);\n        }\n        if (error && self._haltHandlersOnError) {\n          doneCallback.call(self, error);\n          return;\n        }\n      }\n    }\n    doneCallback.call(self, error);\n  },\n\n\n  addListeners: function addListeners(listeners) {\n    var self = this;\n\n    if (listeners._events) listeners = listeners._events;\n\n    AWS.util.each(listeners, function(event, callbacks) {\n      if (typeof callbacks === \'function\') callbacks = [callbacks];\n      AWS.util.arrayEach(callbacks, function(callback) {\n        self.on(event, callback);\n      });\n    });\n\n    return self;\n  },\n\n\n  addNamedListener: function addNamedListener(name, eventName, callback) {\n    this[name] = callback;\n    this.addListener(eventName, callback);\n    return this;\n  },\n\n\n  addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {\n    callback._isAsync = true;\n    return this.addNamedListener(name, eventName, callback);\n  },\n\n\n  addNamedListeners: function addNamedListeners(callback) {\n    var self = this;\n    callback(\n      function() {\n        self.addNamedListener.apply(self, arguments);\n      },\n      function() {\n        self.addNamedAsyncListener.apply(self, arguments);\n      }\n    );\n    return this;\n  }\n});\n\n\nAWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;\n\nmodule.exports = AWS.SequentialExecutor;\n\n},{"./core":10}],41:[function(require,module,exports){\nvar AWS = require(\'./core\');\nvar Api = require(\'./model/api\');\nvar regionConfig = require(\'./region_config\');\nvar inherit = AWS.util.inherit;\nvar clientCount = 0;\n\n\nAWS.Service = inherit({\n\n  constructor: function Service(config) {\n    if (!this.loadServiceClass) {\n      throw AWS.util.error(new Error(),\n        \'Service must be constructed with `new\\\' operator\');\n    }\n    var ServiceClass = this.loadServiceClass(config || {});\n    if (ServiceClass) {\n      var originalConfig = AWS.util.copy(config);\n      var svc = new ServiceClass(config);\n      Object.defineProperty(svc, \'_originalConfig\', {\n        get: function() { return originalConfig; },\n        enumerable: false,\n        configurable: true\n      });\n      svc._clientId = ++clientCount;\n      return svc;\n    }\n    this.initialize(config);\n  },\n\n\n  initialize: function initialize(config) {\n    var svcConfig = AWS.config[this.serviceIdentifier];\n\n    this.config = new AWS.Config(AWS.config);\n    if (svcConfig) this.config.update(svcConfig, true);\n    if (config) this.config.update(config, true);\n\n    this.validateService();\n    if (!this.config.endpoint) regionConfig(this);\n\n    this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);\n    this.setEndpoint(this.config.endpoint);\n  },\n\n\n  validateService: function validateService() {\n  },\n\n\n  loadServiceClass: function loadServiceClass(serviceConfig) {\n    var config = serviceConfig;\n    if (!AWS.util.isEmpty(this.api)) {\n      return null;\n    } else if (config.apiConfig) {\n      return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);\n    } else if (!this.constructor.services) {\n      return null;\n    } else {\n      config = new AWS.Config(AWS.config);\n      config.update(serviceConfig, true);\n      var version = config.apiVersions[this.constructor.serviceIdentifier];\n      version = version || config.apiVersion;\n      return this.getLatestServiceClass(version);\n    }\n  },\n\n\n  getLatestServiceClass: function getLatestServiceClass(version) {\n    version = this.getLatestServiceVersion(version);\n    if (this.constructor.services[version] === null) {\n      AWS.Service.defineServiceApi(this.constructor, version);\n    }\n\n    return this.constructor.services[version];\n  },\n\n\n  getLatestServiceVersion: function getLatestServiceVersion(version) {\n    if (!this.constructor.services || this.constructor.services.length === 0) {\n      throw new Error(\'No services defined on \' +\n                      this.constructor.serviceIdentifier);\n    }\n\n    if (!version) {\n      version = \'latest\';\n    } else if (AWS.util.isType(version, Date)) {\n      version = AWS.util.date.iso8601(version).split(\'T\')[0];\n    }\n\n    if (Object.hasOwnProperty(this.constructor.services, version)) {\n      return version;\n    }\n\n    var keys = Object.keys(this.constructor.services).sort();\n    var selectedVersion = null;\n    for (var i = keys.length - 1; i >= 0; i--) {\n      if (keys[i][keys[i].length - 1] !== \'*\') {\n        selectedVersion = keys[i];\n      }\n      if (keys[i].substr(0, 10) <= version) {\n        return selectedVersion;\n      }\n    }\n\n    throw new Error(\'Could not find \' + this.constructor.serviceIdentifier +\n                    \' API to satisfy version constraint `\' + version + \'\\\'\');\n  },\n\n\n  api: {},\n\n\n  defaultRetryCount: 3,\n\n\n  makeRequest: function makeRequest(operation, params, callback) {\n    if (typeof params === \'function\') {\n      callback = params;\n      params = null;\n    }\n\n    params = params || {};\n    if (this.config.params) { // copy only toplevel bound params\n      var rules = this.api.operations[operation];\n      if (rules) {\n        params = AWS.util.copy(params);\n        AWS.util.each(this.config.params, function(key, value) {\n          if (rules.input.members[key]) {\n            if (params[key] === undefined || params[key] === null) {\n              params[key] = value;\n            }\n          }\n        });\n      }\n    }\n\n    var request = new AWS.Request(this, operation, params);\n    this.addAllRequestListeners(request);\n\n    if (callback) request.send(callback);\n    return request;\n  },\n\n\n  makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {\n    if (typeof params === \'function\') {\n      callback = params;\n      params = {};\n    }\n\n    var request = this.makeRequest(operation, params).toUnauthenticated();\n    return callback ? request.send(callback) : request;\n  },\n\n\n  waitFor: function waitFor(state, params, callback) {\n    var waiter = new AWS.ResourceWaiter(this, state);\n    return waiter.wait(params, callback);\n  },\n\n\n  addAllRequestListeners: function addAllRequestListeners(request) {\n    var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),\n                AWS.EventListeners.CorePost];\n    for (var i = 0; i < list.length; i++) {\n      if (list[i]) request.addListeners(list[i]);\n    }\n\n    if (!this.config.paramValidation) {\n      request.removeListener(\'validate\',\n        AWS.EventListeners.Core.VALIDATE_PARAMETERS);\n    }\n\n    if (this.config.logger) { // add logging events\n      request.addListeners(AWS.EventListeners.Logger);\n    }\n\n    this.setupRequestListeners(request);\n  },\n\n\n  setupRequestListeners: function setupRequestListeners() {\n  },\n\n\n  getSignerClass: function getSignerClass() {\n    var version;\n    if (this.config.signatureVersion) {\n      version = this.config.signatureVersion;\n    } else {\n      version = this.api.signatureVersion;\n    }\n    return AWS.Signers.RequestSigner.getVersion(version);\n  },\n\n\n  serviceInterface: function serviceInterface() {\n    switch (this.api.protocol) {\n      case \'ec2\': return AWS.EventListeners.Query;\n      case \'query\': return AWS.EventListeners.Query;\n      case \'json\': return AWS.EventListeners.Json;\n      case \'rest-json\': return AWS.EventListeners.RestJson;\n      case \'rest-xml\': return AWS.EventListeners.RestXml;\n    }\n    if (this.api.protocol) {\n      throw new Error(\'Invalid service `protocol\\\' \' +\n        this.api.protocol + \' in API config\');\n    }\n  },\n\n\n  successfulResponse: function successfulResponse(resp) {\n    return resp.httpResponse.statusCode < 300;\n  },\n\n\n  numRetries: function numRetries() {\n    if (this.config.maxRetries !== undefined) {\n      return this.config.maxRetries;\n    } else {\n      return this.defaultRetryCount;\n    }\n  },\n\n\n  retryDelays: function retryDelays(retryCount) {\n    return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions);\n  },\n\n\n  retryableError: function retryableError(error) {\n    if (this.networkingError(error)) return true;\n    if (this.expiredCredentialsError(error)) return true;\n    if (this.throttledError(error)) return true;\n    if (error.statusCode >= 500) return true;\n    return false;\n  },\n\n\n  networkingError: function networkingError(error) {\n    return error.code === \'NetworkingError\';\n  },\n\n\n  expiredCredentialsError: function expiredCredentialsError(error) {\n    return (error.code === \'ExpiredTokenException\');\n  },\n\n\n  clockSkewError: function clockSkewError(error) {\n    switch (error.code) {\n      case \'RequestTimeTooSkewed\':\n      case \'RequestExpired\':\n      case \'InvalidSignatureException\':\n      case \'SignatureDoesNotMatch\':\n      case \'AuthFailure\':\n      case \'RequestInTheFuture\':\n        return true;\n      default: return false;\n    }\n  },\n\n\n  throttledError: function throttledError(error) {\n    switch (error.code) {\n      case \'ProvisionedThroughputExceededException\':\n      case \'Throttling\':\n      case \'ThrottlingException\':\n      case \'RequestLimitExceeded\':\n      case \'RequestThrottled\':\n        return true;\n      default:\n        return false;\n    }\n  },\n\n\n  endpointFromTemplate: function endpointFromTemplate(endpoint) {\n    if (typeof endpoint !== \'string\') return endpoint;\n\n    var e = endpoint;\n    e = e.replace(/\\{service\\}/g, this.api.endpointPrefix);\n    e = e.replace(/\\{region\\}/g, this.config.region);\n    e = e.replace(/\\{scheme\\}/g, this.config.sslEnabled ? \'https\' : \'http\');\n    return e;\n  },\n\n\n  setEndpoint: function setEndpoint(endpoint) {\n    this.endpoint = new AWS.Endpoint(endpoint, this.config);\n  },\n\n\n  paginationConfig: function paginationConfig(operation, throwException) {\n    var paginator = this.api.operations[operation].paginator;\n    if (!paginator) {\n      if (throwException) {\n        var e = new Error();\n        throw AWS.util.error(e, \'No pagination configuration for \' + operation);\n      }\n      return null;\n    }\n\n    return paginator;\n  }\n});\n\nAWS.util.update(AWS.Service, {\n\n\n  defineMethods: function defineMethods(svc) {\n    AWS.util.each(svc.prototype.api.operations, function iterator(method) {\n      if (svc.prototype[method]) return;\n      var operation = svc.prototype.api.operations[method];\n      if (operation.authtype === \'none\') {\n        svc.prototype[method] = function (params, callback) {\n          return this.makeUnauthenticatedRequest(method, params, callback);\n        };\n      } else {\n        svc.prototype[method] = function (params, callback) {\n          return this.makeRequest(method, params, callback);\n        };\n      }\n    });\n  },\n\n\n  defineService: function defineService(serviceIdentifier, versions, features) {\n    AWS.Service._serviceMap[serviceIdentifier] = true;\n    if (!Array.isArray(versions)) {\n      features = versions;\n      versions = [];\n    }\n\n    var svc = inherit(AWS.Service, features || {});\n\n    if (typeof serviceIdentifier === \'string\') {\n      AWS.Service.addVersions(svc, versions);\n\n      var identifier = svc.serviceIdentifier || serviceIdentifier;\n      svc.serviceIdentifier = identifier;\n    } else { // defineService called with an API\n      svc.prototype.api = serviceIdentifier;\n      AWS.Service.defineMethods(svc);\n    }\n\n    return svc;\n  },\n\n\n  addVersions: function addVersions(svc, versions) {\n    if (!Array.isArray(versions)) versions = [versions];\n\n    svc.services = svc.services || {};\n    for (var i = 0; i < versions.length; i++) {\n      if (svc.services[versions[i]] === undefined) {\n        svc.services[versions[i]] = null;\n      }\n    }\n\n    svc.apiVersions = Object.keys(svc.services).sort();\n  },\n\n\n  defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {\n    var svc = inherit(superclass, {\n      serviceIdentifier: superclass.serviceIdentifier\n    });\n\n    function setApi(api) {\n      if (api.isApi) {\n        svc.prototype.api = api;\n      } else {\n        svc.prototype.api = new Api(api);\n      }\n    }\n\n    if (typeof version === \'string\') {\n      if (apiConfig) {\n        setApi(apiConfig);\n      } else {\n        try {\n          setApi(AWS.apiLoader(superclass.serviceIdentifier, version));\n        } catch (err) {\n          throw AWS.util.error(err, {\n            message: \'Could not find API configuration \' +\n              superclass.serviceIdentifier + \'-\' + version\n          });\n        }\n      }\n      if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {\n        superclass.apiVersions = superclass.apiVersions.concat(version).sort();\n      }\n      superclass.services[version] = svc;\n    } else {\n      setApi(version);\n    }\n\n    AWS.Service.defineMethods(svc);\n    return svc;\n  },\n\n\n  hasService: function(identifier) {\n    return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);\n  },\n\n\n  _serviceMap: {}\n});\n\nmodule.exports = AWS.Service;\n},{"./core":10,"./model/api":22,"./region_config":36}],42:[function(require,module,exports){\nvar AWS = require(\'../core\');\n\nAWS.util.update(AWS.CognitoIdentity.prototype, {\n  getOpenIdToken: function getOpenIdToken(params, callback) {\n    return this.makeUnauthenticatedRequest(\'getOpenIdToken\', params, callback);\n  },\n\n  getId: function getId(params, callback) {\n    return this.makeUnauthenticatedRequest(\'getId\', params, callback);\n  },\n\n  getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {\n    return this.makeUnauthenticatedRequest(\'getCredentialsForIdentity\', params, callback);\n  }\n});\n\n},{"../core":10}],43:[function(require,module,exports){\nvar AWS = require(\'../core\');\n\nAWS.util.update(AWS.STS.prototype, {\n\n  credentialsFrom: function credentialsFrom(data, credentials) {\n    if (!data) return null;\n    if (!credentials) credentials = new AWS.TemporaryCredentials();\n    credentials.expired = false;\n    credentials.accessKeyId = data.Credentials.AccessKeyId;\n    credentials.secretAccessKey = data.Credentials.SecretAccessKey;\n    credentials.sessionToken = data.Credentials.SessionToken;\n    credentials.expireTime = data.Credentials.Expiration;\n    return credentials;\n  },\n\n  assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {\n    return this.makeUnauthenticatedRequest(\'assumeRoleWithWebIdentity\', params, callback);\n  },\n\n  assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {\n    return this.makeUnauthenticatedRequest(\'assumeRoleWithSAML\', params, callback);\n  }\n});\n\n},{"../core":10}],44:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar inherit = AWS.util.inherit;\n\n\nvar expiresHeader = \'presigned-expires\';\n\n\nfunction signedUrlBuilder(request) {\n  var expires = request.httpRequest.headers[expiresHeader];\n  var signerClass = request.service.getSignerClass(request);\n\n  delete request.httpRequest.headers[\'User-Agent\'];\n  delete request.httpRequest.headers[\'X-Amz-User-Agent\'];\n\n  if (signerClass === AWS.Signers.V4) {\n    if (expires > 604800) { // one week expiry is invalid\n      var message = \'Presigning does not support expiry time greater \' +\n                    \'than a week with SigV4 signing.\';\n      throw AWS.util.error(new Error(), {\n        code: \'InvalidExpiryTime\', message: message, retryable: false\n      });\n    }\n    request.httpRequest.headers[expiresHeader] = expires;\n  } else if (signerClass === AWS.Signers.S3) {\n    request.httpRequest.headers[expiresHeader] = parseInt(\n      AWS.util.date.unixTimestamp() + expires, 10).toString();\n  } else {\n    throw AWS.util.error(new Error(), {\n      message: \'Presigning only supports S3 or SigV4 signing.\',\n      code: \'UnsupportedSigner\', retryable: false\n    });\n  }\n}\n\n\nfunction signedUrlSigner(request) {\n  var endpoint = request.httpRequest.endpoint;\n  var parsedUrl = AWS.util.urlParse(request.httpRequest.path);\n  var queryParams = {};\n\n  if (parsedUrl.search) {\n    queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));\n  }\n\n  AWS.util.each(request.httpRequest.headers, function (key, value) {\n    if (key === expiresHeader) key = \'Expires\';\n    if (key.indexOf(\'x-amz-meta-\') === 0) {\n      delete queryParams[key];\n      key = key.toLowerCase();\n    }\n    queryParams[key] = value;\n  });\n  delete request.httpRequest.headers[expiresHeader];\n\n  var auth = queryParams[\'Authorization\'].split(\' \');\n  if (auth[0] === \'AWS\') {\n    auth = auth[1].split(\':\');\n    queryParams[\'AWSAccessKeyId\'] = auth[0];\n    queryParams[\'Signature\'] = auth[1];\n  } else if (auth[0] === \'AWS4-HMAC-SHA256\') { // SigV4 signing\n    auth.shift();\n    var rest = auth.join(\' \');\n    var signature = rest.match(/Signature=(.*?)(?:,|\\s|\\r?\\n|$)/)[1];\n    queryParams[\'X-Amz-Signature\'] = signature;\n    delete queryParams[\'Expires\'];\n  }\n  delete queryParams[\'Authorization\'];\n  delete queryParams[\'Host\'];\n\n  endpoint.pathname = parsedUrl.pathname;\n  endpoint.search = AWS.util.queryParamsToString(queryParams);\n}\n\n\nAWS.Signers.Presign = inherit({\n\n  sign: function sign(request, expireTime, callback) {\n    request.httpRequest.headers[expiresHeader] = expireTime || 3600;\n    request.on(\'build\', signedUrlBuilder);\n    request.on(\'sign\', signedUrlSigner);\n    request.removeListener(\'afterBuild\',\n      AWS.EventListeners.Core.SET_CONTENT_LENGTH);\n    request.removeListener(\'afterBuild\',\n      AWS.EventListeners.Core.COMPUTE_SHA256);\n\n    request.emit(\'beforePresign\', [request]);\n\n    if (callback) {\n      request.build(function() {\n        if (this.response.error) callback(this.response.error);\n        else {\n          callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));\n        }\n      });\n    } else {\n      request.build();\n      if (request.response.error) throw request.response.error;\n      return AWS.util.urlFormat(request.httpRequest.endpoint);\n    }\n  }\n});\n\nmodule.exports = AWS.Signers.Presign;\n\n},{"../core":10}],45:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar inherit = AWS.util.inherit;\n\n\nAWS.Signers.RequestSigner = inherit({\n  constructor: function RequestSigner(request) {\n    this.request = request;\n  },\n\n  setServiceClientId: function setServiceClientId(id) {\n    this.serviceClientId = id;\n  },\n\n  getServiceClientId: function getServiceClientId() {\n    return this.serviceClientId;\n  }\n});\n\nAWS.Signers.RequestSigner.getVersion = function getVersion(version) {\n  switch (version) {\n    case \'v2\': return AWS.Signers.V2;\n    case \'v3\': return AWS.Signers.V3;\n    case \'v4\': return AWS.Signers.V4;\n    case \'s3\': return AWS.Signers.S3;\n    case \'v3https\': return AWS.Signers.V3Https;\n  }\n  throw new Error(\'Unknown signing version \' + version);\n};\n\nrequire(\'./v2\');\nrequire(\'./v3\');\nrequire(\'./v3https\');\nrequire(\'./v4\');\nrequire(\'./s3\');\nrequire(\'./presign\');\n\n},{"../core":10,"./presign":44,"./s3":46,"./v2":47,"./v3":48,"./v3https":49,"./v4":50}],46:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar inherit = AWS.util.inherit;\n\n\nAWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {\n\n  subResources: {\n    \'acl\': 1,\n    \'accelerate\': 1,\n    \'cors\': 1,\n    \'lifecycle\': 1,\n    \'delete\': 1,\n    \'location\': 1,\n    \'logging\': 1,\n    \'notification\': 1,\n    \'partNumber\': 1,\n    \'policy\': 1,\n    \'requestPayment\': 1,\n    \'replication\': 1,\n    \'restore\': 1,\n    \'tagging\': 1,\n    \'torrent\': 1,\n    \'uploadId\': 1,\n    \'uploads\': 1,\n    \'versionId\': 1,\n    \'versioning\': 1,\n    \'versions\': 1,\n    \'website\': 1\n  },\n\n  responseHeaders: {\n    \'response-content-type\': 1,\n    \'response-content-language\': 1,\n    \'response-expires\': 1,\n    \'response-cache-control\': 1,\n    \'response-content-disposition\': 1,\n    \'response-content-encoding\': 1\n  },\n\n  addAuthorization: function addAuthorization(credentials, date) {\n    if (!this.request.headers[\'presigned-expires\']) {\n      this.request.headers[\'X-Amz-Date\'] = AWS.util.date.rfc822(date);\n    }\n\n    if (credentials.sessionToken) {\n      this.request.headers[\'x-amz-security-token\'] = credentials.sessionToken;\n    }\n\n    var signature = this.sign(credentials.secretAccessKey, this.stringToSign());\n    var auth = \'AWS \' + credentials.accessKeyId + \':\' + signature;\n\n    this.request.headers[\'Authorization\'] = auth;\n  },\n\n  stringToSign: function stringToSign() {\n    var r = this.request;\n\n    var parts = [];\n    parts.push(r.method);\n    parts.push(r.headers[\'Content-MD5\'] || \'\');\n    parts.push(r.headers[\'Content-Type\'] || \'\');\n\n    parts.push(r.headers[\'presigned-expires\'] || \'\');\n\n    var headers = this.canonicalizedAmzHeaders();\n    if (headers) parts.push(headers);\n    parts.push(this.canonicalizedResource());\n\n    return parts.join(\'\\n\');\n\n  },\n\n  canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {\n\n    var amzHeaders = [];\n\n    AWS.util.each(this.request.headers, function (name) {\n      if (name.match(/^x-amz-/i))\n        amzHeaders.push(name);\n    });\n\n    amzHeaders.sort(function (a, b) {\n      return a.toLowerCase() < b.toLowerCase() ? -1 : 1;\n    });\n\n    var parts = [];\n    AWS.util.arrayEach.call(this, amzHeaders, function (name) {\n      parts.push(name.toLowerCase() + \':\' + String(this.request.headers[name]));\n    });\n\n    return parts.join(\'\\n\');\n\n  },\n\n  canonicalizedResource: function canonicalizedResource() {\n\n    var r = this.request;\n\n    var parts = r.path.split(\'?\');\n    var path = parts[0];\n    var querystring = parts[1];\n\n    var resource = \'\';\n\n    if (r.virtualHostedBucket)\n      resource += \'/\' + r.virtualHostedBucket;\n\n    resource += path;\n\n    if (querystring) {\n\n      var resources = [];\n\n      AWS.util.arrayEach.call(this, querystring.split(\'&\'), function (param) {\n        var name = param.split(\'=\')[0];\n        var value = param.split(\'=\')[1];\n        if (this.subResources[name] || this.responseHeaders[name]) {\n          var subresource = { name: name };\n          if (value !== undefined) {\n            if (this.subResources[name]) {\n              subresource.value = value;\n            } else {\n              subresource.value = decodeURIComponent(value);\n            }\n          }\n          resources.push(subresource);\n        }\n      });\n\n      resources.sort(function (a, b) { return a.name < b.name ? -1 : 1; });\n\n      if (resources.length) {\n\n        querystring = [];\n        AWS.util.arrayEach(resources, function (res) {\n          if (res.value === undefined) {\n            querystring.push(res.name);\n          } else {\n            querystring.push(res.name + \'=\' + res.value);\n          }\n        });\n\n        resource += \'?\' + querystring.join(\'&\');\n      }\n\n    }\n\n    return resource;\n\n  },\n\n  sign: function sign(secret, string) {\n    return AWS.util.crypto.hmac(secret, string, \'base64\', \'sha1\');\n  }\n});\n\nmodule.exports = AWS.Signers.S3;\n\n},{"../core":10}],47:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar inherit = AWS.util.inherit;\n\n\nAWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {\n  addAuthorization: function addAuthorization(credentials, date) {\n\n    if (!date) date = AWS.util.date.getDate();\n\n    var r = this.request;\n\n    r.params.Timestamp = AWS.util.date.iso8601(date);\n    r.params.SignatureVersion = \'2\';\n    r.params.SignatureMethod = \'HmacSHA256\';\n    r.params.AWSAccessKeyId = credentials.accessKeyId;\n\n    if (credentials.sessionToken) {\n      r.params.SecurityToken = credentials.sessionToken;\n    }\n\n    delete r.params.Signature; // delete old Signature for re-signing\n    r.params.Signature = this.signature(credentials);\n\n    r.body = AWS.util.queryParamsToString(r.params);\n    r.headers[\'Content-Length\'] = r.body.length;\n  },\n\n  signature: function signature(credentials) {\n    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), \'base64\');\n  },\n\n  stringToSign: function stringToSign() {\n    var parts = [];\n    parts.push(this.request.method);\n    parts.push(this.request.endpoint.host.toLowerCase());\n    parts.push(this.request.pathname());\n    parts.push(AWS.util.queryParamsToString(this.request.params));\n    return parts.join(\'\\n\');\n  }\n\n});\n\nmodule.exports = AWS.Signers.V2;\n\n},{"../core":10}],48:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar inherit = AWS.util.inherit;\n\n\nAWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {\n  addAuthorization: function addAuthorization(credentials, date) {\n\n    var datetime = AWS.util.date.rfc822(date);\n\n    this.request.headers[\'X-Amz-Date\'] = datetime;\n\n    if (credentials.sessionToken) {\n      this.request.headers[\'x-amz-security-token\'] = credentials.sessionToken;\n    }\n\n    this.request.headers[\'X-Amzn-Authorization\'] =\n      this.authorization(credentials, datetime);\n\n  },\n\n  authorization: function authorization(credentials) {\n    return \'AWS3 \' +\n      \'AWSAccessKeyId=\' + credentials.accessKeyId + \',\' +\n      \'Algorithm=HmacSHA256,\' +\n      \'SignedHeaders=\' + this.signedHeaders() + \',\' +\n      \'Signature=\' + this.signature(credentials);\n  },\n\n  signedHeaders: function signedHeaders() {\n    var headers = [];\n    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {\n      headers.push(h.toLowerCase());\n    });\n    return headers.sort().join(\';\');\n  },\n\n  canonicalHeaders: function canonicalHeaders() {\n    var headers = this.request.headers;\n    var parts = [];\n    AWS.util.arrayEach(this.headersToSign(), function iterator(h) {\n      parts.push(h.toLowerCase().trim() + \':\' + String(headers[h]).trim());\n    });\n    return parts.sort().join(\'\\n\') + \'\\n\';\n  },\n\n  headersToSign: function headersToSign() {\n    var headers = [];\n    AWS.util.each(this.request.headers, function iterator(k) {\n      if (k === \'Host\' || k === \'Content-Encoding\' || k.match(/^X-Amz/i)) {\n        headers.push(k);\n      }\n    });\n    return headers;\n  },\n\n  signature: function signature(credentials) {\n    return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), \'base64\');\n  },\n\n  stringToSign: function stringToSign() {\n    var parts = [];\n    parts.push(this.request.method);\n    parts.push(\'/\');\n    parts.push(\'\');\n    parts.push(this.canonicalHeaders());\n    parts.push(this.request.body);\n    return AWS.util.crypto.sha256(parts.join(\'\\n\'));\n  }\n\n});\n\nmodule.exports = AWS.Signers.V3;\n\n},{"../core":10}],49:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar inherit = AWS.util.inherit;\n\nrequire(\'./v3\');\n\n\nAWS.Signers.V3Https = inherit(AWS.Signers.V3, {\n  authorization: function authorization(credentials) {\n    return \'AWS3-HTTPS \' +\n      \'AWSAccessKeyId=\' + credentials.accessKeyId + \',\' +\n      \'Algorithm=HmacSHA256,\' +\n      \'Signature=\' + this.signature(credentials);\n  },\n\n  stringToSign: function stringToSign() {\n    return this.request.headers[\'X-Amz-Date\'];\n  }\n});\n\nmodule.exports = AWS.Signers.V3Https;\n\n},{"../core":10,"./v3":48}],50:[function(require,module,exports){\nvar AWS = require(\'../core\');\nvar inherit = AWS.util.inherit;\n\n\nvar cachedSecret = {};\n\n\nvar cacheQueue = [];\n\n\nvar maxCacheEntries = 50;\n\n\nvar expiresHeader = \'presigned-expires\';\n\n\nAWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {\n  constructor: function V4(request, serviceName, signatureCache) {\n    AWS.Signers.RequestSigner.call(this, request);\n    this.serviceName = serviceName;\n    this.signatureCache = signatureCache;\n  },\n\n  algorithm: \'AWS4-HMAC-SHA256\',\n\n  addAuthorization: function addAuthorization(credentials, date) {\n    var datetime = AWS.util.date.iso8601(date).replace(/[:\\-]|\\.\\d{3}/g, \'\');\n\n    if (this.isPresigned()) {\n      this.updateForPresigned(credentials, datetime);\n    } else {\n      this.addHeaders(credentials, datetime);\n    }\n\n    this.request.headers[\'Authorization\'] =\n      this.authorization(credentials, datetime);\n  },\n\n  addHeaders: function addHeaders(credentials, datetime) {\n    this.request.headers[\'X-Amz-Date\'] = datetime;\n    if (credentials.sessionToken) {\n      this.request.headers[\'x-amz-security-token\'] = credentials.sessionToken;\n    }\n  },\n\n  updateForPresigned: function updateForPresigned(credentials, datetime) {\n    var credString = this.credentialString(datetime);\n    var qs = {\n      \'X-Amz-Date\': datetime,\n      \'X-Amz-Algorithm\': this.algorithm,\n      \'X-Amz-Credential\': credentials.accessKeyId + \'/\' + credString,\n      \'X-Amz-Expires\': this.request.headers[expiresHeader],\n      \'X-Amz-SignedHeaders\': this.signedHeaders()\n    };\n\n    if (credentials.sessionToken) {\n      qs[\'X-Amz-Security-Token\'] = credentials.sessionToken;\n    }\n\n    if (this.request.headers[\'Content-Type\']) {\n      qs[\'Content-Type\'] = this.request.headers[\'Content-Type\'];\n    }\n    if (this.request.headers[\'Content-MD5\']) {\n      qs[\'Content-MD5\'] = this.request.headers[\'Content-MD5\'];\n    }\n    if (this.request.headers[\'Cache-Control\']) {\n      qs[\'Cache-Control\'] = this.request.headers[\'Cache-Control\'];\n    }\n\n    AWS.util.each.call(this, this.request.headers, function(key, value) {\n      if (key === expiresHeader) return;\n      if (this.isSignableHeader(key)) {\n        var lowerKey = key.toLowerCase();\n        if (lowerKey.indexOf(\'x-amz-meta-\') === 0) {\n          qs[lowerKey] = value;\n        } else if (lowerKey.indexOf(\'x-amz-\') === 0) {\n          qs[key] = value;\n        }\n      }\n    });\n\n    var sep = this.request.path.indexOf(\'?\') >= 0 ? \'&\' : \'?\';\n    this.request.path += sep + AWS.util.queryParamsToString(qs);\n  },\n\n  authorization: function authorization(credentials, datetime) {\n    var parts = [];\n    var credString = this.credentialString(datetime);\n    parts.push(this.algorithm + \' Credential=\' +\n      credentials.accessKeyId + \'/\' + credString);\n    parts.push(\'SignedHeaders=\' + this.signedHeaders());\n    parts.push(\'Signature=\' + this.signature(credentials, datetime));\n    return parts.join(\', \');\n  },\n\n  signature: function signature(credentials, datetime) {\n    var cache = null;\n    var cacheIdentifier = this.serviceName + (this.getServiceClientId() ? \'_\' + this.getServiceClientId() : \'\');\n    if (this.signatureCache) {\n      var cache = cachedSecret[cacheIdentifier];\n      if (!cache) {\n        cacheQueue.push(cacheIdentifier);\n        if (cacheQueue.length > maxCacheEntries) {\n          delete cachedSecret[cacheQueue.shift()];\n        }\n      }\n\n    }\n    var date = datetime.substr(0, 8);\n\n    if (!cache ||\n        cache.akid !== credentials.accessKeyId ||\n        cache.region !== this.request.region ||\n        cache.date !== date) {\n\n      var kSecret = credentials.secretAccessKey;\n      var kDate = AWS.util.crypto.hmac(\'AWS4\' + kSecret, date, \'buffer\');\n      var kRegion = AWS.util.crypto.hmac(kDate, this.request.region, \'buffer\');\n      var kService = AWS.util.crypto.hmac(kRegion, this.serviceName, \'buffer\');\n      var kCredentials = AWS.util.crypto.hmac(kService, \'aws4_request\', \'buffer\');\n\n      if (!this.signatureCache) {\n        return AWS.util.crypto.hmac(kCredentials, this.stringToSign(datetime), \'hex\');\n      }\n\n      cachedSecret[cacheIdentifier] = {\n        region: this.request.region, date: date,\n        key: kCredentials, akid: credentials.accessKeyId\n      };\n    }\n\n    var key = cachedSecret[cacheIdentifier].key;\n    return AWS.util.crypto.hmac(key, this.stringToSign(datetime), \'hex\');\n  },\n\n  stringToSign: function stringToSign(datetime) {\n    var parts = [];\n    parts.push(\'AWS4-HMAC-SHA256\');\n    parts.push(datetime);\n    parts.push(this.credentialString(datetime));\n    parts.push(this.hexEncodedHash(this.canonicalString()));\n    return parts.join(\'\\n\');\n  },\n\n  canonicalString: function canonicalString() {\n    var parts = [], pathname = this.request.pathname();\n    if (this.serviceName !== \'s3\') pathname = AWS.util.uriEscapePath(pathname);\n\n    parts.push(this.request.method);\n    parts.push(pathname);\n    parts.push(this.request.search());\n    parts.push(this.canonicalHeaders() + \'\\n\');\n    parts.push(this.signedHeaders());\n    parts.push(this.hexEncodedBodyHash());\n    return parts.join(\'\\n\');\n  },\n\n  canonicalHeaders: function canonicalHeaders() {\n    var headers = [];\n    AWS.util.each.call(this, this.request.headers, function (key, item) {\n      headers.push([key, item]);\n    });\n    headers.sort(function (a, b) {\n      return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;\n    });\n    var parts = [];\n    AWS.util.arrayEach.call(this, headers, function (item) {\n      var key = item[0].toLowerCase();\n      if (this.isSignableHeader(key)) {\n        parts.push(key + \':\' +\n          this.canonicalHeaderValues(item[1].toString()));\n      }\n    });\n    return parts.join(\'\\n\');\n  },\n\n  canonicalHeaderValues: function canonicalHeaderValues(values) {\n    return values.replace(/\\s+/g, \' \').replace(/^\\s+|\\s+$/g, \'\');\n  },\n\n  signedHeaders: function signedHeaders() {\n    var keys = [];\n    AWS.util.each.call(this, this.request.headers, function (key) {\n      key = key.toLowerCase();\n      if (this.isSignableHeader(key)) keys.push(key);\n    });\n    return keys.sort().join(\';\');\n  },\n\n  credentialString: function credentialString(datetime) {\n    var parts = [];\n    parts.push(datetime.substr(0, 8));\n    parts.push(this.request.region);\n    parts.push(this.serviceName);\n    parts.push(\'aws4_request\');\n    return parts.join(\'/\');\n  },\n\n  hexEncodedHash: function hash(string) {\n    return AWS.util.crypto.sha256(string, \'hex\');\n  },\n\n  hexEncodedBodyHash: function hexEncodedBodyHash() {\n    if (this.isPresigned() && this.serviceName === \'s3\' && !this.request.body) {\n      return \'UNSIGNED-PAYLOAD\';\n    } else if (this.request.headers[\'X-Amz-Content-Sha256\']) {\n      return this.request.headers[\'X-Amz-Content-Sha256\'];\n    } else {\n      return this.hexEncodedHash(this.request.body || \'\');\n    }\n  },\n\n  unsignableHeaders: [\'authorization\', \'content-type\', \'content-length\',\n                      \'user-agent\', expiresHeader, \'expect\'],\n\n  isSignableHeader: function isSignableHeader(key) {\n    if (key.toLowerCase().indexOf(\'x-amz-\') === 0) return true;\n    return this.unsignableHeaders.indexOf(key) < 0;\n  },\n\n  isPresigned: function isPresigned() {\n    return this.request.headers[expiresHeader] ? true : false;\n  }\n\n});\n\nmodule.exports = AWS.Signers.V4;\n\n},{"../core":10}],51:[function(require,module,exports){\nfunction AcceptorStateMachine(states, state) {\n  this.currentState = state || null;\n  this.states = states || {};\n}\n\nAcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {\n  if (typeof finalState === \'function\') {\n    inputError = bindObject; bindObject = done;\n    done = finalState; finalState = null;\n  }\n\n  var self = this;\n  var state = self.states[self.currentState];\n  state.fn.call(bindObject || self, inputError, function(err) {\n    if (err) {\n      if (state.fail) self.currentState = state.fail;\n      else return done ? done.call(bindObject, err) : null;\n    } else {\n      if (state.accept) self.currentState = state.accept;\n      else return done ? done.call(bindObject) : null;\n    }\n    if (self.currentState === finalState) {\n      return done ? done.call(bindObject, err) : null;\n    }\n\n    self.runTo(finalState, done, bindObject, err);\n  });\n};\n\nAcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {\n  if (typeof acceptState === \'function\') {\n    fn = acceptState; acceptState = null; failState = null;\n  } else if (typeof failState === \'function\') {\n    fn = failState; failState = null;\n  }\n\n  if (!this.currentState) this.currentState = name;\n  this.states[name] = { accept: acceptState, fail: failState, fn: fn };\n  return this;\n};\n\nmodule.exports = AcceptorStateMachine;\n\n},{}],52:[function(require,module,exports){\n(function (process){\n\nvar AWS;\n\n\nvar util = {\n  engine: function engine() {\n    if (util.isBrowser() && typeof navigator !== \'undefined\') {\n      return navigator.userAgent;\n    } else {\n      return process.platform + \'/\' + process.version;\n    }\n  },\n\n  userAgent: function userAgent() {\n    var name = util.isBrowser() ? \'js\' : \'nodejs\';\n    var agent = \'aws-sdk-\' + name + \'/\' + require(\'./core\').VERSION;\n    if (name === \'nodejs\') agent += \' \' + util.engine();\n    return agent;\n  },\n\n  isBrowser: function isBrowser() { return process && process.browser; },\n  isNode: function isNode() { return !util.isBrowser(); },\n  uriEscape: function uriEscape(string) {\n    var output = encodeURIComponent(string);\n    output = output.replace(/[^A-Za-z0-9_.~\\-%]+/g, escape);\n\n    output = output.replace(/[*]/g, function(ch) {\n      return \'%\' + ch.charCodeAt(0).toString(16).toUpperCase();\n    });\n\n    return output;\n  },\n\n  uriEscapePath: function uriEscapePath(string) {\n    var parts = [];\n    util.arrayEach(string.split(\'/\'), function (part) {\n      parts.push(util.uriEscape(part));\n    });\n    return parts.join(\'/\');\n  },\n\n  urlParse: function urlParse(url) {\n    return util.url.parse(url);\n  },\n\n  urlFormat: function urlFormat(url) {\n    return util.url.format(url);\n  },\n\n  queryStringParse: function queryStringParse(qs) {\n    return util.querystring.parse(qs);\n  },\n\n  queryParamsToString: function queryParamsToString(params) {\n    var items = [];\n    var escape = util.uriEscape;\n    var sortedKeys = Object.keys(params).sort();\n\n    util.arrayEach(sortedKeys, function(name) {\n      var value = params[name];\n      var ename = escape(name);\n      var result = ename + \'=\';\n      if (Array.isArray(value)) {\n        var vals = [];\n        util.arrayEach(value, function(item) { vals.push(escape(item)); });\n        result = ename + \'=\' + vals.sort().join(\'&\' + ename + \'=\');\n      } else if (value !== undefined && value !== null) {\n        result = ename + \'=\' + escape(value);\n      }\n      items.push(result);\n    });\n\n    return items.join(\'&\');\n  },\n\n  readFileSync: function readFileSync(path) {\n    if (util.isBrowser()) return null;\n    return require(\'fs\').readFileSync(path, \'utf-8\');\n  },\n\n  base64: {\n\n    encode: function encode64(string) {\n      return new util.Buffer(string).toString(\'base64\');\n    },\n\n    decode: function decode64(string) {\n      return new util.Buffer(string, \'base64\');\n    }\n\n  },\n\n  buffer: {\n    toStream: function toStream(buffer) {\n      if (!util.Buffer.isBuffer(buffer)) buffer = new util.Buffer(buffer);\n\n      var readable = new (util.stream.Readable)();\n      var pos = 0;\n      readable._read = function(size) {\n        if (pos >= buffer.length) return readable.push(null);\n\n        var end = pos + size;\n        if (end > buffer.length) end = buffer.length;\n        readable.push(buffer.slice(pos, end));\n        pos = end;\n      };\n\n      return readable;\n    },\n\n\n    concat: function(buffers) {\n      var length = 0,\n          offset = 0,\n          buffer = null, i;\n\n      for (i = 0; i < buffers.length; i++) {\n        length += buffers[i].length;\n      }\n\n      buffer = new util.Buffer(length);\n\n      for (i = 0; i < buffers.length; i++) {\n        buffers[i].copy(buffer, offset);\n        offset += buffers[i].length;\n      }\n\n      return buffer;\n    }\n  },\n\n  string: {\n    byteLength: function byteLength(string) {\n      if (string === null || string === undefined) return 0;\n      if (typeof string === \'string\') string = new util.Buffer(string);\n\n      if (typeof string.byteLength === \'number\') {\n        return string.byteLength;\n      } else if (typeof string.length === \'number\') {\n        return string.length;\n      } else if (typeof string.size === \'number\') {\n        return string.size;\n      } else if (typeof string.path === \'string\') {\n        return require(\'fs\').lstatSync(string.path).size;\n      } else {\n        throw util.error(new Error(\'Cannot determine length of \' + string),\n          { object: string });\n      }\n    },\n\n    upperFirst: function upperFirst(string) {\n      return string[0].toUpperCase() + string.substr(1);\n    },\n\n    lowerFirst: function lowerFirst(string) {\n      return string[0].toLowerCase() + string.substr(1);\n    }\n  },\n\n  ini: {\n    parse: function string(ini) {\n      var currentSection, map = {};\n      util.arrayEach(ini.split(/\\r?\\n/), function(line) {\n        line = line.split(/(^|\\s)[;#]/)[0]; // remove comments\n        var section = line.match(/^\\s*\\[([^\\[\\]]+)\\]\\s*$/);\n        if (section) {\n          currentSection = section[1];\n        } else if (currentSection) {\n          var item = line.match(/^\\s*(.+?)\\s*=\\s*(.+?)\\s*$/);\n          if (item) {\n            map[currentSection] = map[currentSection] || {};\n            map[currentSection][item[1]] = item[2];\n          }\n        }\n      });\n\n      return map;\n    }\n  },\n\n  fn: {\n    noop: function() {},\n\n\n    makeAsync: function makeAsync(fn, expectedArgs) {\n      if (expectedArgs && expectedArgs <= fn.length) {\n        return fn;\n      }\n\n      return function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        var callback = args.pop();\n        var result = fn.apply(null, args);\n        callback(result);\n      };\n    }\n  },\n\n\n  date: {\n\n\n    getDate: function getDate() {\n      if (!AWS) AWS = require(\'./core\');\n      if (AWS.config.systemClockOffset) { // use offset when non-zero\n        return new Date(new Date().getTime() + AWS.config.systemClockOffset);\n      } else {\n        return new Date();\n      }\n    },\n\n\n    iso8601: function iso8601(date) {\n      if (date === undefined) { date = util.date.getDate(); }\n      return date.toISOString().replace(/\\.\\d{3}Z$/, \'Z\');\n    },\n\n\n    rfc822: function rfc822(date) {\n      if (date === undefined) { date = util.date.getDate(); }\n      return date.toUTCString();\n    },\n\n\n    unixTimestamp: function unixTimestamp(date) {\n      if (date === undefined) { date = util.date.getDate(); }\n      return date.getTime() / 1000;\n    },\n\n\n    from: function format(date) {\n      if (typeof date === \'number\') {\n        return new Date(date * 1000); // unix timestamp\n      } else {\n        return new Date(date);\n      }\n    },\n\n\n    format: function format(date, formatter) {\n      if (!formatter) formatter = \'iso8601\';\n      return util.date[formatter](util.date.from(date));\n    },\n\n    parseTimestamp: function parseTimestamp(value) {\n      if (typeof value === \'number\') { // unix timestamp (number)\n        return new Date(value * 1000);\n      } else if (value.match(/^\\d+$/)) { // unix timestamp\n        return new Date(value * 1000);\n      } else if (value.match(/^\\d{4}/)) { // iso8601\n        return new Date(value);\n      } else if (value.match(/^\\w{3},/)) { // rfc822\n        return new Date(value);\n      } else {\n        throw util.error(\n          new Error(\'unhandled timestamp format: \' + value),\n          {code: \'TimestampParserError\'});\n      }\n    }\n\n  },\n\n  crypto: {\n    crc32Table: [\n     0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,\n     0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,\n     0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,\n     0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,\n     0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,\n     0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,\n     0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,\n     0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,\n     0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,\n     0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,\n     0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,\n     0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,\n     0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,\n     0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,\n     0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,\n     0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,\n     0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,\n     0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,\n     0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,\n     0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,\n     0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,\n     0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,\n     0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,\n     0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,\n     0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,\n     0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,\n     0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,\n     0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,\n     0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,\n     0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,\n     0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,\n     0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,\n     0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,\n     0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,\n     0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,\n     0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,\n     0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,\n     0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,\n     0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,\n     0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,\n     0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,\n     0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,\n     0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,\n     0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,\n     0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,\n     0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,\n     0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,\n     0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,\n     0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,\n     0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,\n     0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,\n     0x2D02EF8D],\n\n    crc32: function crc32(data) {\n      var tbl = util.crypto.crc32Table;\n      var crc = 0 ^ -1;\n\n      if (typeof data === \'string\') {\n        data = new util.Buffer(data);\n      }\n\n      for (var i = 0; i < data.length; i++) {\n        var code = data.readUInt8(i);\n        crc = (crc >>> 8) ^ tbl[(crc ^ code) & 0xFF];\n      }\n      return (crc ^ -1) >>> 0;\n    },\n\n    hmac: function hmac(key, string, digest, fn) {\n      if (!digest) digest = \'binary\';\n      if (digest === \'buffer\') { digest = undefined; }\n      if (!fn) fn = \'sha256\';\n      if (typeof string === \'string\') string = new util.Buffer(string);\n      return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);\n    },\n\n    md5: function md5(data, digest, callback) {\n      return util.crypto.hash(\'md5\', data, digest, callback);\n    },\n\n    sha256: function sha256(data, digest, callback) {\n      return util.crypto.hash(\'sha256\', data, digest, callback);\n    },\n\n    hash: function(algorithm, data, digest, callback) {\n      var hash = util.crypto.createHash(algorithm);\n      if (!digest) { digest = \'binary\'; }\n      if (digest === \'buffer\') { digest = undefined; }\n      if (typeof data === \'string\') data = new util.Buffer(data);\n      var sliceFn = util.arraySliceFn(data);\n      var isBuffer = util.Buffer.isBuffer(data);\n      if (util.isBrowser() && typeof ArrayBuffer !== \'undefined\' && data && data.buffer instanceof ArrayBuffer) isBuffer = true;\n\n      if (callback && typeof data === \'object\' &&\n          typeof data.on === \'function\' && !isBuffer) {\n        data.on(\'data\', function(chunk) { hash.update(chunk); });\n        data.on(\'error\', function(err) { callback(err); });\n        data.on(\'end\', function() { callback(null, hash.digest(digest)); });\n      } else if (callback && sliceFn && !isBuffer &&\n                 typeof FileReader !== \'undefined\') {\n        var index = 0, size = 1024 * 512;\n        var reader = new FileReader();\n        reader.onerror = function() {\n          callback(new Error(\'Failed to read data.\'));\n        };\n        reader.onload = function() {\n          var buf = new util.Buffer(new Uint8Array(reader.result));\n          hash.update(buf);\n          index += buf.length;\n          reader._continueReading();\n        };\n        reader._continueReading = function() {\n          if (index >= data.size) {\n            callback(null, hash.digest(digest));\n            return;\n          }\n\n          var back = index + size;\n          if (back > data.size) back = data.size;\n          reader.readAsArrayBuffer(sliceFn.call(data, index, back));\n        };\n\n        reader._continueReading();\n      } else {\n        if (util.isBrowser() && typeof data === \'object\' && !isBuffer) {\n          data = new util.Buffer(new Uint8Array(data));\n        }\n        var out = hash.update(data).digest(digest);\n        if (callback) callback(null, out);\n        return out;\n      }\n    },\n\n    toHex: function toHex(data) {\n      var out = [];\n      for (var i = 0; i < data.length; i++) {\n        out.push((\'0\' + data.charCodeAt(i).toString(16)).substr(-2, 2));\n      }\n      return out.join(\'\');\n    },\n\n    createHash: function createHash(algorithm) {\n      return util.crypto.lib.createHash(algorithm);\n    }\n\n  },\n\n\n\n\n  abort: {},\n\n  each: function each(object, iterFunction) {\n    for (var key in object) {\n      if (Object.prototype.hasOwnProperty.call(object, key)) {\n        var ret = iterFunction.call(this, key, object[key]);\n        if (ret === util.abort) break;\n      }\n    }\n  },\n\n  arrayEach: function arrayEach(array, iterFunction) {\n    for (var idx in array) {\n      if (Object.prototype.hasOwnProperty.call(array, idx)) {\n        var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));\n        if (ret === util.abort) break;\n      }\n    }\n  },\n\n  update: function update(obj1, obj2) {\n    util.each(obj2, function iterator(key, item) {\n      obj1[key] = item;\n    });\n    return obj1;\n  },\n\n  merge: function merge(obj1, obj2) {\n    return util.update(util.copy(obj1), obj2);\n  },\n\n  copy: function copy(object) {\n    if (object === null || object === undefined) return object;\n    var dupe = {};\n    for (var key in object) {\n      dupe[key] = object[key];\n    }\n    return dupe;\n  },\n\n  isEmpty: function isEmpty(obj) {\n    for (var prop in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n        return false;\n      }\n    }\n    return true;\n  },\n\n  arraySliceFn: function arraySliceFn(obj) {\n    var fn = obj.slice || obj.webkitSlice || obj.mozSlice;\n    return typeof fn === \'function\' ? fn : null;\n  },\n\n  isType: function isType(obj, type) {\n    if (typeof type === \'function\') type = util.typeName(type);\n    return Object.prototype.toString.call(obj) === \'[object \' + type + \']\';\n  },\n\n  typeName: function typeName(type) {\n    if (Object.prototype.hasOwnProperty.call(type, \'name\')) return type.name;\n    var str = type.toString();\n    var match = str.match(/^\\s*function (.+)\\(/);\n    return match ? match[1] : str;\n  },\n\n  error: function error(err, options) {\n    var originalError = null;\n    if (typeof err.message === \'string\' && err.message !== \'\') {\n      if (typeof options === \'string\' || (options && options.message)) {\n        originalError = util.copy(err);\n        originalError.message = err.message;\n      }\n    }\n    err.message = err.message || null;\n\n    if (typeof options === \'string\') {\n      err.message = options;\n    } else if (typeof options === \'object\' && options !== null) {\n      util.update(err, options);\n      if (options.message)\n        err.message = options.message;\n      if (options.code || options.name)\n        err.code = options.code || options.name;\n      if (options.stack)\n        err.stack = options.stack;\n    }\n\n    if (typeof Object.defineProperty === \'function\') {\n      Object.defineProperty(err, \'name\', {writable: true, enumerable: false});\n      Object.defineProperty(err, \'message\', {enumerable: true});\n    }\n\n    err.name = options && options.name || err.name || err.code || \'Error\';\n    err.time = new Date();\n\n    if (originalError) err.originalError = originalError;\n\n    return err;\n  },\n\n\n  inherit: function inherit(klass, features) {\n    var newObject = null;\n    if (features === undefined) {\n      features = klass;\n      klass = Object;\n      newObject = {};\n    } else {\n      var ctor = function ConstructorWrapper() {};\n      ctor.prototype = klass.prototype;\n      newObject = new ctor();\n    }\n\n    if (features.constructor === Object) {\n      features.constructor = function() {\n        if (klass !== Object) {\n          return klass.apply(this, arguments);\n        }\n      };\n    }\n\n    features.constructor.prototype = newObject;\n    util.update(features.constructor.prototype, features);\n    features.constructor.__super__ = klass;\n    return features.constructor;\n  },\n\n\n  mixin: function mixin() {\n    var klass = arguments[0];\n    for (var i = 1; i < arguments.length; i++) {\n      for (var prop in arguments[i].prototype) {\n        var fn = arguments[i].prototype[prop];\n        if (prop !== \'constructor\') {\n          klass.prototype[prop] = fn;\n        }\n      }\n    }\n    return klass;\n  },\n\n\n  hideProperties: function hideProperties(obj, props) {\n    if (typeof Object.defineProperty !== \'function\') return;\n\n    util.arrayEach(props, function (key) {\n      Object.defineProperty(obj, key, {\n        enumerable: false, writable: true, configurable: true });\n    });\n  },\n\n\n  property: function property(obj, name, value, enumerable, isValue) {\n    var opts = {\n      configurable: true,\n      enumerable: enumerable !== undefined ? enumerable : true\n    };\n    if (typeof value === \'function\' && !isValue) {\n      opts.get = value;\n    }\n    else {\n      opts.value = value; opts.writable = true;\n    }\n\n    Object.defineProperty(obj, name, opts);\n  },\n\n\n  memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {\n    var cachedValue = null;\n\n    util.property(obj, name, function() {\n      if (cachedValue === null) {\n        cachedValue = get();\n      }\n      return cachedValue;\n    }, enumerable);\n  },\n\n\n  hoistPayloadMember: function hoistPayloadMember(resp) {\n    var req = resp.request;\n    var operation = req.operation;\n    var output = req.service.api.operations[operation].output;\n    if (output.payload) {\n      var payloadMember = output.members[output.payload];\n      var responsePayload = resp.data[output.payload];\n      if (payloadMember.type === \'structure\') {\n        util.each(responsePayload, function(key, value) {\n          util.property(resp.data, key, value, false);\n        });\n      }\n    }\n  },\n\n\n  computeSha256: function computeSha256(body, done) {\n    if (util.isNode()) {\n      var Stream = util.stream.Stream;\n      var fs = require(\'fs\');\n      if (body instanceof Stream) {\n        if (typeof body.path === \'string\') { // assume file object\n          var settings = {};\n          if (typeof body.start === \'number\') {\n            settings.start = body.start;\n          }\n          if (typeof body.end === \'number\') {\n            settings.end = body.end;\n          }\n          body = fs.createReadStream(body.path, settings);\n        } else { // TODO support other stream types\n          return done(new Error(\'Non-file stream objects are \' +\n                                \'not supported with SigV4\'));\n        }\n      }\n    }\n\n    util.crypto.sha256(body, \'hex\', function(err, sha) {\n      if (err) done(err);\n      else done(null, sha);\n    });\n  },\n\n\n  isClockSkewed: function isClockSkewed(serverTime) {\n    if (serverTime) {\n      util.property(AWS.config, \'isClockSkewed\',\n        Math.abs(new Date().getTime() - serverTime) >= 300000, false);\n      return AWS.config.isClockSkewed;\n    }\n  },\n\n  applyClockOffset: function applyClockOffset(serverTime) {\n    if (serverTime)\n      AWS.config.systemClockOffset = serverTime - new Date().getTime();\n  },\n\n\n  extractRequestId: function extractRequestId(resp) {\n    var requestId = resp.httpResponse.headers[\'x-amz-request-id\'] ||\n                     resp.httpResponse.headers[\'x-amzn-requestid\'];\n\n    if (!requestId && resp.data && resp.data.ResponseMetadata) {\n      requestId = resp.data.ResponseMetadata.RequestId;\n    }\n\n    if (requestId) {\n      resp.requestId = requestId;\n    }\n\n    if (resp.error) {\n      resp.error.requestId = requestId;\n    }\n  },\n\n\n  addPromises: function addPromises(constructors, PromiseDependency) {\n    if (PromiseDependency === undefined && AWS && AWS.config) {\n      PromiseDependency = AWS.config.getPromisesDependency();\n    }\n    if (PromiseDependency === undefined && typeof Promise !== \'undefined\') {\n      PromiseDependency = Promise;\n    }\n    if (typeof PromiseDependency !== \'function\') var deletePromises = true;\n    if (!Array.isArray(constructors)) constructors = [constructors];\n\n    for (var ind = 0; ind < constructors.length; ind++) {\n      var constructor = constructors[ind];\n      if (deletePromises) {\n        if (constructor.deletePromisesFromClass) {\n          constructor.deletePromisesFromClass();\n        }\n      } else if (constructor.addPromisesToClass) {\n        constructor.addPromisesToClass(PromiseDependency);\n      }\n    }\n  },\n\n\n  promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {\n    return function promise() {\n      var self = this;\n      return new PromiseDependency(function(resolve, reject) {\n        self[methodName](function(err, data) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(data);\n          }\n        });\n      });\n    };\n  },\n\n\n  isDualstackAvailable: function isDualstackAvailable(service) {\n    if (!service) return false;\n    var metadata = require(\'../apis/metadata.json\');\n    if (typeof service !== \'string\') service = service.serviceIdentifier;\n    if (typeof service !== \'string\' || !metadata.hasOwnProperty(service)) return false;\n    return !!metadata[service].dualstackAvailable;\n  },\n\n\n  calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions) {\n    if (!retryDelayOptions) retryDelayOptions = {};\n    var customBackoff = retryDelayOptions.customBackoff || null;\n    if (typeof customBackoff === \'function\') {\n      return customBackoff(retryCount);\n    }\n    var base = retryDelayOptions.base || 100;\n    var delay = Math.random() * (Math.pow(2, retryCount) * base);\n    return delay;\n  },\n\n\n  handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {\n    if (!options) options = {};\n    var http = AWS.HttpClient.getInstance();\n    var httpOptions = options.httpOptions || {};\n    var retryCount = 0;\n\n    var errCallback = function(err) {\n      var maxRetries = options.maxRetries || 0;\n      if (err && err.code === \'TimeoutError\') err.retryable = true;\n      if (err && err.retryable && retryCount < maxRetries) {\n        retryCount++;\n        var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions);\n        setTimeout(sendRequest, delay + (err.retryAfter || 0));\n      } else {\n        cb(err);\n      }\n    };\n\n    var sendRequest = function() {\n      var data = \'\';\n      http.handleRequest(httpRequest, httpOptions, function(httpResponse) {\n        httpResponse.on(\'data\', function(chunk) { data += chunk.toString(); });\n        httpResponse.on(\'end\', function() {\n          var statusCode = httpResponse.statusCode;\n          if (statusCode < 300) {\n            cb(null, data);\n          } else {\n            var retryAfter = parseInt(httpResponse.headers[\'retry-after\'], 10) * 1000 || 0;\n            var err = util.error(new Error(),\n              { retryable: statusCode >= 500 || statusCode === 429 }\n            );\n            if (retryAfter && err.retryable) err.retryAfter = retryAfter;\n            errCallback(err);\n          }\n        });\n      }, errCallback);\n    };\n\n    process.nextTick(sendRequest);\n  }\n\n};\n\nmodule.exports = util;\n\n}).call(this,require(\'_process\'))\n},{"../apis/metadata.json":3,"./core":10,"_process":117,"fs":56}],53:[function(require,module,exports){\nvar util = require(\'../util\');\nvar Shape = require(\'../model/shape\');\n\nfunction DomXmlParser() { }\n\nDomXmlParser.prototype.parse = function(xml, shape) {\n  if (xml.replace(/^\\s+/, \'\') === \'\') return {};\n\n  var result, error;\n  try {\n    if (window.DOMParser) {\n      try {\n        var parser = new DOMParser();\n        result = parser.parseFromString(xml, \'text/xml\');\n      } catch (syntaxError) {\n        throw util.error(new Error(\'Parse error in document\'),\n          {\n            originalError: syntaxError,\n            code: \'XMLParserError\',\n            retryable: true\n          });\n      }\n\n      if (result.documentElement === null) {\n        throw util.error(new Error(\'Cannot parse empty document.\'),\n          {\n            code: \'XMLParserError\',\n            retryable: true\n          });\n      }\n\n      var isError = result.getElementsByTagName(\'parsererror\')[0];\n      if (isError && (isError.parentNode === result ||\n          isError.parentNode.nodeName === \'body\' ||\n          isError.parentNode.parentNode === result ||\n          isError.parentNode.parentNode.nodeName === \'body\')) {\n        var errorElement = isError.getElementsByTagName(\'div\')[0] || isError;\n        throw util.error(new Error(errorElement.textContent || \'Parser error in document\'),\n          {\n            code: \'XMLParserError\',\n            retryable: true\n          });\n      }\n    } else if (window.ActiveXObject) {\n      result = new window.ActiveXObject(\'Microsoft.XMLDOM\');\n      result.async = false;\n\n      if (!result.loadXML(xml)) {\n        throw util.error(new Error(\'Parse error in document\'),\n          {\n            code: \'XMLParserError\',\n            retryable: true\n          });\n      }\n    } else {\n      throw new Error(\'Cannot load XML parser\');\n    }\n  } catch (e) {\n    error = e;\n  }\n\n  if (result && result.documentElement && !error) {\n    var data = parseXml(result.documentElement, shape);\n    var metadata = result.getElementsByTagName(\'ResponseMetadata\')[0];\n    if (metadata) {\n      data.ResponseMetadata = parseXml(metadata, {});\n    }\n    return data;\n  } else if (error) {\n    throw util.error(error || new Error(), {code: \'XMLParserError\', retryable: true});\n  } else { // empty xml document\n    return {};\n  }\n};\n\nfunction parseXml(xml, shape) {\n  if (!shape) shape = {};\n  switch (shape.type) {\n    case \'structure\': return parseStructure(xml, shape);\n    case \'map\': return parseMap(xml, shape);\n    case \'list\': return parseList(xml, shape);\n    case undefined: case null: return parseUnknown(xml);\n    default: return parseScalar(xml, shape);\n  }\n}\n\nfunction parseStructure(xml, shape) {\n  var data = {};\n  if (xml === null) return data;\n\n  util.each(shape.members, function(memberName, memberShape) {\n    if (memberShape.isXmlAttribute) {\n      if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {\n        var value = xml.attributes[memberShape.name].value;\n        data[memberName] = parseXml({textContent: value}, memberShape);\n      }\n    } else {\n      var xmlChild = memberShape.flattened ? xml :\n        xml.getElementsByTagName(memberShape.name)[0];\n      if (xmlChild) {\n        data[memberName] = parseXml(xmlChild, memberShape);\n      } else if (!memberShape.flattened && memberShape.type === \'list\') {\n        data[memberName] = memberShape.defaultValue;\n      }\n    }\n  });\n\n  return data;\n}\n\nfunction parseMap(xml, shape) {\n  var data = {};\n  var xmlKey = shape.key.name || \'key\';\n  var xmlValue = shape.value.name || \'value\';\n  var tagName = shape.flattened ? shape.name : \'entry\';\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      var key = child.getElementsByTagName(xmlKey)[0].textContent;\n      var value = child.getElementsByTagName(xmlValue)[0];\n      data[key] = parseXml(value, shape.value);\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseList(xml, shape) {\n  var data = [];\n  var tagName = shape.flattened ? shape.name : (shape.member.name || \'member\');\n\n  var child = xml.firstElementChild;\n  while (child) {\n    if (child.nodeName === tagName) {\n      data.push(parseXml(child, shape.member));\n    }\n    child = child.nextElementSibling;\n  }\n  return data;\n}\n\nfunction parseScalar(xml, shape) {\n  if (xml.getAttribute) {\n    var encoding = xml.getAttribute(\'encoding\');\n    if (encoding === \'base64\') {\n      shape = new Shape.create({type: encoding});\n    }\n  }\n\n  var text = xml.textContent;\n  if (text === \'\') text = null;\n  if (typeof shape.toType === \'function\') {\n    return shape.toType(text);\n  } else {\n    return text;\n  }\n}\n\nfunction parseUnknown(xml) {\n  if (xml === undefined || xml === null) return \'\';\n\n  if (!xml.firstElementChild) {\n    if (xml.parentNode.parentNode === null) return {};\n    if (xml.childNodes.length === 0) return \'\';\n    else return xml.textContent;\n  }\n\n  var shape = {type: \'structure\', members: {}};\n  var child = xml.firstElementChild;\n  while (child) {\n    var tag = child.nodeName;\n    if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {\n      shape.members[tag].type = \'list\';\n    } else {\n      shape.members[tag] = {name: tag};\n    }\n    child = child.nextElementSibling;\n  }\n  return parseStructure(xml, shape);\n}\n\nmodule.exports = DomXmlParser;\n\n},{"../model/shape":27,"../util":52}],54:[function(require,module,exports){\nvar util = require(\'../util\');\nvar builder = require(\'xmlbuilder\');\n\nfunction XmlBuilder() { }\n\nXmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {\n  var xml = builder.create(rootElement);\n  applyNamespaces(xml, shape);\n  serialize(xml, params, shape);\n  return xml.children.length > 0 || noEmpty ? xml.root().toString() : \'\';\n};\n\nfunction serialize(xml, value, shape) {\n  switch (shape.type) {\n    case \'structure\': return serializeStructure(xml, value, shape);\n    case \'map\': return serializeMap(xml, value, shape);\n    case \'list\': return serializeList(xml, value, shape);\n    default: return serializeScalar(xml, value, shape);\n  }\n}\n\nfunction serializeStructure(xml, params, shape) {\n  util.arrayEach(shape.memberNames, function(memberName) {\n    var memberShape = shape.members[memberName];\n    if (memberShape.location !== \'body\') return;\n\n    var value = params[memberName];\n    var name = memberShape.name;\n    if (value !== undefined && value !== null) {\n      if (memberShape.isXmlAttribute) {\n        xml.att(name, value);\n      } else if (memberShape.flattened) {\n        serialize(xml, value, memberShape);\n      } else {\n        var element = xml.ele(name);\n        applyNamespaces(element, memberShape);\n        serialize(element, value, memberShape);\n      }\n    }\n  });\n}\n\nfunction serializeMap(xml, map, shape) {\n  var xmlKey = shape.key.name || \'key\';\n  var xmlValue = shape.value.name || \'value\';\n\n  util.each(map, function(key, value) {\n    var entry = xml.ele(shape.flattened ? shape.name : \'entry\');\n    serialize(entry.ele(xmlKey), key, shape.key);\n    serialize(entry.ele(xmlValue), value, shape.value);\n  });\n}\n\nfunction serializeList(xml, list, shape) {\n  if (shape.flattened) {\n    util.arrayEach(list, function(value) {\n      var name = shape.member.name || shape.name;\n      var element = xml.ele(name);\n      serialize(element, value, shape.member);\n    });\n  } else {\n    util.arrayEach(list, function(value) {\n      var name = shape.member.name || \'member\';\n      var element = xml.ele(name);\n      serialize(element, value, shape.member);\n    });\n  }\n}\n\nfunction serializeScalar(xml, value, shape) {\n  xml.txt(shape.toWireFormat(value));\n}\n\nfunction applyNamespaces(xml, shape) {\n  var uri, prefix = \'xmlns\';\n  if (shape.xmlNamespaceUri) {\n    uri = shape.xmlNamespaceUri;\n    if (shape.xmlNamespacePrefix) prefix += \':\' + shape.xmlNamespacePrefix;\n  } else if (xml.isRoot && shape.api.xmlNamespaceUri) {\n    uri = shape.api.xmlNamespaceUri;\n  }\n\n  if (uri) xml.att(prefix, uri);\n}\n\nmodule.exports = XmlBuilder;\n\n},{"../util":52,"xmlbuilder":145}],55:[function(require,module,exports){\n\'use strict\'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== \'undefined\' ? Uint8Array : Array\n\nvar code = \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup[\'-\'.charCodeAt(0)] = 62\nrevLookup[\'_\'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error(\'Invalid string. Length must be a multiple of 4\')\n  }\n\n  return b64[len - 2] === \'=\' ? 2 : b64[len - 1] === \'=\' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join(\'\')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = \'\'\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += \'==\'\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += \'=\'\n  }\n\n  parts.push(output)\n\n  return parts.join(\'\')\n}\n\n},{}],56:[function(require,module,exports){\n\n},{}],57:[function(require,module,exports){\n(function (global){\n\n\n\n\'use strict\'\n\nvar base64 = require(\'base64-js\')\nvar ieee754 = require(\'ieee754\')\nvar isArray = require(\'isarray\')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === \'function\' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError(\'Invalid typed array length\')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  if (typeof arg === \'number\') {\n    if (typeof encodingOrOffset === \'string\') {\n      throw new Error(\n        \'If encoding is specified then the first argument must be a string\'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === \'number\') {\n    throw new TypeError(\'"value" argument must not be a number\')\n  }\n\n  if (typeof ArrayBuffer !== \'undefined\' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === \'string\') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== \'undefined\' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== \'number\') {\n    throw new TypeError(\'"size" argument must be a number\')\n  } else if (size < 0) {\n    throw new RangeError(\'"size" argument must not be negative\')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    return typeof encoding === \'string\'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== \'string\' || encoding === \'\') {\n    encoding = \'utf8\'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError(\'"encoding" must be a valid string encoding\')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError(\'\\\'offset\\\' is out of bounds\')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError(\'\\\'length\\\' is out of bounds\')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== \'undefined\' &&\n        obj.buffer instanceof ArrayBuffer) || \'length\' in obj) {\n      if (typeof obj.length !== \'number\' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === \'Buffer\' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError(\'First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\')\n}\n\nfunction checked (length) {\n  if (length >= kMaxLength()) {\n    throw new RangeError(\'Attempt to allocate Buffer larger than maximum \' +\n                         \'size: 0x\' + kMaxLength().toString(16) + \' bytes\')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\'Arguments must be Buffers\')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case \'hex\':\n    case \'utf8\':\n    case \'utf-8\':\n    case \'ascii\':\n    case \'latin1\':\n    case \'binary\':\n    case \'base64\':\n    case \'ucs2\':\n    case \'ucs-2\':\n    case \'utf16le\':\n    case \'utf-16le\':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError(\'"list" argument must be an Array of Buffers\')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError(\'"list" argument must be an Array of Buffers\')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== \'undefined\' && typeof ArrayBuffer.isView === \'function\' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== \'string\') {\n    string = \'\' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case \'ascii\':\n      case \'latin1\':\n      case \'binary\':\n        return len\n      case \'utf8\':\n      case \'utf-8\':\n      case undefined:\n        return utf8ToBytes(string).length\n      case \'ucs2\':\n      case \'ucs-2\':\n      case \'utf16le\':\n      case \'utf-16le\':\n        return len * 2\n      case \'hex\':\n        return len >>> 1\n      case \'base64\':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = (\'\' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  if (start > this.length) {\n    return \'\'\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return \'\'\n  }\n\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return \'\'\n  }\n\n  if (!encoding) encoding = \'utf8\'\n\n  while (true) {\n    switch (encoding) {\n      case \'hex\':\n        return hexSlice(this, start, end)\n\n      case \'utf8\':\n      case \'utf-8\':\n        return utf8Slice(this, start, end)\n\n      case \'ascii\':\n        return asciiSlice(this, start, end)\n\n      case \'latin1\':\n      case \'binary\':\n        return latin1Slice(this, start, end)\n\n      case \'base64\':\n        return base64Slice(this, start, end)\n\n      case \'ucs2\':\n      case \'ucs-2\':\n      case \'utf16le\':\n      case \'utf-16le\':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError(\'Unknown encoding: \' + encoding)\n        encoding = (encoding + \'\').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError(\'Buffer size must be a multiple of 16-bits\')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError(\'Buffer size must be a multiple of 32-bits\')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError(\'Buffer size must be a multiple of 64-bits\')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return \'\'\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError(\'Argument must be a Buffer\')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = \'\'\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString(\'hex\', 0, max).match(/.{2}/g).join(\' \')\n    if (this.length > max) str += \' ... \'\n  }\n  return \'<Buffer \' + str + \'>\'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\'Argument must be a Buffer\')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError(\'out of range index\')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  if (buffer.length === 0) return -1\n\n  if (typeof byteOffset === \'string\') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  if (typeof val === \'string\') {\n    val = Buffer.from(val, encoding)\n  }\n\n  if (Buffer.isBuffer(val)) {\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === \'number\') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === \'function\') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError(\'val must be string, number or Buffer\')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === \'ucs2\' || encoding === \'ucs-2\' ||\n        encoding === \'utf16le\' || encoding === \'utf-16le\') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError(\'Invalid hex string\')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  if (offset === undefined) {\n    encoding = \'utf8\'\n    length = this.length\n    offset = 0\n  } else if (length === undefined && typeof offset === \'string\') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = \'utf8\'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      \'Buffer.write(string, encoding, offset[, length]) is no longer supported\'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError(\'Attempt to write outside buffer bounds\')\n  }\n\n  if (!encoding) encoding = \'utf8\'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case \'hex\':\n        return hexWrite(this, string, offset, length)\n\n      case \'utf8\':\n      case \'utf-8\':\n        return utf8Write(this, string, offset, length)\n\n      case \'ascii\':\n        return asciiWrite(this, string, offset, length)\n\n      case \'latin1\':\n      case \'binary\':\n        return latin1Write(this, string, offset, length)\n\n      case \'base64\':\n        return base64Write(this, string, offset, length)\n\n      case \'ucs2\':\n      case \'ucs-2\':\n      case \'utf16le\':\n      case \'utf-16le\':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError(\'Unknown encoding: \' + encoding)\n        encoding = (\'\' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: \'Buffer\',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  var res = \'\'\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = \'\'\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = \'\'\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = \'\'\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = \'\'\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError(\'offset is not uint\')\n  if (offset + ext > length) throw new RangeError(\'Trying to access beyond buffer length\')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError(\'"buffer" argument must be a Buffer instance\')\n  if (value > max || value < min) throw new RangeError(\'"value" argument is out of bounds\')\n  if (offset + ext > buf.length) throw new RangeError(\'Index out of range\')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError(\'Index out of range\')\n  if (offset < 0) throw new RangeError(\'Index out of range\')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  if (targetStart < 0) {\n    throw new RangeError(\'targetStart out of bounds\')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError(\'sourceStart out of bounds\')\n  if (end < 0) throw new RangeError(\'sourceEnd out of bounds\')\n\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  if (typeof val === \'string\') {\n    if (typeof start === \'string\') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === \'string\') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== \'string\') {\n      throw new TypeError(\'encoding must be a string\')\n    }\n    if (typeof encoding === \'string\' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError(\'Unknown encoding: \' + encoding)\n    }\n  } else if (typeof val === \'number\') {\n    val = val & 255\n  }\n\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError(\'Out of range index\')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === \'number\') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  str = stringtrim(str).replace(INVALID_BASE64_RE, \'\')\n  if (str.length < 2) return \'\'\n  while (str.length % 4 !== 0) {\n    str = str + \'=\'\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, \'\')\n}\n\nfunction toHex (n) {\n  if (n < 16) return \'0\' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      if (!leadSurrogate) {\n        if (codePoint > 0xDBFF) {\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error(\'Invalid code point\')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{"base64-js":55,"ieee754":66,"isarray":67}],58:[function(require,module,exports){\narguments[4][57][0].apply(exports,arguments)\n},{"base64-js":55,"dup":57,"ieee754":66,"isarray":67}],59:[function(require,module,exports){\nvar Buffer = require(\'buffer\').Buffer;\nvar intSize = 4;\nvar zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);\nvar chrsz = 8;\n\nfunction toArray(buf, bigEndian) {\n  if ((buf.length % intSize) !== 0) {\n    var len = buf.length + (intSize - (buf.length % intSize));\n    buf = Buffer.concat([buf, zeroBuffer], len);\n  }\n\n  var arr = [];\n  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;\n  for (var i = 0; i < buf.length; i += intSize) {\n    arr.push(fn.call(buf, i));\n  }\n  return arr;\n}\n\nfunction toBuffer(arr, size, bigEndian) {\n  var buf = new Buffer(size);\n  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;\n  for (var i = 0; i < arr.length; i++) {\n    fn.call(buf, arr[i], i * 4, true);\n  }\n  return buf;\n}\n\nfunction hash(buf, fn, hashSize, bigEndian) {\n  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);\n  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);\n  return toBuffer(arr, hashSize, bigEndian);\n}\n\nmodule.exports = { hash: hash };\n\n},{"buffer":57}],60:[function(require,module,exports){\nvar Buffer = require(\'buffer\').Buffer\nvar sha = require(\'./sha\')\nvar sha256 = require(\'./sha256\')\nvar rng = require(\'./rng\')\nvar md5 = require(\'./md5\')\n\nvar algorithms = {\n  sha1: sha,\n  sha256: sha256,\n  md5: md5\n}\n\nvar blocksize = 64\nvar zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)\nfunction hmac(fn, key, data) {\n  if(!Buffer.isBuffer(key)) key = new Buffer(key)\n  if(!Buffer.isBuffer(data)) data = new Buffer(data)\n\n  if(key.length > blocksize) {\n    key = fn(key)\n  } else if(key.length < blocksize) {\n    key = Buffer.concat([key, zeroBuffer], blocksize)\n  }\n\n  var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)\n  for(var i = 0; i < blocksize; i++) {\n    ipad[i] = key[i] ^ 0x36\n    opad[i] = key[i] ^ 0x5C\n  }\n\n  var hash = fn(Buffer.concat([ipad, data]))\n  return fn(Buffer.concat([opad, hash]))\n}\n\nfunction hash(alg, key) {\n  alg = alg || \'sha1\'\n  var fn = algorithms[alg]\n  var bufs = []\n  var length = 0\n  if(!fn) error(\'algorithm:\', alg, \'is not yet supported\')\n  return {\n    update: function (data) {\n      if(!Buffer.isBuffer(data)) data = new Buffer(data)\n        \n      bufs.push(data)\n      length += data.length\n      return this\n    },\n    digest: function (enc) {\n      var buf = Buffer.concat(bufs)\n      var r = key ? hmac(fn, key, buf) : fn(buf)\n      bufs = null\n      return enc ? r.toString(enc) : r\n    }\n  }\n}\n\nfunction error () {\n  var m = [].slice.call(arguments).join(\' \')\n  throw new Error([\n    m,\n    \'we accept pull requests\',\n    \'http://github.com/dominictarr/crypto-browserify\'\n    ].join(\'\\n\'))\n}\n\nexports.createHash = function (alg) { return hash(alg) }\nexports.createHmac = function (alg, key) { return hash(alg, key) }\nexports.randomBytes = function(size, callback) {\n  if (callback && callback.call) {\n    try {\n      callback.call(this, undefined, new Buffer(rng(size)))\n    } catch (err) { callback(err) }\n  } else {\n    return new Buffer(rng(size))\n  }\n}\n\nfunction each(a, f) {\n  for(var i in a)\n    f(a[i], i)\n}\n\neach([\'createCredentials\'\n, \'createCipher\'\n, \'createCipheriv\'\n, \'createDecipher\'\n, \'createDecipheriv\'\n, \'createSign\'\n, \'createVerify\'\n, \'createDiffieHellman\'\n, \'pbkdf2\'], function (name) {\n  exports[name] = function () {\n    error(\'sorry,\', name, \'is not implemented yet\')\n  }\n})\n\n},{"./md5":61,"./rng":62,"./sha":63,"./sha256":64,"buffer":57}],61:[function(require,module,exports){\n\n\nvar helpers = require(\'./helpers\');\n\n\nfunction md5_vm_test()\n{\n  return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";\n}\n\n\nfunction core_md5(x, len)\n{\n\n  x[len >> 5] |= 0x80 << ((len) % 32);\n  x[(((len + 64) >>> 9) << 4) + 14] = len;\n\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n\n    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);\n    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);\n    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);\n    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);\n    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);\n    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);\n    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);\n    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);\n    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);\n    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);\n    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);\n    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);\n    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);\n    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);\n    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);\n    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);\n\n    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);\n    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);\n    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);\n    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);\n    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);\n    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);\n    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);\n    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);\n    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);\n    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);\n    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);\n    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);\n    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);\n    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);\n    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);\n    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);\n\n    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);\n    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);\n    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);\n    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);\n    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);\n    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);\n    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);\n    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);\n    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);\n    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);\n    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);\n    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);\n    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);\n    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);\n    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);\n    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);\n\n    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);\n    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);\n    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);\n    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);\n    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);\n    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);\n    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);\n    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);\n    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);\n    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);\n    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);\n    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);\n    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);\n    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);\n    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);\n    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n  }\n  return Array(a, b, c, d);\n\n}\n\n\nfunction md5_cmn(q, a, b, x, s, t)\n{\n  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);\n}\nfunction md5_ff(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t)\n{\n  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t)\n{\n  return md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t)\n{\n  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\n}\n\n\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n\nfunction bit_rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function md5(buf) {\n  return helpers.hash(buf, core_md5, 16);\n};\n\n},{"./helpers":59}],62:[function(require,module,exports){\n(function() {\n  var _global = this;\n\n  var mathRNG, whatwgRNG;\n\n  mathRNG = function(size) {\n    var bytes = new Array(size);\n    var r;\n\n    for (var i = 0, r; i < size; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return bytes;\n  }\n\n  if (_global.crypto && crypto.getRandomValues) {\n    whatwgRNG = function(size) {\n      var bytes = new Uint8Array(size);\n      crypto.getRandomValues(bytes);\n      return bytes;\n    }\n  }\n\n  module.exports = whatwgRNG || mathRNG;\n\n}())\n\n},{}],63:[function(require,module,exports){\n\n\nvar helpers = require(\'./helpers\');\n\n\nfunction core_sha1(x, len)\n{\n\n  x[len >> 5] |= 0x80 << (24 - len % 32);\n  x[((len + 64 >> 9) << 4) + 15] = len;\n\n  var w = Array(80);\n  var a =  1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d =  271733878;\n  var e = -1009589776;\n\n  for(var i = 0; i < x.length; i += 16)\n  {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    var olde = e;\n\n    for(var j = 0; j < 80; j++)\n    {\n      if(j < 16) w[j] = x[i + j];\n      else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\n      var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\n      e = d;\n      d = c;\n      c = rol(b, 30);\n      b = a;\n      a = t;\n    }\n\n    a = safe_add(a, olda);\n    b = safe_add(b, oldb);\n    c = safe_add(c, oldc);\n    d = safe_add(d, oldd);\n    e = safe_add(e, olde);\n  }\n  return Array(a, b, c, d, e);\n\n}\n\n\nfunction sha1_ft(t, b, c, d)\n{\n  if(t < 20) return (b & c) | ((~b) & d);\n  if(t < 40) return b ^ c ^ d;\n  if(t < 60) return (b & c) | (b & d) | (c & d);\n  return b ^ c ^ d;\n}\n\n\nfunction sha1_kt(t)\n{\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\n         (t < 60) ? -1894007588 : -899497514;\n}\n\n\nfunction safe_add(x, y)\n{\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n}\n\n\nfunction rol(num, cnt)\n{\n  return (num << cnt) | (num >>> (32 - cnt));\n}\n\nmodule.exports = function sha1(buf) {\n  return helpers.hash(buf, core_sha1, 20, true);\n};\n\n},{"./helpers":59}],64:[function(require,module,exports){\n\n\n\nvar helpers = require(\'./helpers\');\n\nvar safe_add = function(x, y) {\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return (msw << 16) | (lsw & 0xFFFF);\n};\n\nvar S = function(X, n) {\n  return (X >>> n) | (X << (32 - n));\n};\n\nvar R = function(X, n) {\n  return (X >>> n);\n};\n\nvar Ch = function(x, y, z) {\n  return ((x & y) ^ ((~x) & z));\n};\n\nvar Maj = function(x, y, z) {\n  return ((x & y) ^ (x & z) ^ (y & z));\n};\n\nvar Sigma0256 = function(x) {\n  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));\n};\n\nvar Sigma1256 = function(x) {\n  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));\n};\n\nvar Gamma0256 = function(x) {\n  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));\n};\n\nvar Gamma1256 = function(x) {\n  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));\n};\n\nvar core_sha256 = function(m, l) {\n  var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);\n  var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n\n  m[l >> 5] |= 0x80 << (24 - l % 32);\n  m[((l + 64 >> 9) << 4) + 15] = l;\n  for (var i = 0; i < m.length; i += 16) {\n    a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];\n    for (var j = 0; j < 64; j++) {\n      if (j < 16) {\n        W[j] = m[j + i];\n      } else {\n        W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);\n      }\n      T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);\n      T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n      h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);\n    }\n    HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);\n    HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);\n  }\n  return HASH;\n};\n\nmodule.exports = function sha256(buf) {\n  return helpers.hash(buf, core_sha256, 32, true);\n};\n\n},{"./helpers":59}],65:[function(require,module,exports){\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError(\'n must be a positive number\');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  if (type === \'error\') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled \'error\' event\n      } else {\n        var err = new Error(\'Uncaught, unspecified "error" event. (\' + er + \')\');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError(\'listener must be a function\');\n\n  if (!this._events)\n    this._events = {};\n\n  if (this._events.newListener)\n    this.emit(\'newListener\', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    this._events[type].push(listener);\n  else\n    this._events[type] = [this._events[type], listener];\n\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error(\'(node) warning: possible EventEmitter memory \' +\n                    \'leak detected. %d listeners added. \' +\n                    \'Use emitter.setMaxListeners() to increase limit.\',\n                    this._events[type].length);\n      if (typeof console.trace === \'function\') {\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError(\'listener must be a function\');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError(\'listener must be a function\');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit(\'removeListener\', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit(\'removeListener\', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === \'removeListener\') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners(\'removeListener\');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === \'function\';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === \'number\';\n}\n\nfunction isObject(arg) {\n  return typeof arg === \'object\' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],66:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],67:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == \'[object Array]\';\n};\n\n},{}],68:[function(require,module,exports){\n(function(exports) {\n  "use strict";\n\n  function isArray(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === "[object Array]";\n    } else {\n      return false;\n    }\n  }\n\n  function isObject(obj) {\n    if (obj !== null) {\n      return Object.prototype.toString.call(obj) === "[object Object]";\n    } else {\n      return false;\n    }\n  }\n\n  function strictDeepEqual(first, second) {\n    if (first === second) {\n      return true;\n    }\n\n    var firstType = Object.prototype.toString.call(first);\n    if (firstType !== Object.prototype.toString.call(second)) {\n      return false;\n    }\n    if (isArray(first) === true) {\n      if (first.length !== second.length) {\n        return false;\n      }\n      for (var i = 0; i < first.length; i++) {\n        if (strictDeepEqual(first[i], second[i]) === false) {\n          return false;\n        }\n      }\n      return true;\n    }\n    if (isObject(first) === true) {\n      var keysSeen = {};\n      for (var key in first) {\n        if (hasOwnProperty.call(first, key)) {\n          if (strictDeepEqual(first[key], second[key]) === false) {\n            return false;\n          }\n          keysSeen[key] = true;\n        }\n      }\n      for (var key2 in second) {\n        if (hasOwnProperty.call(second, key2)) {\n          if (keysSeen[key2] !== true) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  function isFalse(obj) {\n\n    if (obj === "" || obj === false || obj === null) {\n        return true;\n    } else if (isArray(obj) && obj.length === 0) {\n        return true;\n    } else if (isObject(obj)) {\n        for (var key in obj) {\n            if (obj.hasOwnProperty(key)) {\n              return false;\n            }\n        }\n        return true;\n    } else {\n        return false;\n    }\n  }\n\n  function objValues(obj) {\n    var keys = Object.keys(obj);\n    var values = [];\n    for (var i = 0; i < keys.length; i++) {\n      values.push(obj[keys[i]]);\n    }\n    return values;\n  }\n\n  function merge(a, b) {\n      var merged = {};\n      for (var key in a) {\n          merged[key] = a[key];\n      }\n      for (var key2 in b) {\n          merged[key2] = b[key2];\n      }\n      return merged;\n  }\n\n  var trimLeft;\n  if (typeof String.prototype.trimLeft === "function") {\n    trimLeft = function(str) {\n      return str.trimLeft();\n    };\n  } else {\n    trimLeft = function(str) {\n      return str.match(/^\\s*(.*)/)[1];\n    };\n  }\n\n  var TYPE_NUMBER = 0;\n  var TYPE_ANY = 1;\n  var TYPE_STRING = 2;\n  var TYPE_ARRAY = 3;\n  var TYPE_OBJECT = 4;\n  var TYPE_BOOLEAN = 5;\n  var TYPE_EXPREF = 6;\n  var TYPE_NULL = 7;\n  var TYPE_ARRAY_NUMBER = 8;\n  var TYPE_ARRAY_STRING = 9;\n\n  var TOK_EOF = "EOF";\n  var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";\n  var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";\n  var TOK_RBRACKET = "Rbracket";\n  var TOK_RPAREN = "Rparen";\n  var TOK_COMMA = "Comma";\n  var TOK_COLON = "Colon";\n  var TOK_RBRACE = "Rbrace";\n  var TOK_NUMBER = "Number";\n  var TOK_CURRENT = "Current";\n  var TOK_EXPREF = "Expref";\n  var TOK_PIPE = "Pipe";\n  var TOK_OR = "Or";\n  var TOK_AND = "And";\n  var TOK_EQ = "EQ";\n  var TOK_GT = "GT";\n  var TOK_LT = "LT";\n  var TOK_GTE = "GTE";\n  var TOK_LTE = "LTE";\n  var TOK_NE = "NE";\n  var TOK_FLATTEN = "Flatten";\n  var TOK_STAR = "Star";\n  var TOK_FILTER = "Filter";\n  var TOK_DOT = "Dot";\n  var TOK_NOT = "Not";\n  var TOK_LBRACE = "Lbrace";\n  var TOK_LBRACKET = "Lbracket";\n  var TOK_LPAREN= "Lparen";\n  var TOK_LITERAL= "Literal";\n\n\n  var basicTokens = {\n    ".": TOK_DOT,\n    "*": TOK_STAR,\n    ",": TOK_COMMA,\n    ":": TOK_COLON,\n    "{": TOK_LBRACE,\n    "}": TOK_RBRACE,\n    "]": TOK_RBRACKET,\n    "(": TOK_LPAREN,\n    ")": TOK_RPAREN,\n    "@": TOK_CURRENT\n  };\n\n  var operatorStartToken = {\n      "<": true,\n      ">": true,\n      "=": true,\n      "!": true\n  };\n\n  var skipChars = {\n      " ": true,\n      "\\t": true,\n      "\\n": true\n  };\n\n\n  function isAlpha(ch) {\n      return (ch >= "a" && ch <= "z") ||\n             (ch >= "A" && ch <= "Z") ||\n             ch === "_";\n  }\n\n  function isNum(ch) {\n      return (ch >= "0" && ch <= "9") ||\n             ch === "-";\n  }\n  function isAlphaNum(ch) {\n      return (ch >= "a" && ch <= "z") ||\n             (ch >= "A" && ch <= "Z") ||\n             (ch >= "0" && ch <= "9") ||\n             ch === "_";\n  }\n\n  function Lexer() {\n  }\n  Lexer.prototype = {\n      tokenize: function(stream) {\n          var tokens = [];\n          this._current = 0;\n          var start;\n          var identifier;\n          var token;\n          while (this._current < stream.length) {\n              if (isAlpha(stream[this._current])) {\n                  start = this._current;\n                  identifier = this._consumeUnquotedIdentifier(stream);\n                  tokens.push({type: TOK_UNQUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (basicTokens[stream[this._current]] !== undefined) {\n                  tokens.push({type: basicTokens[stream[this._current]],\n                              value: stream[this._current],\n                              start: this._current});\n                  this._current++;\n              } else if (isNum(stream[this._current])) {\n                  token = this._consumeNumber(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === "[") {\n                  token = this._consumeLBracket(stream);\n                  tokens.push(token);\n              } else if (stream[this._current] === "\\"") {\n                  start = this._current;\n                  identifier = this._consumeQuotedIdentifier(stream);\n                  tokens.push({type: TOK_QUOTEDIDENTIFIER,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === "\'") {\n                  start = this._current;\n                  identifier = this._consumeRawStringLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: identifier,\n                               start: start});\n              } else if (stream[this._current] === "`") {\n                  start = this._current;\n                  var literal = this._consumeLiteral(stream);\n                  tokens.push({type: TOK_LITERAL,\n                               value: literal,\n                               start: start});\n              } else if (operatorStartToken[stream[this._current]] !== undefined) {\n                  tokens.push(this._consumeOperator(stream));\n              } else if (skipChars[stream[this._current]] !== undefined) {\n                  this._current++;\n              } else if (stream[this._current] === "&") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === "&") {\n                      this._current++;\n                      tokens.push({type: TOK_AND, value: "&&", start: start});\n                  } else {\n                      tokens.push({type: TOK_EXPREF, value: "&", start: start});\n                  }\n              } else if (stream[this._current] === "|") {\n                  start = this._current;\n                  this._current++;\n                  if (stream[this._current] === "|") {\n                      this._current++;\n                      tokens.push({type: TOK_OR, value: "||", start: start});\n                  } else {\n                      tokens.push({type: TOK_PIPE, value: "|", start: start});\n                  }\n              } else {\n                  var error = new Error("Unknown character:" + stream[this._current]);\n                  error.name = "LexerError";\n                  throw error;\n              }\n          }\n          return tokens;\n      },\n\n      _consumeUnquotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          while (this._current < stream.length && isAlphaNum(stream[this._current])) {\n              this._current++;\n          }\n          return stream.slice(start, this._current);\n      },\n\n      _consumeQuotedIdentifier: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== "\\"" && this._current < maxLength) {\n              var current = this._current;\n              if (stream[current] === "\\\\" && (stream[current + 1] === "\\\\" ||\n                                               stream[current + 1] === "\\"")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          return JSON.parse(stream.slice(start, this._current));\n      },\n\n      _consumeRawStringLiteral: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (stream[this._current] !== "\'" && this._current < maxLength) {\n              var current = this._current;\n              if (stream[current] === "\\\\" && (stream[current + 1] === "\\\\" ||\n                                               stream[current + 1] === "\'")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          this._current++;\n          var literal = stream.slice(start + 1, this._current - 1);\n          return literal.replace("\\\\\'", "\'");\n      },\n\n      _consumeNumber: function(stream) {\n          var start = this._current;\n          this._current++;\n          var maxLength = stream.length;\n          while (isNum(stream[this._current]) && this._current < maxLength) {\n              this._current++;\n          }\n          var value = parseInt(stream.slice(start, this._current));\n          return {type: TOK_NUMBER, value: value, start: start};\n      },\n\n      _consumeLBracket: function(stream) {\n          var start = this._current;\n          this._current++;\n          if (stream[this._current] === "?") {\n              this._current++;\n              return {type: TOK_FILTER, value: "[?", start: start};\n          } else if (stream[this._current] === "]") {\n              this._current++;\n              return {type: TOK_FLATTEN, value: "[]", start: start};\n          } else {\n              return {type: TOK_LBRACKET, value: "[", start: start};\n          }\n      },\n\n      _consumeOperator: function(stream) {\n          var start = this._current;\n          var startingChar = stream[start];\n          this._current++;\n          if (startingChar === "!") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_NE, value: "!=", start: start};\n              } else {\n                return {type: TOK_NOT, value: "!", start: start};\n              }\n          } else if (startingChar === "<") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_LTE, value: "<=", start: start};\n              } else {\n                  return {type: TOK_LT, value: "<", start: start};\n              }\n          } else if (startingChar === ">") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_GTE, value: ">=", start: start};\n              } else {\n                  return {type: TOK_GT, value: ">", start: start};\n              }\n          } else if (startingChar === "=") {\n              if (stream[this._current] === "=") {\n                  this._current++;\n                  return {type: TOK_EQ, value: "==", start: start};\n              }\n          }\n      },\n\n      _consumeLiteral: function(stream) {\n          this._current++;\n          var start = this._current;\n          var maxLength = stream.length;\n          var literal;\n          while(stream[this._current] !== "`" && this._current < maxLength) {\n              var current = this._current;\n              if (stream[current] === "\\\\" && (stream[current + 1] === "\\\\" ||\n                                               stream[current + 1] === "`")) {\n                  current += 2;\n              } else {\n                  current++;\n              }\n              this._current = current;\n          }\n          var literalString = trimLeft(stream.slice(start, this._current));\n          literalString = literalString.replace("\\\\`", "`");\n          if (this._looksLikeJSON(literalString)) {\n              literal = JSON.parse(literalString);\n          } else {\n              literal = JSON.parse("\\"" + literalString + "\\"");\n          }\n          this._current++;\n          return literal;\n      },\n\n      _looksLikeJSON: function(literalString) {\n          var startingChars = "[{\\"";\n          var jsonLiterals = ["true", "false", "null"];\n          var numberLooking = "-0123456789";\n\n          if (literalString === "") {\n              return false;\n          } else if (startingChars.indexOf(literalString[0]) >= 0) {\n              return true;\n          } else if (jsonLiterals.indexOf(literalString) >= 0) {\n              return true;\n          } else if (numberLooking.indexOf(literalString[0]) >= 0) {\n              try {\n                  JSON.parse(literalString);\n                  return true;\n              } catch (ex) {\n                  return false;\n              }\n          } else {\n              return false;\n          }\n      }\n  };\n\n      var bindingPower = {};\n      bindingPower[TOK_EOF] = 0;\n      bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_QUOTEDIDENTIFIER] = 0;\n      bindingPower[TOK_RBRACKET] = 0;\n      bindingPower[TOK_RPAREN] = 0;\n      bindingPower[TOK_COMMA] = 0;\n      bindingPower[TOK_RBRACE] = 0;\n      bindingPower[TOK_NUMBER] = 0;\n      bindingPower[TOK_CURRENT] = 0;\n      bindingPower[TOK_EXPREF] = 0;\n      bindingPower[TOK_PIPE] = 1;\n      bindingPower[TOK_OR] = 2;\n      bindingPower[TOK_AND] = 3;\n      bindingPower[TOK_EQ] = 5;\n      bindingPower[TOK_GT] = 5;\n      bindingPower[TOK_LT] = 5;\n      bindingPower[TOK_GTE] = 5;\n      bindingPower[TOK_LTE] = 5;\n      bindingPower[TOK_NE] = 5;\n      bindingPower[TOK_FLATTEN] = 9;\n      bindingPower[TOK_STAR] = 20;\n      bindingPower[TOK_FILTER] = 21;\n      bindingPower[TOK_DOT] = 40;\n      bindingPower[TOK_NOT] = 45;\n      bindingPower[TOK_LBRACE] = 50;\n      bindingPower[TOK_LBRACKET] = 55;\n      bindingPower[TOK_LPAREN] = 60;\n\n  function Parser() {\n  }\n\n  Parser.prototype = {\n      parse: function(expression) {\n          this._loadTokens(expression);\n          this.index = 0;\n          var ast = this.expression(0);\n          if (this._lookahead(0) !== TOK_EOF) {\n              var t = this._lookaheadToken(0);\n              var error = new Error(\n                  "Unexpected token type: " + t.type + ", value: " + t.value);\n              error.name = "ParserError";\n              throw error;\n          }\n          return ast;\n      },\n\n      _loadTokens: function(expression) {\n          var lexer = new Lexer();\n          var tokens = lexer.tokenize(expression);\n          tokens.push({type: TOK_EOF, value: "", start: expression.length});\n          this.tokens = tokens;\n      },\n\n      expression: function(rbp) {\n          var leftToken = this._lookaheadToken(0);\n          this._advance();\n          var left = this.nud(leftToken);\n          var currentToken = this._lookahead(0);\n          while (rbp < bindingPower[currentToken]) {\n              this._advance();\n              left = this.led(currentToken, left);\n              currentToken = this._lookahead(0);\n          }\n          return left;\n      },\n\n      _lookahead: function(number) {\n          return this.tokens[this.index + number].type;\n      },\n\n      _lookaheadToken: function(number) {\n          return this.tokens[this.index + number];\n      },\n\n      _advance: function() {\n          this.index++;\n      },\n\n      nud: function(token) {\n        var left;\n        var right;\n        var expression;\n        switch (token.type) {\n          case TOK_LITERAL:\n            return {type: "Literal", value: token.value};\n          case TOK_UNQUOTEDIDENTIFIER:\n            return {type: "Field", name: token.value};\n          case TOK_QUOTEDIDENTIFIER:\n            var node = {type: "Field", name: token.value};\n            if (this._lookahead(0) === TOK_LPAREN) {\n                throw new Error("Quoted identifier not allowed for function names.");\n            } else {\n                return node;\n            }\n            break;\n          case TOK_NOT:\n            right = this.expression(bindingPower.Not);\n            return {type: "NotExpression", children: [right]};\n          case TOK_STAR:\n            left = {type: "Identity"};\n            right = null;\n            if (this._lookahead(0) === TOK_RBRACKET) {\n                right = {type: "Identity"};\n            } else {\n                right = this._parseProjectionRHS(bindingPower.Star);\n            }\n            return {type: "ValueProjection", children: [left, right]};\n          case TOK_FILTER:\n            return this.led(token.type, {type: "Identity"});\n          case TOK_LBRACE:\n            return this._parseMultiselectHash();\n          case TOK_FLATTEN:\n            left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};\n            right = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: "Projection", children: [left, right]};\n          case TOK_LBRACKET:\n            if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice({type: "Identity"}, right);\n            } else if (this._lookahead(0) === TOK_STAR &&\n                       this._lookahead(1) === TOK_RBRACKET) {\n                this._advance();\n                this._advance();\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {type: "Projection",\n                        children: [{type: "Identity"}, right]};\n            } else {\n                return this._parseMultiselectList();\n            }\n            break;\n          case TOK_CURRENT:\n            return {type: TOK_CURRENT};\n          case TOK_EXPREF:\n            expression = this.expression(bindingPower.Expref);\n            return {type: "ExpressionReference", children: [expression]};\n          case TOK_LPAREN:\n            var args = [];\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            return args[0];\n          default:\n            this._errorToken(token);\n        }\n      },\n\n      led: function(tokenName, left) {\n        var right;\n        switch(tokenName) {\n          case TOK_DOT:\n            var rbp = bindingPower.Dot;\n            if (this._lookahead(0) !== TOK_STAR) {\n                right = this._parseDotRHS(rbp);\n                return {type: "Subexpression", children: [left, right]};\n            } else {\n                this._advance();\n                right = this._parseProjectionRHS(rbp);\n                return {type: "ValueProjection", children: [left, right]};\n            }\n            break;\n          case TOK_PIPE:\n            right = this.expression(bindingPower.Pipe);\n            return {type: TOK_PIPE, children: [left, right]};\n          case TOK_OR:\n            right = this.expression(bindingPower.Or);\n            return {type: "OrExpression", children: [left, right]};\n          case TOK_AND:\n            right = this.expression(bindingPower.And);\n            return {type: "AndExpression", children: [left, right]};\n          case TOK_LPAREN:\n            var name = left.name;\n            var args = [];\n            var expression, node;\n            while (this._lookahead(0) !== TOK_RPAREN) {\n              if (this._lookahead(0) === TOK_CURRENT) {\n                expression = {type: TOK_CURRENT};\n                this._advance();\n              } else {\n                expression = this.expression(0);\n              }\n              if (this._lookahead(0) === TOK_COMMA) {\n                this._match(TOK_COMMA);\n              }\n              args.push(expression);\n            }\n            this._match(TOK_RPAREN);\n            node = {type: "Function", name: name, children: args};\n            return node;\n          case TOK_FILTER:\n            var condition = this.expression(0);\n            this._match(TOK_RBRACKET);\n            if (this._lookahead(0) === TOK_FLATTEN) {\n              right = {type: "Identity"};\n            } else {\n              right = this._parseProjectionRHS(bindingPower.Filter);\n            }\n            return {type: "FilterProjection", children: [left, right, condition]};\n          case TOK_FLATTEN:\n            var leftNode = {type: TOK_FLATTEN, children: [left]};\n            var rightNode = this._parseProjectionRHS(bindingPower.Flatten);\n            return {type: "Projection", children: [leftNode, rightNode]};\n          case TOK_EQ:\n          case TOK_NE:\n          case TOK_GT:\n          case TOK_GTE:\n          case TOK_LT:\n          case TOK_LTE:\n            return this._parseComparator(left, tokenName);\n          case TOK_LBRACKET:\n            var token = this._lookaheadToken(0);\n            if (token.type === TOK_NUMBER || token.type === TOK_COLON) {\n                right = this._parseIndexExpression();\n                return this._projectIfSlice(left, right);\n            } else {\n                this._match(TOK_STAR);\n                this._match(TOK_RBRACKET);\n                right = this._parseProjectionRHS(bindingPower.Star);\n                return {type: "Projection", children: [left, right]};\n            }\n            break;\n          default:\n            this._errorToken(this._lookaheadToken(0));\n        }\n      },\n\n      _match: function(tokenType) {\n          if (this._lookahead(0) === tokenType) {\n              this._advance();\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error("Expected " + tokenType + ", got: " + t.type);\n              error.name = "ParserError";\n              throw error;\n          }\n      },\n\n      _errorToken: function(token) {\n          var error = new Error("Invalid token (" +\n                                token.type + "): \\"" +\n                                token.value + "\\"");\n          error.name = "ParserError";\n          throw error;\n      },\n\n\n      _parseIndexExpression: function() {\n          if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {\n              return this._parseSliceExpression();\n          } else {\n              var node = {\n                  type: "Index",\n                  value: this._lookaheadToken(0).value};\n              this._advance();\n              this._match(TOK_RBRACKET);\n              return node;\n          }\n      },\n\n      _projectIfSlice: function(left, right) {\n          var indexExpr = {type: "IndexExpression", children: [left, right]};\n          if (right.type === "Slice") {\n              return {\n                  type: "Projection",\n                  children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]\n              };\n          } else {\n              return indexExpr;\n          }\n      },\n\n      _parseSliceExpression: function() {\n          var parts = [null, null, null];\n          var index = 0;\n          var currentToken = this._lookahead(0);\n          while (currentToken !== TOK_RBRACKET && index < 3) {\n              if (currentToken === TOK_COLON) {\n                  index++;\n                  this._advance();\n              } else if (currentToken === TOK_NUMBER) {\n                  parts[index] = this._lookaheadToken(0).value;\n                  this._advance();\n              } else {\n                  var t = this._lookahead(0);\n                  var error = new Error("Syntax error, unexpected token: " +\n                                        t.value + "(" + t.type + ")");\n                  error.name = "Parsererror";\n                  throw error;\n              }\n              currentToken = this._lookahead(0);\n          }\n          this._match(TOK_RBRACKET);\n          return {\n              type: "Slice",\n              children: parts\n          };\n      },\n\n      _parseComparator: function(left, comparator) {\n        var right = this.expression(bindingPower[comparator]);\n        return {type: "Comparator", name: comparator, children: [left, right]};\n      },\n\n      _parseDotRHS: function(rbp) {\n          var lookahead = this._lookahead(0);\n          var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];\n          if (exprTokens.indexOf(lookahead) >= 0) {\n              return this.expression(rbp);\n          } else if (lookahead === TOK_LBRACKET) {\n              this._match(TOK_LBRACKET);\n              return this._parseMultiselectList();\n          } else if (lookahead === TOK_LBRACE) {\n              this._match(TOK_LBRACE);\n              return this._parseMultiselectHash();\n          }\n      },\n\n      _parseProjectionRHS: function(rbp) {\n          var right;\n          if (bindingPower[this._lookahead(0)] < 10) {\n              right = {type: "Identity"};\n          } else if (this._lookahead(0) === TOK_LBRACKET) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_FILTER) {\n              right = this.expression(rbp);\n          } else if (this._lookahead(0) === TOK_DOT) {\n              this._match(TOK_DOT);\n              right = this._parseDotRHS(rbp);\n          } else {\n              var t = this._lookaheadToken(0);\n              var error = new Error("Sytanx error, unexpected token: " +\n                                    t.value + "(" + t.type + ")");\n              error.name = "ParserError";\n              throw error;\n          }\n          return right;\n      },\n\n      _parseMultiselectList: function() {\n          var expressions = [];\n          while (this._lookahead(0) !== TOK_RBRACKET) {\n              var expression = this.expression(0);\n              expressions.push(expression);\n              if (this._lookahead(0) === TOK_COMMA) {\n                  this._match(TOK_COMMA);\n                  if (this._lookahead(0) === TOK_RBRACKET) {\n                    throw new Error("Unexpected token Rbracket");\n                  }\n              }\n          }\n          this._match(TOK_RBRACKET);\n          return {type: "MultiSelectList", children: expressions};\n      },\n\n      _parseMultiselectHash: function() {\n        var pairs = [];\n        var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];\n        var keyToken, keyName, value, node;\n        for (;;) {\n          keyToken = this._lookaheadToken(0);\n          if (identifierTypes.indexOf(keyToken.type) < 0) {\n            throw new Error("Expecting an identifier token, got: " +\n                            keyToken.type);\n          }\n          keyName = keyToken.value;\n          this._advance();\n          this._match(TOK_COLON);\n          value = this.expression(0);\n          node = {type: "KeyValuePair", name: keyName, value: value};\n          pairs.push(node);\n          if (this._lookahead(0) === TOK_COMMA) {\n            this._match(TOK_COMMA);\n          } else if (this._lookahead(0) === TOK_RBRACE) {\n            this._match(TOK_RBRACE);\n            break;\n          }\n        }\n        return {type: "MultiSelectHash", children: pairs};\n      }\n  };\n\n\n  function TreeInterpreter(runtime) {\n    this.runtime = runtime;\n  }\n\n  TreeInterpreter.prototype = {\n      search: function(node, value) {\n          return this.visit(node, value);\n      },\n\n      visit: function(node, value) {\n          var matched, current, result, first, second, field, left, right, collected, i;\n          switch (node.type) {\n            case "Field":\n              if (value === null ) {\n                  return null;\n              } else if (isObject(value)) {\n                  field = value[node.name];\n                  if (field === undefined) {\n                      return null;\n                  } else {\n                      return field;\n                  }\n              } else {\n                return null;\n              }\n              break;\n            case "Subexpression":\n              result = this.visit(node.children[0], value);\n              for (i = 1; i < node.children.length; i++) {\n                  result = this.visit(node.children[1], result);\n                  if (result === null) {\n                      return null;\n                  }\n              }\n              return result;\n            case "IndexExpression":\n              left = this.visit(node.children[0], value);\n              right = this.visit(node.children[1], left);\n              return right;\n            case "Index":\n              if (!isArray(value)) {\n                return null;\n              }\n              var index = node.value;\n              if (index < 0) {\n                index = value.length + index;\n              }\n              result = value[index];\n              if (result === undefined) {\n                result = null;\n              }\n              return result;\n            case "Slice":\n              if (!isArray(value)) {\n                return null;\n              }\n              var sliceParams = node.children.slice(0);\n              var computed = this.computeSliceParams(value.length, sliceParams);\n              var start = computed[0];\n              var stop = computed[1];\n              var step = computed[2];\n              result = [];\n              if (step > 0) {\n                  for (i = start; i < stop; i += step) {\n                      result.push(value[i]);\n                  }\n              } else {\n                  for (i = start; i > stop; i += step) {\n                      result.push(value[i]);\n                  }\n              }\n              return result;\n            case "Projection":\n              var base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < base.length; i++) {\n                current = this.visit(node.children[1], base[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case "ValueProjection":\n              base = this.visit(node.children[0], value);\n              if (!isObject(base)) {\n                return null;\n              }\n              collected = [];\n              var values = objValues(base);\n              for (i = 0; i < values.length; i++) {\n                current = this.visit(node.children[1], values[i]);\n                if (current !== null) {\n                  collected.push(current);\n                }\n              }\n              return collected;\n            case "FilterProjection":\n              base = this.visit(node.children[0], value);\n              if (!isArray(base)) {\n                return null;\n              }\n              var filtered = [];\n              var finalResults = [];\n              for (i = 0; i < base.length; i++) {\n                matched = this.visit(node.children[2], base[i]);\n                if (!isFalse(matched)) {\n                  filtered.push(base[i]);\n                }\n              }\n              for (var j = 0; j < filtered.length; j++) {\n                current = this.visit(node.children[1], filtered[j]);\n                if (current !== null) {\n                  finalResults.push(current);\n                }\n              }\n              return finalResults;\n            case "Comparator":\n              first = this.visit(node.children[0], value);\n              second = this.visit(node.children[1], value);\n              switch(node.name) {\n                case TOK_EQ:\n                  result = strictDeepEqual(first, second);\n                  break;\n                case TOK_NE:\n                  result = !strictDeepEqual(first, second);\n                  break;\n                case TOK_GT:\n                  result = first > second;\n                  break;\n                case TOK_GTE:\n                  result = first >= second;\n                  break;\n                case TOK_LT:\n                  result = first < second;\n                  break;\n                case TOK_LTE:\n                  result = first <= second;\n                  break;\n                default:\n                  throw new Error("Unknown comparator: " + node.name);\n              }\n              return result;\n            case TOK_FLATTEN:\n              var original = this.visit(node.children[0], value);\n              if (!isArray(original)) {\n                return null;\n              }\n              var merged = [];\n              for (i = 0; i < original.length; i++) {\n                current = original[i];\n                if (isArray(current)) {\n                  merged.push.apply(merged, current);\n                } else {\n                  merged.push(current);\n                }\n              }\n              return merged;\n            case "Identity":\n              return value;\n            case "MultiSelectList":\n              if (value === null) {\n                return null;\n              }\n              collected = [];\n              for (i = 0; i < node.children.length; i++) {\n                  collected.push(this.visit(node.children[i], value));\n              }\n              return collected;\n            case "MultiSelectHash":\n              if (value === null) {\n                return null;\n              }\n              collected = {};\n              var child;\n              for (i = 0; i < node.children.length; i++) {\n                child = node.children[i];\n                collected[child.name] = this.visit(child.value, value);\n              }\n              return collected;\n            case "OrExpression":\n              matched = this.visit(node.children[0], value);\n              if (isFalse(matched)) {\n                  matched = this.visit(node.children[1], value);\n              }\n              return matched;\n            case "AndExpression":\n              first = this.visit(node.children[0], value);\n\n              if (isFalse(first) === true) {\n                return first;\n              }\n              return this.visit(node.children[1], value);\n            case "NotExpression":\n              first = this.visit(node.children[0], value);\n              return isFalse(first);\n            case "Literal":\n              return node.value;\n            case TOK_PIPE:\n              left = this.visit(node.children[0], value);\n              return this.visit(node.children[1], left);\n            case TOK_CURRENT:\n              return value;\n            case "Function":\n              var resolvedArgs = [];\n              for (i = 0; i < node.children.length; i++) {\n                  resolvedArgs.push(this.visit(node.children[i], value));\n              }\n              return this.runtime.callFunction(node.name, resolvedArgs);\n            case "ExpressionReference":\n              var refNode = node.children[0];\n              refNode.jmespathType = TOK_EXPREF;\n              return refNode;\n            default:\n              throw new Error("Unknown node type: " + node.type);\n          }\n      },\n\n      computeSliceParams: function(arrayLength, sliceParams) {\n        var start = sliceParams[0];\n        var stop = sliceParams[1];\n        var step = sliceParams[2];\n        var computed = [null, null, null];\n        if (step === null) {\n          step = 1;\n        } else if (step === 0) {\n          var error = new Error("Invalid slice, step cannot be 0");\n          error.name = "RuntimeError";\n          throw error;\n        }\n        var stepValueNegative = step < 0 ? true : false;\n\n        if (start === null) {\n            start = stepValueNegative ? arrayLength - 1 : 0;\n        } else {\n            start = this.capSliceRange(arrayLength, start, step);\n        }\n\n        if (stop === null) {\n            stop = stepValueNegative ? -1 : arrayLength;\n        } else {\n            stop = this.capSliceRange(arrayLength, stop, step);\n        }\n        computed[0] = start;\n        computed[1] = stop;\n        computed[2] = step;\n        return computed;\n      },\n\n      capSliceRange: function(arrayLength, actualValue, step) {\n          if (actualValue < 0) {\n              actualValue += arrayLength;\n              if (actualValue < 0) {\n                  actualValue = step < 0 ? -1 : 0;\n              }\n          } else if (actualValue >= arrayLength) {\n              actualValue = step < 0 ? arrayLength - 1 : arrayLength;\n          }\n          return actualValue;\n      }\n\n  };\n\n  function Runtime(interpreter) {\n    this._interpreter = interpreter;\n    this.functionTable = {\n        abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},\n        avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},\n        contains: {\n            _func: this._functionContains,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},\n                        {types: [TYPE_ANY]}]},\n        "ends_with": {\n            _func: this._functionEndsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},\n        length: {\n            _func: this._functionLength,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},\n        map: {\n            _func: this._functionMap,\n            _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},\n        max: {\n            _func: this._functionMax,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        "merge": {\n            _func: this._functionMerge,\n            _signature: [{types: [TYPE_OBJECT], variadic: true}]\n        },\n        "max_by": {\n          _func: this._functionMaxBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},\n        "starts_with": {\n            _func: this._functionStartsWith,\n            _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},\n        min: {\n            _func: this._functionMin,\n            _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},\n        "min_by": {\n          _func: this._functionMinBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},\n        keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},\n        values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},\n        sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},\n        "sort_by": {\n          _func: this._functionSortBy,\n          _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]\n        },\n        join: {\n            _func: this._functionJoin,\n            _signature: [\n                {types: [TYPE_STRING]},\n                {types: [TYPE_ARRAY_STRING]}\n            ]\n        },\n        reverse: {\n            _func: this._functionReverse,\n            _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},\n        "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},\n        "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},\n        "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},\n        "not_null": {\n            _func: this._functionNotNull,\n            _signature: [{types: [TYPE_ANY], variadic: true}]\n        }\n    };\n  }\n\n  Runtime.prototype = {\n    callFunction: function(name, resolvedArgs) {\n      var functionEntry = this.functionTable[name];\n      if (functionEntry === undefined) {\n          throw new Error("Unknown function: " + name + "()");\n      }\n      this._validateArgs(name, resolvedArgs, functionEntry._signature);\n      return functionEntry._func.call(this, resolvedArgs);\n    },\n\n    _validateArgs: function(name, args, signature) {\n        var pluralized;\n        if (signature[signature.length - 1].variadic) {\n            if (args.length < signature.length) {\n                pluralized = signature.length === 1 ? " argument" : " arguments";\n                throw new Error("ArgumentError: " + name + "() " +\n                                "takes at least" + signature.length + pluralized +\n                                " but received " + args.length);\n            }\n        } else if (args.length !== signature.length) {\n            pluralized = signature.length === 1 ? " argument" : " arguments";\n            throw new Error("ArgumentError: " + name + "() " +\n                            "takes " + signature.length + pluralized +\n                            " but received " + args.length);\n        }\n        var currentSpec;\n        var actualType;\n        var typeMatched;\n        for (var i = 0; i < signature.length; i++) {\n            typeMatched = false;\n            currentSpec = signature[i].types;\n            actualType = this._getTypeName(args[i]);\n            for (var j = 0; j < currentSpec.length; j++) {\n                if (this._typeMatches(actualType, currentSpec[j], args[i])) {\n                    typeMatched = true;\n                    break;\n                }\n            }\n            if (!typeMatched) {\n                throw new Error("TypeError: " + name + "() " +\n                                "expected argument " + (i + 1) +\n                                " to be type " + currentSpec +\n                                " but received type " + actualType +\n                                " instead.");\n            }\n        }\n    },\n\n    _typeMatches: function(actual, expected, argValue) {\n        if (expected === TYPE_ANY) {\n            return true;\n        }\n        if (expected === TYPE_ARRAY_STRING ||\n            expected === TYPE_ARRAY_NUMBER ||\n            expected === TYPE_ARRAY) {\n            if (expected === TYPE_ARRAY) {\n                return actual === TYPE_ARRAY;\n            } else if (actual === TYPE_ARRAY) {\n                var subtype;\n                if (expected === TYPE_ARRAY_NUMBER) {\n                  subtype = TYPE_NUMBER;\n                } else if (expected === TYPE_ARRAY_STRING) {\n                  subtype = TYPE_STRING;\n                }\n                for (var i = 0; i < argValue.length; i++) {\n                    if (!this._typeMatches(\n                            this._getTypeName(argValue[i]), subtype,\n                                             argValue[i])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        } else {\n            return actual === expected;\n        }\n    },\n    _getTypeName: function(obj) {\n        switch (Object.prototype.toString.call(obj)) {\n            case "[object String]":\n              return TYPE_STRING;\n            case "[object Number]":\n              return TYPE_NUMBER;\n            case "[object Array]":\n              return TYPE_ARRAY;\n            case "[object Boolean]":\n              return TYPE_BOOLEAN;\n            case "[object Null]":\n              return TYPE_NULL;\n            case "[object Object]":\n              if (obj.jmespathType === TOK_EXPREF) {\n                return TYPE_EXPREF;\n              } else {\n                return TYPE_OBJECT;\n              }\n        }\n    },\n\n    _functionStartsWith: function(resolvedArgs) {\n        return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;\n    },\n\n    _functionEndsWith: function(resolvedArgs) {\n        var searchStr = resolvedArgs[0];\n        var suffix = resolvedArgs[1];\n        return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;\n    },\n\n    _functionReverse: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        if (typeName === TYPE_STRING) {\n          var originalStr = resolvedArgs[0];\n          var reversedStr = "";\n          for (var i = originalStr.length - 1; i >= 0; i--) {\n              reversedStr += originalStr[i];\n          }\n          return reversedStr;\n        } else {\n          var reversedArray = resolvedArgs[0].slice(0);\n          reversedArray.reverse();\n          return reversedArray;\n        }\n    },\n\n    _functionAbs: function(resolvedArgs) {\n      return Math.abs(resolvedArgs[0]);\n    },\n\n    _functionCeil: function(resolvedArgs) {\n        return Math.ceil(resolvedArgs[0]);\n    },\n\n    _functionAvg: function(resolvedArgs) {\n        var sum = 0;\n        var inputArray = resolvedArgs[0];\n        for (var i = 0; i < inputArray.length; i++) {\n            sum += inputArray[i];\n        }\n        return sum / inputArray.length;\n    },\n\n    _functionContains: function(resolvedArgs) {\n        return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;\n    },\n\n    _functionFloor: function(resolvedArgs) {\n        return Math.floor(resolvedArgs[0]);\n    },\n\n    _functionLength: function(resolvedArgs) {\n       if (!isObject(resolvedArgs[0])) {\n         return resolvedArgs[0].length;\n       } else {\n         return Object.keys(resolvedArgs[0]).length;\n       }\n    },\n\n    _functionMap: function(resolvedArgs) {\n      var mapped = [];\n      var interpreter = this._interpreter;\n      var exprefNode = resolvedArgs[0];\n      var elements = resolvedArgs[1];\n      for (var i = 0; i < elements.length; i++) {\n          mapped.push(interpreter.visit(exprefNode, elements[i]));\n      }\n      return mapped;\n    },\n\n    _functionMerge: function(resolvedArgs) {\n      var merged = {};\n      for (var i = 0; i < resolvedArgs.length; i++) {\n        var current = resolvedArgs[i];\n        for (var key in current) {\n          merged[key] = current[key];\n        }\n      }\n      return merged;\n    },\n\n    _functionMax: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.max.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var maxElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (maxElement.localeCompare(elements[i]) < 0) {\n                  maxElement = elements[i];\n              }\n          }\n          return maxElement;\n        }\n      } else {\n          return null;\n      }\n    },\n\n    _functionMin: function(resolvedArgs) {\n      if (resolvedArgs[0].length > 0) {\n        var typeName = this._getTypeName(resolvedArgs[0][0]);\n        if (typeName === TYPE_NUMBER) {\n          return Math.min.apply(Math, resolvedArgs[0]);\n        } else {\n          var elements = resolvedArgs[0];\n          var minElement = elements[0];\n          for (var i = 1; i < elements.length; i++) {\n              if (elements[i].localeCompare(minElement) < 0) {\n                  minElement = elements[i];\n              }\n          }\n          return minElement;\n        }\n      } else {\n        return null;\n      }\n    },\n\n    _functionSum: function(resolvedArgs) {\n      var sum = 0;\n      var listToSum = resolvedArgs[0];\n      for (var i = 0; i < listToSum.length; i++) {\n        sum += listToSum[i];\n      }\n      return sum;\n    },\n\n    _functionType: function(resolvedArgs) {\n        switch (this._getTypeName(resolvedArgs[0])) {\n          case TYPE_NUMBER:\n            return "number";\n          case TYPE_STRING:\n            return "string";\n          case TYPE_ARRAY:\n            return "array";\n          case TYPE_OBJECT:\n            return "object";\n          case TYPE_BOOLEAN:\n            return "boolean";\n          case TYPE_EXPREF:\n            return "expref";\n          case TYPE_NULL:\n            return "null";\n        }\n    },\n\n    _functionKeys: function(resolvedArgs) {\n        return Object.keys(resolvedArgs[0]);\n    },\n\n    _functionValues: function(resolvedArgs) {\n        var obj = resolvedArgs[0];\n        var keys = Object.keys(obj);\n        var values = [];\n        for (var i = 0; i < keys.length; i++) {\n            values.push(obj[keys[i]]);\n        }\n        return values;\n    },\n\n    _functionJoin: function(resolvedArgs) {\n        var joinChar = resolvedArgs[0];\n        var listJoin = resolvedArgs[1];\n        return listJoin.join(joinChar);\n    },\n\n    _functionToArray: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {\n            return resolvedArgs[0];\n        } else {\n            return [resolvedArgs[0]];\n        }\n    },\n\n    _functionToString: function(resolvedArgs) {\n        if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {\n            return resolvedArgs[0];\n        } else {\n            return JSON.stringify(resolvedArgs[0]);\n        }\n    },\n\n    _functionToNumber: function(resolvedArgs) {\n        var typeName = this._getTypeName(resolvedArgs[0]);\n        var convertedValue;\n        if (typeName === TYPE_NUMBER) {\n            return resolvedArgs[0];\n        } else if (typeName === TYPE_STRING) {\n            convertedValue = +resolvedArgs[0];\n            if (!isNaN(convertedValue)) {\n                return convertedValue;\n            }\n        }\n        return null;\n    },\n\n    _functionNotNull: function(resolvedArgs) {\n        for (var i = 0; i < resolvedArgs.length; i++) {\n            if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {\n                return resolvedArgs[i];\n            }\n        }\n        return null;\n    },\n\n    _functionSort: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        sortedArray.sort();\n        return sortedArray;\n    },\n\n    _functionSortBy: function(resolvedArgs) {\n        var sortedArray = resolvedArgs[0].slice(0);\n        if (sortedArray.length === 0) {\n            return sortedArray;\n        }\n        var interpreter = this._interpreter;\n        var exprefNode = resolvedArgs[1];\n        var requiredType = this._getTypeName(\n            interpreter.visit(exprefNode, sortedArray[0]));\n        if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {\n            throw new Error("TypeError");\n        }\n        var that = this;\n        var decorated = [];\n        for (var i = 0; i < sortedArray.length; i++) {\n          decorated.push([i, sortedArray[i]]);\n        }\n        decorated.sort(function(a, b) {\n          var exprA = interpreter.visit(exprefNode, a[1]);\n          var exprB = interpreter.visit(exprefNode, b[1]);\n          if (that._getTypeName(exprA) !== requiredType) {\n              throw new Error(\n                  "TypeError: expected " + requiredType + ", received " +\n                  that._getTypeName(exprA));\n          } else if (that._getTypeName(exprB) !== requiredType) {\n              throw new Error(\n                  "TypeError: expected " + requiredType + ", received " +\n                  that._getTypeName(exprB));\n          }\n          if (exprA > exprB) {\n            return 1;\n          } else if (exprA < exprB) {\n            return -1;\n          } else {\n            return a[0] - b[0];\n          }\n        });\n        for (var j = 0; j < decorated.length; j++) {\n          sortedArray[j] = decorated[j][1];\n        }\n        return sortedArray;\n    },\n\n    _functionMaxBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var maxNumber = -Infinity;\n      var maxRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current > maxNumber) {\n          maxNumber = current;\n          maxRecord = resolvedArray[i];\n        }\n      }\n      return maxRecord;\n    },\n\n    _functionMinBy: function(resolvedArgs) {\n      var exprefNode = resolvedArgs[1];\n      var resolvedArray = resolvedArgs[0];\n      var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);\n      var minNumber = Infinity;\n      var minRecord;\n      var current;\n      for (var i = 0; i < resolvedArray.length; i++) {\n        current = keyFunction(resolvedArray[i]);\n        if (current < minNumber) {\n          minNumber = current;\n          minRecord = resolvedArray[i];\n        }\n      }\n      return minRecord;\n    },\n\n    createKeyFunction: function(exprefNode, allowedTypes) {\n      var that = this;\n      var interpreter = this._interpreter;\n      var keyFunc = function(x) {\n        var current = interpreter.visit(exprefNode, x);\n        if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {\n          var msg = "TypeError: expected one of " + allowedTypes +\n                    ", received " + that._getTypeName(current);\n          throw new Error(msg);\n        }\n        return current;\n      };\n      return keyFunc;\n    }\n\n  };\n\n  function compile(stream) {\n    var parser = new Parser();\n    var ast = parser.parse(stream);\n    return ast;\n  }\n\n  function tokenize(stream) {\n      var lexer = new Lexer();\n      return lexer.tokenize(stream);\n  }\n\n  function search(data, expression) {\n      var parser = new Parser();\n      var runtime = new Runtime();\n      var interpreter = new TreeInterpreter(runtime);\n      runtime._interpreter = interpreter;\n      var node = parser.parse(expression);\n      return interpreter.search(node, data);\n  }\n\n  exports.tokenize = tokenize;\n  exports.compile = compile;\n  exports.search = search;\n  exports.strictDeepEqual = strictDeepEqual;\n})(typeof exports === "undefined" ? this.jmespath = {} : exports);\n\n},{}],69:[function(require,module,exports){\nvar arrayEvery = require(\'../internal/arrayEvery\'),\n    baseCallback = require(\'../internal/baseCallback\'),\n    baseEvery = require(\'../internal/baseEvery\'),\n    isArray = require(\'../lang/isArray\');\n\n\nfunction every(collection, predicate, thisArg) {\n  var func = isArray(collection) ? arrayEvery : baseEvery;\n  if (typeof predicate != \'function\' || typeof thisArg != \'undefined\') {\n    predicate = baseCallback(predicate, thisArg, 3);\n  }\n  return func(collection, predicate);\n}\n\nmodule.exports = every;\n\n},{"../internal/arrayEvery":70,"../internal/baseCallback":72,"../internal/baseEvery":76,"../lang/isArray":103}],70:[function(require,module,exports){\n\nfunction arrayEvery(array, predicate) {\n  var index = -1,\n      length = array.length;\n\n  while (++index < length) {\n    if (!predicate(array[index], index, array)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = arrayEvery;\n\n},{}],71:[function(require,module,exports){\nvar baseCopy = require(\'./baseCopy\'),\n    keys = require(\'../object/keys\');\n\n\nfunction baseAssign(object, source, customizer) {\n  var props = keys(source);\n  if (!customizer) {\n    return baseCopy(source, object, props);\n  }\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index],\n        value = object[key],\n        result = customizer(value, source[key], key, object, source);\n\n    if ((result === result ? (result !== value) : (value === value)) ||\n        (typeof value == \'undefined\' && !(key in object))) {\n      object[key] = result;\n    }\n  }\n  return object;\n}\n\nmodule.exports = baseAssign;\n\n},{"../object/keys":112,"./baseCopy":73}],72:[function(require,module,exports){\nvar baseMatches = require(\'./baseMatches\'),\n    baseMatchesProperty = require(\'./baseMatchesProperty\'),\n    baseProperty = require(\'./baseProperty\'),\n    bindCallback = require(\'./bindCallback\'),\n    identity = require(\'../utility/identity\'),\n    isBindable = require(\'./isBindable\');\n\n\nfunction baseCallback(func, thisArg, argCount) {\n  var type = typeof func;\n  if (type == \'function\') {\n    return (typeof thisArg != \'undefined\' && isBindable(func))\n      ? bindCallback(func, thisArg, argCount)\n      : func;\n  }\n  if (func == null) {\n    return identity;\n  }\n  if (type == \'object\') {\n    return baseMatches(func);\n  }\n  return typeof thisArg == \'undefined\'\n    ? baseProperty(func + \'\')\n    : baseMatchesProperty(func + \'\', thisArg);\n}\n\nmodule.exports = baseCallback;\n\n},{"../utility/identity":116,"./baseMatches":83,"./baseMatchesProperty":84,"./baseProperty":85,"./bindCallback":88,"./isBindable":93}],73:[function(require,module,exports){\n\nfunction baseCopy(source, object, props) {\n  if (!props) {\n    props = object;\n    object = {};\n  }\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    object[key] = source[key];\n  }\n  return object;\n}\n\nmodule.exports = baseCopy;\n\n},{}],74:[function(require,module,exports){\n(function (global){\nvar isObject = require(\'../lang/isObject\');\n\n\nvar baseCreate = (function() {\n  function Object() {}\n  return function(prototype) {\n    if (isObject(prototype)) {\n      Object.prototype = prototype;\n      var result = new Object;\n      Object.prototype = null;\n    }\n    return result || global.Object();\n  };\n}());\n\nmodule.exports = baseCreate;\n\n}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{"../lang/isObject":107}],75:[function(require,module,exports){\nvar baseForOwn = require(\'./baseForOwn\'),\n    isLength = require(\'./isLength\'),\n    toObject = require(\'./toObject\');\n\n\nfunction baseEach(collection, iteratee) {\n  var length = collection ? collection.length : 0;\n  if (!isLength(length)) {\n    return baseForOwn(collection, iteratee);\n  }\n  var index = -1,\n      iterable = toObject(collection);\n\n  while (++index < length) {\n    if (iteratee(iterable[index], index, iterable) === false) {\n      break;\n    }\n  }\n  return collection;\n}\n\nmodule.exports = baseEach;\n\n},{"./baseForOwn":78,"./isLength":96,"./toObject":101}],76:[function(require,module,exports){\nvar baseEach = require(\'./baseEach\');\n\n\nfunction baseEvery(collection, predicate) {\n  var result = true;\n  baseEach(collection, function(value, index, collection) {\n    result = !!predicate(value, index, collection);\n    return result;\n  });\n  return result;\n}\n\nmodule.exports = baseEvery;\n\n},{"./baseEach":75}],77:[function(require,module,exports){\nvar toObject = require(\'./toObject\');\n\n\nfunction baseFor(object, iteratee, keysFunc) {\n  var index = -1,\n      iterable = toObject(object),\n      props = keysFunc(object),\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n    if (iteratee(iterable[key], key, iterable) === false) {\n      break;\n    }\n  }\n  return object;\n}\n\nmodule.exports = baseFor;\n\n},{"./toObject":101}],78:[function(require,module,exports){\nvar baseFor = require(\'./baseFor\'),\n    keys = require(\'../object/keys\');\n\n\nfunction baseForOwn(object, iteratee) {\n  return baseFor(object, iteratee, keys);\n}\n\nmodule.exports = baseForOwn;\n\n},{"../object/keys":112,"./baseFor":77}],79:[function(require,module,exports){\nvar baseIsEqualDeep = require(\'./baseIsEqualDeep\');\n\n\nfunction baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {\n  if (value === other) {\n    return value !== 0 || (1 / value == 1 / other);\n  }\n  var valType = typeof value,\n      othType = typeof other;\n\n  if ((valType != \'function\' && valType != \'object\' && othType != \'function\' && othType != \'object\') ||\n      value == null || other == null) {\n    return value !== value && other !== other;\n  }\n  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);\n}\n\nmodule.exports = baseIsEqual;\n\n},{"./baseIsEqualDeep":80}],80:[function(require,module,exports){\nvar equalArrays = require(\'./equalArrays\'),\n    equalByTag = require(\'./equalByTag\'),\n    equalObjects = require(\'./equalObjects\'),\n    isArray = require(\'../lang/isArray\'),\n    isTypedArray = require(\'../lang/isTypedArray\');\n\n\nvar argsTag = \'[object Arguments]\',\n    arrayTag = \'[object Array]\',\n    objectTag = \'[object Object]\';\n\n\nvar objectProto = Object.prototype;\n\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\nvar objToString = objectProto.toString;\n\n\nfunction baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {\n  var objIsArr = isArray(object),\n      othIsArr = isArray(other),\n      objTag = arrayTag,\n      othTag = arrayTag;\n\n  if (!objIsArr) {\n    objTag = objToString.call(object);\n    if (objTag == argsTag) {\n      objTag = objectTag;\n    } else if (objTag != objectTag) {\n      objIsArr = isTypedArray(object);\n    }\n  }\n  if (!othIsArr) {\n    othTag = objToString.call(other);\n    if (othTag == argsTag) {\n      othTag = objectTag;\n    } else if (othTag != objectTag) {\n      othIsArr = isTypedArray(other);\n    }\n  }\n  var objIsObj = objTag == objectTag,\n      othIsObj = othTag == objectTag,\n      isSameTag = objTag == othTag;\n\n  if (isSameTag && !(objIsArr || objIsObj)) {\n    return equalByTag(object, other, objTag);\n  }\n  var valWrapped = objIsObj && hasOwnProperty.call(object, \'__wrapped__\'),\n      othWrapped = othIsObj && hasOwnProperty.call(other, \'__wrapped__\');\n\n  if (valWrapped || othWrapped) {\n    return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);\n  }\n  if (!isSameTag) {\n    return false;\n  }\n  stackA || (stackA = []);\n  stackB || (stackB = []);\n\n  var length = stackA.length;\n  while (length--) {\n    if (stackA[length] == object) {\n      return stackB[length] == other;\n    }\n  }\n  stackA.push(object);\n  stackB.push(other);\n\n  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);\n\n  stackA.pop();\n  stackB.pop();\n\n  return result;\n}\n\nmodule.exports = baseIsEqualDeep;\n\n},{"../lang/isArray":103,"../lang/isTypedArray":109,"./equalArrays":90,"./equalByTag":91,"./equalObjects":92}],81:[function(require,module,exports){\n\nfunction baseIsFunction(value) {\n  return typeof value == \'function\' || false;\n}\n\nmodule.exports = baseIsFunction;\n\n},{}],82:[function(require,module,exports){\nvar baseIsEqual = require(\'./baseIsEqual\');\n\n\nvar objectProto = Object.prototype;\n\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\nfunction baseIsMatch(object, props, values, strictCompareFlags, customizer) {\n  var length = props.length;\n  if (object == null) {\n    return !length;\n  }\n  var index = -1,\n      noCustomizer = !customizer;\n\n  while (++index < length) {\n    if ((noCustomizer && strictCompareFlags[index])\n          ? values[index] !== object[props[index]]\n          : !hasOwnProperty.call(object, props[index])\n        ) {\n      return false;\n    }\n  }\n  index = -1;\n  while (++index < length) {\n    var key = props[index];\n    if (noCustomizer && strictCompareFlags[index]) {\n      var result = hasOwnProperty.call(object, key);\n    } else {\n      var objValue = object[key],\n          srcValue = values[index];\n\n      result = customizer ? customizer(objValue, srcValue, key) : undefined;\n      if (typeof result == \'undefined\') {\n        result = baseIsEqual(srcValue, objValue, customizer, true);\n      }\n    }\n    if (!result) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = baseIsMatch;\n\n},{"./baseIsEqual":79}],83:[function(require,module,exports){\nvar baseIsMatch = require(\'./baseIsMatch\'),\n    isStrictComparable = require(\'./isStrictComparable\'),\n    keys = require(\'../object/keys\');\n\n\nvar objectProto = Object.prototype;\n\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\nfunction baseMatches(source) {\n  var props = keys(source),\n      length = props.length;\n\n  if (length == 1) {\n    var key = props[0],\n        value = source[key];\n\n    if (isStrictComparable(value)) {\n      return function(object) {\n        return object != null && object[key] === value && hasOwnProperty.call(object, key);\n      };\n    }\n  }\n  var values = Array(length),\n      strictCompareFlags = Array(length);\n\n  while (length--) {\n    value = source[props[length]];\n    values[length] = value;\n    strictCompareFlags[length] = isStrictComparable(value);\n  }\n  return function(object) {\n    return baseIsMatch(object, props, values, strictCompareFlags);\n  };\n}\n\nmodule.exports = baseMatches;\n\n},{"../object/keys":112,"./baseIsMatch":82,"./isStrictComparable":98}],84:[function(require,module,exports){\nvar baseIsEqual = require(\'./baseIsEqual\'),\n    isStrictComparable = require(\'./isStrictComparable\');\n\n\nfunction baseMatchesProperty(key, value) {\n  if (isStrictComparable(value)) {\n    return function(object) {\n      return object != null && object[key] === value;\n    };\n  }\n  return function(object) {\n    return object != null && baseIsEqual(value, object[key], null, true);\n  };\n}\n\nmodule.exports = baseMatchesProperty;\n\n},{"./baseIsEqual":79,"./isStrictComparable":98}],85:[function(require,module,exports){\n\nfunction baseProperty(key) {\n  return function(object) {\n    return object == null ? undefined : object[key];\n  };\n}\n\nmodule.exports = baseProperty;\n\n},{}],86:[function(require,module,exports){\nvar identity = require(\'../utility/identity\'),\n    metaMap = require(\'./metaMap\');\n\n\nvar baseSetData = !metaMap ? identity : function(func, data) {\n  metaMap.set(func, data);\n  return func;\n};\n\nmodule.exports = baseSetData;\n\n},{"../utility/identity":116,"./metaMap":99}],87:[function(require,module,exports){\n\nfunction baseToString(value) {\n  if (typeof value == \'string\') {\n    return value;\n  }\n  return value == null ? \'\' : (value + \'\');\n}\n\nmodule.exports = baseToString;\n\n},{}],88:[function(require,module,exports){\nvar identity = require(\'../utility/identity\');\n\n\nfunction bindCallback(func, thisArg, argCount) {\n  if (typeof func != \'function\') {\n    return identity;\n  }\n  if (typeof thisArg == \'undefined\') {\n    return func;\n  }\n  switch (argCount) {\n    case 1: return function(value) {\n      return func.call(thisArg, value);\n    };\n    case 3: return function(value, index, collection) {\n      return func.call(thisArg, value, index, collection);\n    };\n    case 4: return function(accumulator, value, index, collection) {\n      return func.call(thisArg, accumulator, value, index, collection);\n    };\n    case 5: return function(value, other, key, object, source) {\n      return func.call(thisArg, value, other, key, object, source);\n    };\n  }\n  return function() {\n    return func.apply(thisArg, arguments);\n  };\n}\n\nmodule.exports = bindCallback;\n\n},{"../utility/identity":116}],89:[function(require,module,exports){\nvar bindCallback = require(\'./bindCallback\'),\n    isIterateeCall = require(\'./isIterateeCall\');\n\n\nfunction createAssigner(assigner) {\n  return function() {\n    var args = arguments,\n        length = args.length,\n        object = args[0];\n\n    if (length < 2 || object == null) {\n      return object;\n    }\n    var customizer = args[length - 2],\n        thisArg = args[length - 1],\n        guard = args[3];\n\n    if (length > 3 && typeof customizer == \'function\') {\n      customizer = bindCallback(customizer, thisArg, 5);\n      length -= 2;\n    } else {\n      customizer = (length > 2 && typeof thisArg == \'function\') ? thisArg : null;\n      length -= (customizer ? 1 : 0);\n    }\n    if (guard && isIterateeCall(args[1], args[2], guard)) {\n      customizer = length == 3 ? null : customizer;\n      length = 2;\n    }\n    var index = 0;\n    while (++index < length) {\n      var source = args[index];\n      if (source) {\n        assigner(object, source, customizer);\n      }\n    }\n    return object;\n  };\n}\n\nmodule.exports = createAssigner;\n\n},{"./bindCallback":88,"./isIterateeCall":95}],90:[function(require,module,exports){\n\nfunction equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {\n  var index = -1,\n      arrLength = array.length,\n      othLength = other.length,\n      result = true;\n\n  if (arrLength != othLength && !(isWhere && othLength > arrLength)) {\n    return false;\n  }\n  while (result && ++index < arrLength) {\n    var arrValue = array[index],\n        othValue = other[index];\n\n    result = undefined;\n    if (customizer) {\n      result = isWhere\n        ? customizer(othValue, arrValue, index)\n        : customizer(arrValue, othValue, index);\n    }\n    if (typeof result == \'undefined\') {\n      if (isWhere) {\n        var othIndex = othLength;\n        while (othIndex--) {\n          othValue = other[othIndex];\n          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);\n          if (result) {\n            break;\n          }\n        }\n      } else {\n        result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);\n      }\n    }\n  }\n  return !!result;\n}\n\nmodule.exports = equalArrays;\n\n},{}],91:[function(require,module,exports){\n\nvar boolTag = \'[object Boolean]\',\n    dateTag = \'[object Date]\',\n    errorTag = \'[object Error]\',\n    numberTag = \'[object Number]\',\n    regexpTag = \'[object RegExp]\',\n    stringTag = \'[object String]\';\n\n\nfunction equalByTag(object, other, tag) {\n  switch (tag) {\n    case boolTag:\n    case dateTag:\n      return +object == +other;\n\n    case errorTag:\n      return object.name == other.name && object.message == other.message;\n\n    case numberTag:\n      return (object != +object)\n        ? other != +other\n        : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);\n\n    case regexpTag:\n    case stringTag:\n      return object == (other + \'\');\n  }\n  return false;\n}\n\nmodule.exports = equalByTag;\n\n},{}],92:[function(require,module,exports){\nvar keys = require(\'../object/keys\');\n\n\nvar objectProto = Object.prototype;\n\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\nfunction equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {\n  var objProps = keys(object),\n      objLength = objProps.length,\n      othProps = keys(other),\n      othLength = othProps.length;\n\n  if (objLength != othLength && !isWhere) {\n    return false;\n  }\n  var hasCtor,\n      index = -1;\n\n  while (++index < objLength) {\n    var key = objProps[index],\n        result = hasOwnProperty.call(other, key);\n\n    if (result) {\n      var objValue = object[key],\n          othValue = other[key];\n\n      result = undefined;\n      if (customizer) {\n        result = isWhere\n          ? customizer(othValue, objValue, key)\n          : customizer(objValue, othValue, key);\n      }\n      if (typeof result == \'undefined\') {\n        result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);\n      }\n    }\n    if (!result) {\n      return false;\n    }\n    hasCtor || (hasCtor = key == \'constructor\');\n  }\n  if (!hasCtor) {\n    var objCtor = object.constructor,\n        othCtor = other.constructor;\n\n    if (objCtor != othCtor &&\n        (\'constructor\' in object && \'constructor\' in other) &&\n        !(typeof objCtor == \'function\' && objCtor instanceof objCtor &&\n          typeof othCtor == \'function\' && othCtor instanceof othCtor)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nmodule.exports = equalObjects;\n\n},{"../object/keys":112}],93:[function(require,module,exports){\nvar baseSetData = require(\'./baseSetData\'),\n    isNative = require(\'../lang/isNative\'),\n    support = require(\'../support\');\n\n\nvar reFuncName = /^\\s*function[ \\n\\r\\t]+\\w/;\n\n\nvar reThis = /\\bthis\\b/;\n\n\nvar fnToString = Function.prototype.toString;\n\n\nfunction isBindable(func) {\n  var result = !(support.funcNames ? func.name : support.funcDecomp);\n\n  if (!result) {\n    var source = fnToString.call(func);\n    if (!support.funcNames) {\n      result = !reFuncName.test(source);\n    }\n    if (!result) {\n      result = reThis.test(source) || isNative(func);\n      baseSetData(func, result);\n    }\n  }\n  return result;\n}\n\nmodule.exports = isBindable;\n\n},{"../lang/isNative":106,"../support":115,"./baseSetData":86}],94:[function(require,module,exports){\n\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n\nfunction isIndex(value, length) {\n  value = +value;\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return value > -1 && value % 1 == 0 && value < length;\n}\n\nmodule.exports = isIndex;\n\n},{}],95:[function(require,module,exports){\nvar isIndex = require(\'./isIndex\'),\n    isLength = require(\'./isLength\'),\n    isObject = require(\'../lang/isObject\');\n\n\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == \'number\') {\n    var length = object.length,\n        prereq = isLength(length) && isIndex(index, length);\n  } else {\n    prereq = type == \'string\' && index in object;\n  }\n  if (prereq) {\n    var other = object[index];\n    return value === value ? (value === other) : (other !== other);\n  }\n  return false;\n}\n\nmodule.exports = isIterateeCall;\n\n},{"../lang/isObject":107,"./isIndex":94,"./isLength":96}],96:[function(require,module,exports){\n\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n\nfunction isLength(value) {\n  return typeof value == \'number\' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\nmodule.exports = isLength;\n\n},{}],97:[function(require,module,exports){\n\nfunction isObjectLike(value) {\n  return (value && typeof value == \'object\') || false;\n}\n\nmodule.exports = isObjectLike;\n\n},{}],98:[function(require,module,exports){\nvar isObject = require(\'../lang/isObject\');\n\n\nfunction isStrictComparable(value) {\n  return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));\n}\n\nmodule.exports = isStrictComparable;\n\n},{"../lang/isObject":107}],99:[function(require,module,exports){\n(function (global){\nvar isNative = require(\'../lang/isNative\');\n\n\nvar WeakMap = isNative(WeakMap = global.WeakMap) && WeakMap;\n\n\nvar metaMap = WeakMap && new WeakMap;\n\nmodule.exports = metaMap;\n\n}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{"../lang/isNative":106}],100:[function(require,module,exports){\nvar isArguments = require(\'../lang/isArguments\'),\n    isArray = require(\'../lang/isArray\'),\n    isIndex = require(\'./isIndex\'),\n    isLength = require(\'./isLength\'),\n    keysIn = require(\'../object/keysIn\'),\n    support = require(\'../support\');\n\n\nvar objectProto = Object.prototype;\n\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\nfunction shimKeys(object) {\n  var props = keysIn(object),\n      propsLength = props.length,\n      length = propsLength && object.length;\n\n  var allowIndexes = length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object)));\n\n  var index = -1,\n      result = [];\n\n  while (++index < propsLength) {\n    var key = props[index];\n    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = shimKeys;\n\n},{"../lang/isArguments":102,"../lang/isArray":103,"../object/keysIn":113,"../support":115,"./isIndex":94,"./isLength":96}],101:[function(require,module,exports){\nvar isObject = require(\'../lang/isObject\');\n\n\nfunction toObject(value) {\n  return isObject(value) ? value : Object(value);\n}\n\nmodule.exports = toObject;\n\n},{"../lang/isObject":107}],102:[function(require,module,exports){\nvar isLength = require(\'../internal/isLength\'),\n    isObjectLike = require(\'../internal/isObjectLike\');\n\n\nvar argsTag = \'[object Arguments]\';\n\n\nvar objectProto = Object.prototype;\n\n\nvar objToString = objectProto.toString;\n\n\nfunction isArguments(value) {\n  var length = isObjectLike(value) ? value.length : undefined;\n  return (isLength(length) && objToString.call(value) == argsTag) || false;\n}\n\nmodule.exports = isArguments;\n\n},{"../internal/isLength":96,"../internal/isObjectLike":97}],103:[function(require,module,exports){\nvar isLength = require(\'../internal/isLength\'),\n    isNative = require(\'./isNative\'),\n    isObjectLike = require(\'../internal/isObjectLike\');\n\n\nvar arrayTag = \'[object Array]\';\n\n\nvar objectProto = Object.prototype;\n\n\nvar objToString = objectProto.toString;\n\n\nvar nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray;\n\n\nvar isArray = nativeIsArray || function(value) {\n  return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;\n};\n\nmodule.exports = isArray;\n\n},{"../internal/isLength":96,"../internal/isObjectLike":97,"./isNative":106}],104:[function(require,module,exports){\nvar isArguments = require(\'./isArguments\'),\n    isArray = require(\'./isArray\'),\n    isFunction = require(\'./isFunction\'),\n    isLength = require(\'../internal/isLength\'),\n    isObjectLike = require(\'../internal/isObjectLike\'),\n    isString = require(\'./isString\'),\n    keys = require(\'../object/keys\');\n\n\nfunction isEmpty(value) {\n  if (value == null) {\n    return true;\n  }\n  var length = value.length;\n  if (isLength(length) && (isArray(value) || isString(value) || isArguments(value) ||\n      (isObjectLike(value) && isFunction(value.splice)))) {\n    return !length;\n  }\n  return !keys(value).length;\n}\n\nmodule.exports = isEmpty;\n\n},{"../internal/isLength":96,"../internal/isObjectLike":97,"../object/keys":112,"./isArguments":102,"./isArray":103,"./isFunction":105,"./isString":108}],105:[function(require,module,exports){\n(function (global){\nvar baseIsFunction = require(\'../internal/baseIsFunction\'),\n    isNative = require(\'./isNative\');\n\n\nvar funcTag = \'[object Function]\';\n\n\nvar objectProto = Object.prototype;\n\n\nvar objToString = objectProto.toString;\n\n\nvar Uint8Array = isNative(Uint8Array = global.Uint8Array) && Uint8Array;\n\n\nvar isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {\n  return objToString.call(value) == funcTag;\n};\n\nmodule.exports = isFunction;\n\n}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{"../internal/baseIsFunction":81,"./isNative":106}],106:[function(require,module,exports){\nvar escapeRegExp = require(\'../string/escapeRegExp\'),\n    isObjectLike = require(\'../internal/isObjectLike\');\n\n\nvar funcTag = \'[object Function]\';\n\n\nvar reHostCtor = /^\\[object .+?Constructor\\]$/;\n\n\nvar objectProto = Object.prototype;\n\n\nvar fnToString = Function.prototype.toString;\n\n\nvar objToString = objectProto.toString;\n\n\nvar reNative = RegExp(\'^\' +\n  escapeRegExp(objToString)\n  .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \'$1.*?\') + \'$\'\n);\n\n\nfunction isNative(value) {\n  if (value == null) {\n    return false;\n  }\n  if (objToString.call(value) == funcTag) {\n    return reNative.test(fnToString.call(value));\n  }\n  return (isObjectLike(value) && reHostCtor.test(value)) || false;\n}\n\nmodule.exports = isNative;\n\n},{"../internal/isObjectLike":97,"../string/escapeRegExp":114}],107:[function(require,module,exports){\n\nfunction isObject(value) {\n  var type = typeof value;\n  return type == \'function\' || (value && type == \'object\') || false;\n}\n\nmodule.exports = isObject;\n\n},{}],108:[function(require,module,exports){\nvar isObjectLike = require(\'../internal/isObjectLike\');\n\n\nvar stringTag = \'[object String]\';\n\n\nvar objectProto = Object.prototype;\n\n\nvar objToString = objectProto.toString;\n\n\nfunction isString(value) {\n  return typeof value == \'string\' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;\n}\n\nmodule.exports = isString;\n\n},{"../internal/isObjectLike":97}],109:[function(require,module,exports){\nvar isLength = require(\'../internal/isLength\'),\n    isObjectLike = require(\'../internal/isObjectLike\');\n\n\nvar argsTag = \'[object Arguments]\',\n    arrayTag = \'[object Array]\',\n    boolTag = \'[object Boolean]\',\n    dateTag = \'[object Date]\',\n    errorTag = \'[object Error]\',\n    funcTag = \'[object Function]\',\n    mapTag = \'[object Map]\',\n    numberTag = \'[object Number]\',\n    objectTag = \'[object Object]\',\n    regexpTag = \'[object RegExp]\',\n    setTag = \'[object Set]\',\n    stringTag = \'[object String]\',\n    weakMapTag = \'[object WeakMap]\';\n\nvar arrayBufferTag = \'[object ArrayBuffer]\',\n    float32Tag = \'[object Float32Array]\',\n    float64Tag = \'[object Float64Array]\',\n    int8Tag = \'[object Int8Array]\',\n    int16Tag = \'[object Int16Array]\',\n    int32Tag = \'[object Int32Array]\',\n    uint8Tag = \'[object Uint8Array]\',\n    uint8ClampedTag = \'[object Uint8ClampedArray]\',\n    uint16Tag = \'[object Uint16Array]\',\n    uint32Tag = \'[object Uint32Array]\';\n\n\nvar typedArrayTags = {};\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\ntypedArrayTags[uint32Tag] = true;\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\ntypedArrayTags[dateTag] = typedArrayTags[errorTag] =\ntypedArrayTags[funcTag] = typedArrayTags[mapTag] =\ntypedArrayTags[numberTag] = typedArrayTags[objectTag] =\ntypedArrayTags[regexpTag] = typedArrayTags[setTag] =\ntypedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n\n\nvar objectProto = Object.prototype;\n\n\nvar objToString = objectProto.toString;\n\n\nfunction isTypedArray(value) {\n  return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;\n}\n\nmodule.exports = isTypedArray;\n\n},{"../internal/isLength":96,"../internal/isObjectLike":97}],110:[function(require,module,exports){\nvar baseAssign = require(\'../internal/baseAssign\'),\n    createAssigner = require(\'../internal/createAssigner\');\n\n\nvar assign = createAssigner(baseAssign);\n\nmodule.exports = assign;\n\n},{"../internal/baseAssign":71,"../internal/createAssigner":89}],111:[function(require,module,exports){\nvar baseCopy = require(\'../internal/baseCopy\'),\n    baseCreate = require(\'../internal/baseCreate\'),\n    isIterateeCall = require(\'../internal/isIterateeCall\'),\n    keys = require(\'./keys\');\n\n\nfunction create(prototype, properties, guard) {\n  var result = baseCreate(prototype);\n  if (guard && isIterateeCall(prototype, properties, guard)) {\n    properties = null;\n  }\n  return properties ? baseCopy(properties, result, keys(properties)) : result;\n}\n\nmodule.exports = create;\n\n},{"../internal/baseCopy":73,"../internal/baseCreate":74,"../internal/isIterateeCall":95,"./keys":112}],112:[function(require,module,exports){\nvar isLength = require(\'../internal/isLength\'),\n    isNative = require(\'../lang/isNative\'),\n    isObject = require(\'../lang/isObject\'),\n    shimKeys = require(\'../internal/shimKeys\');\n\n\nvar nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys;\n\n\nvar keys = !nativeKeys ? shimKeys : function(object) {\n  if (object) {\n    var Ctor = object.constructor,\n        length = object.length;\n  }\n  if ((typeof Ctor == \'function\' && Ctor.prototype === object) ||\n      (typeof object != \'function\' && (length && isLength(length)))) {\n    return shimKeys(object);\n  }\n  return isObject(object) ? nativeKeys(object) : [];\n};\n\nmodule.exports = keys;\n\n},{"../internal/isLength":96,"../internal/shimKeys":100,"../lang/isNative":106,"../lang/isObject":107}],113:[function(require,module,exports){\nvar isArguments = require(\'../lang/isArguments\'),\n    isArray = require(\'../lang/isArray\'),\n    isIndex = require(\'../internal/isIndex\'),\n    isLength = require(\'../internal/isLength\'),\n    isObject = require(\'../lang/isObject\'),\n    support = require(\'../support\');\n\n\nvar objectProto = Object.prototype;\n\n\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n\nfunction keysIn(object) {\n  if (object == null) {\n    return [];\n  }\n  if (!isObject(object)) {\n    object = Object(object);\n  }\n  var length = object.length;\n  length = (length && isLength(length) &&\n    (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;\n\n  var Ctor = object.constructor,\n      index = -1,\n      isProto = typeof Ctor == \'function\' && Ctor.prototype === object,\n      result = Array(length),\n      skipIndexes = length > 0;\n\n  while (++index < length) {\n    result[index] = (index + \'\');\n  }\n  for (var key in object) {\n    if (!(skipIndexes && isIndex(key, length)) &&\n        !(key == \'constructor\' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\nmodule.exports = keysIn;\n\n},{"../internal/isIndex":94,"../internal/isLength":96,"../lang/isArguments":102,"../lang/isArray":103,"../lang/isObject":107,"../support":115}],114:[function(require,module,exports){\nvar baseToString = require(\'../internal/baseToString\');\n\n\nvar reRegExpChars = /[.*+?^${}()|[\\]\\/\\\\]/g,\n    reHasRegExpChars = RegExp(reRegExpChars.source);\n\n\nfunction escapeRegExp(string) {\n  string = baseToString(string);\n  return (string && reHasRegExpChars.test(string))\n    ? string.replace(reRegExpChars, \'\\\\$&\')\n    : string;\n}\n\nmodule.exports = escapeRegExp;\n\n},{"../internal/baseToString":87}],115:[function(require,module,exports){\n(function (global){\nvar isNative = require(\'./lang/isNative\');\n\n\nvar reThis = /\\bthis\\b/;\n\n\nvar objectProto = Object.prototype;\n\n\nvar document = (document = global.window) && document.document;\n\n\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n\nvar support = {};\n\n(function(x) {\n\n\n  support.funcDecomp = !isNative(global.WinRTError) && reThis.test(function() { return this; });\n\n\n  support.funcNames = typeof Function.name == \'string\';\n\n\n  try {\n    support.dom = document.createDocumentFragment().nodeType === 11;\n  } catch(e) {\n    support.dom = false;\n  }\n\n\n  try {\n    support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);\n  } catch(e) {\n    support.nonEnumArgs = true;\n  }\n}(0, 0));\n\nmodule.exports = support;\n\n}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{"./lang/isNative":106}],116:[function(require,module,exports){\n\nfunction identity(value) {\n  return value;\n}\n\nmodule.exports = identity;\n\n},{}],117:[function(require,module,exports){\nvar process = module.exports = {};\n\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error(\'setTimeout has not been defined\');\n}\nfunction defaultClearTimeout () {\n    throw new Error(\'clearTimeout has not been defined\');\n}\n(function () {\n    try {\n        if (typeof setTimeout === \'function\') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === \'function\') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        return setTimeout(fun, 0);\n    }\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        return clearTimeout(marker);\n    }\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = \'browser\';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = \'\'; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error(\'process.binding is not supported\');\n};\n\nprocess.cwd = function () { return \'/\' };\nprocess.chdir = function (dir) {\n    throw new Error(\'process.chdir is not supported\');\n};\nprocess.umask = function() { return 0; };\n\n},{}],118:[function(require,module,exports){\n(function (global){\n\n;(function(root) {\n\n\n\tvar freeExports = typeof exports == \'object\' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == \'object\' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == \'object\' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\n\tvar punycode,\n\n\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = \'-\', // \'\\x2D\'\n\n\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\n\terrors = {\n\t\t\'overflow\': \'Overflow: input needs wider integers to process\',\n\t\t\'not-basic\': \'Illegal input >= 0x80 (not a basic code point)\',\n\t\t\'invalid-input\': \'Invalid input\'\n\t},\n\n\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\n\tkey;\n\n\n\n\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split(\'@\');\n\t\tvar result = \'\';\n\t\tif (parts.length > 1) {\n\t\t\tresult = parts[0] + \'@\';\n\t\t\tstring = parts[1];\n\t\t}\n\t\tstring = string.replace(regexSeparators, \'\\x2E\');\n\t\tvar labels = string.split(\'.\');\n\t\tvar encoded = map(labels, fn).join(\'.\');\n\t\treturn result + encoded;\n\t}\n\n\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = \'\';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join(\'\');\n\t}\n\n\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\n\tfunction digitToBasic(digit, flag) {\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\n\tfunction decode(input) {\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\n\t\t    baseMinusT;\n\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror(\'not-basic\');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror(\'invalid-input\');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror(\'overflow\');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror(\'overflow\');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror(\'overflow\');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\n\t\t    inputLength,\n\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\tinput = ucs2decode(input);\n\n\t\tinputLength = input.length;\n\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror(\'overflow\');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror(\'overflow\');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join(\'\');\n\t}\n\n\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? \'xn--\' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\n\n\n\tpunycode = {\n\n\t\t\'version\': \'1.4.1\',\n\n\t\t\'ucs2\': {\n\t\t\t\'decode\': ucs2decode,\n\t\t\t\'encode\': ucs2encode\n\t\t},\n\t\t\'decode\': decode,\n\t\t\'encode\': encode,\n\t\t\'toASCII\': toASCII,\n\t\t\'toUnicode\': toUnicode\n\t};\n\n\n\tif (\n\t\ttypeof define == \'function\' &&\n\t\ttypeof define.amd == \'object\' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine(\'punycode\', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{}],119:[function(require,module,exports){\n\n\'use strict\';\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n  var obj = {};\n\n  if (typeof qs !== \'string\' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === \'number\') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, \'%20\'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = \'\';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === \'[object Array]\';\n};\n\n},{}],120:[function(require,module,exports){\n\n\'use strict\';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case \'string\':\n      return v;\n\n    case \'boolean\':\n      return v ? \'true\' : \'false\';\n\n    case \'number\':\n      return isFinite(v) ? v : \'\';\n\n    default:\n      return \'\';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === \'object\') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return \'\';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === \'[object Array]\';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n\n},{}],121:[function(require,module,exports){\n\'use strict\';\n\nexports.decode = exports.parse = require(\'./decode\');\nexports.encode = exports.stringify = require(\'./encode\');\n\n},{"./decode":119,"./encode":120}],122:[function(require,module,exports){\n\n\'use strict\';\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n  var obj = {};\n\n  if (typeof qs !== \'string\' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === \'number\') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, \'%20\'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = \'\';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n},{}],123:[function(require,module,exports){\n\n\'use strict\';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case \'string\':\n      return v;\n\n    case \'boolean\':\n      return v ? \'true\' : \'false\';\n\n    case \'number\':\n      return isFinite(v) ? v : \'\';\n\n    default:\n      return \'\';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || \'&\';\n  eq = eq || \'=\';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === \'object\') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return \'\';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\n},{}],124:[function(require,module,exports){\narguments[4][121][0].apply(exports,arguments)\n},{"./decode":122,"./encode":123,"dup":121}],125:[function(require,module,exports){\n\nvar punycode = require(\'punycode\');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    delims = [\'<\', \'>\', \'"\', \'`\', \' \', \'\\r\', \'\\n\', \'\\t\'],\n\n    unwise = [\'{\', \'}\', \'|\', \'\\\\\', \'^\', \'`\'].concat(delims),\n\n    autoEscape = [\'\\\'\'].concat(unwise),\n    nonHostChars = [\'%\', \'/\', \'?\', \';\', \'#\'].concat(autoEscape),\n    hostEndingChars = [\'/\', \'?\', \'#\'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,\n    unsafeProtocol = {\n      \'javascript\': true,\n      \'javascript:\': true\n    },\n    hostlessProtocol = {\n      \'javascript\': true,\n      \'javascript:\': true\n    },\n    slashedProtocol = {\n      \'http\': true,\n      \'https\': true,\n      \'ftp\': true,\n      \'gopher\': true,\n      \'file\': true,\n      \'http:\': true,\n      \'https:\': true,\n      \'ftp:\': true,\n      \'gopher:\': true,\n      \'file:\': true\n    },\n    querystring = require(\'querystring\');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!isString(url)) {\n    throw new TypeError("Parameter \'url\' must be a string, not " + typeof url);\n  }\n\n  var rest = url;\n\n  rest = rest.trim();\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === \'//\';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n\n\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    var auth, atSign;\n    if (hostEnd === -1) {\n      atSign = rest.lastIndexOf(\'@\');\n    } else {\n      atSign = rest.lastIndexOf(\'@\', hostEnd);\n    }\n\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    this.parseHost();\n\n    this.hostname = this.hostname || \'\';\n\n    var ipv6Hostname = this.hostname[0] === \'[\' &&\n        this.hostname[this.hostname.length - 1] === \']\';\n\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = \'\';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              newpart += \'x\';\n            } else {\n              newpart += part[j];\n            }\n          }\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = \'/\' + notHost.join(\'.\') + rest;\n            }\n            this.hostname = validParts.join(\'.\');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = \'\';\n    } else {\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      var domainArray = this.hostname.split(\'.\');\n      var newOut = [];\n      for (var i = 0; i < domainArray.length; ++i) {\n        var s = domainArray[i];\n        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?\n            \'xn--\' + punycode.encode(s) : s);\n      }\n      this.hostname = newOut.join(\'.\');\n    }\n\n    var p = this.port ? \':\' + this.port : \'\';\n    var h = this.hostname || \'\';\n    this.host = h + p;\n    this.href += this.host;\n\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== \'/\') {\n        rest = \'/\' + rest;\n      }\n    }\n  }\n\n  if (!unsafeProtocol[lowerProto]) {\n\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  var hash = rest.indexOf(\'#\');\n  if (hash !== -1) {\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf(\'?\');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    this.search = \'\';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = \'/\';\n  }\n\n  if (this.pathname || this.search) {\n    var p = this.pathname || \'\';\n    var s = this.search || \'\';\n    this.path = p + s;\n  }\n\n  this.href = this.format();\n  return this;\n};\n\nfunction urlFormat(obj) {\n  if (isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || \'\';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, \':\');\n    auth += \'@\';\n  }\n\n  var protocol = this.protocol || \'\',\n      pathname = this.pathname || \'\',\n      hash = this.hash || \'\',\n      host = false,\n      query = \'\';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(\':\') === -1 ?\n        this.hostname :\n        \'[\' + this.hostname + \']\');\n    if (this.port) {\n      host += \':\' + this.port;\n    }\n  }\n\n  if (this.query &&\n      isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && (\'?\' + query)) || \'\';\n\n  if (protocol && protocol.substr(-1) !== \':\') protocol += \':\';\n\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = \'//\' + (host || \'\');\n    if (pathname && pathname.charAt(0) !== \'/\') pathname = \'/\' + pathname;\n  } else if (!host) {\n    host = \'\';\n  }\n\n  if (hash && hash.charAt(0) !== \'#\') hash = \'#\' + hash;\n  if (search && search.charAt(0) !== \'?\') search = \'?\' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace(\'#\', \'%23\');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  Object.keys(this).forEach(function(k) {\n    result[k] = this[k];\n  }, this);\n\n  result.hash = relative.hash;\n\n  if (relative.href === \'\') {\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.slashes && !relative.protocol) {\n    Object.keys(relative).forEach(function(k) {\n      if (k !== \'protocol\')\n        result[k] = relative[k];\n    });\n\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = \'/\';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    if (!slashedProtocol[relative.protocol]) {\n      Object.keys(relative).forEach(function(k) {\n        result[k] = relative[k];\n      });\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || \'\').split(\'/\');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = \'\';\n      if (!relative.hostname) relative.hostname = \'\';\n      if (relPath[0] !== \'\') relPath.unshift(\'\');\n      if (relPath.length < 2) relPath.unshift(\'\');\n      result.pathname = relPath.join(\'/\');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || \'\';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    if (result.pathname || result.search) {\n      var p = result.pathname || \'\';\n      var s = result.search || \'\';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === \'/\'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === \'/\'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split(\'/\') || [],\n      relPath = relative.pathname && relative.pathname.split(\'/\') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  if (psychotic) {\n    result.hostname = \'\';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === \'\') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = \'\';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === \'\') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === \'\' || srcPath[0] === \'\');\n  }\n\n  if (isRelAbs) {\n    result.host = (relative.host || relative.host === \'\') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === \'\') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n  } else if (relPath.length) {\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!isNullOrUndefined(relative.search)) {\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      var authInHost = result.host && result.host.indexOf(\'@\') > 0 ?\n                       result.host.split(\'@\') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    if (!isNull(result.pathname) || !isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : \'\') +\n                    (result.search ? result.search : \'\');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    if (result.search) {\n      result.path = \'/\' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host) && (last === \'.\' || last === \'..\') ||\n      last === \'\');\n\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last == \'.\') {\n      srcPath.splice(i, 1);\n    } else if (last === \'..\') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift(\'..\');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== \'\' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== \'/\')) {\n    srcPath.unshift(\'\');\n  }\n\n  if (hasTrailingSlash && (srcPath.join(\'/\').substr(-1) !== \'/\')) {\n    srcPath.push(\'\');\n  }\n\n  var isAbsolute = srcPath[0] === \'\' ||\n      (srcPath[0] && srcPath[0].charAt(0) === \'/\');\n\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? \'\' :\n                                    srcPath.length ? srcPath.shift() : \'\';\n    var authInHost = result.host && result.host.indexOf(\'@\') > 0 ?\n                     result.host.split(\'@\') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift(\'\');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join(\'/\');\n  }\n\n  if (!isNull(result.pathname) || !isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : \'\') +\n                  (result.search ? result.search : \'\');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== \':\') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n\nfunction isString(arg) {\n  return typeof arg === "string";\n}\n\nfunction isObject(arg) {\n  return typeof arg === \'object\' && arg !== null;\n}\n\nfunction isNull(arg) {\n  return arg === null;\n}\nfunction isNullOrUndefined(arg) {\n  return  arg == null;\n}\n\n},{"punycode":118,"querystring":121}],126:[function(require,module,exports){\nif (typeof Object.create === \'function\') {\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],127:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === \'object\'\n    && typeof arg.copy === \'function\'\n    && typeof arg.fill === \'function\'\n    && typeof arg.readUInt8 === \'function\';\n}\n},{}],128:[function(require,module,exports){\n(function (process,global){\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(\' \');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === \'%%\') return \'%\';\n    if (i >= len) return x;\n    switch (x) {\n      case \'%s\': return String(args[i++]);\n      case \'%d\': return Number(args[i++]);\n      case \'%j\':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return \'[Circular]\';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += \' \' + x;\n    } else {\n      str += \' \' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\nexports.deprecate = function(fn, msg) {\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || \'\';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp(\'\\\\b\' + set + \'\\\\b\', \'i\').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error(\'%s %d: %s\', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n\n\nfunction inspect(obj, opts) {\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    ctx.showHidden = opts;\n  } else if (opts) {\n    exports._extend(ctx, opts);\n  }\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\ninspect.colors = {\n  \'bold\' : [1, 22],\n  \'italic\' : [3, 23],\n  \'underline\' : [4, 24],\n  \'inverse\' : [7, 27],\n  \'white\' : [37, 39],\n  \'grey\' : [90, 39],\n  \'black\' : [30, 39],\n  \'blue\' : [34, 39],\n  \'cyan\' : [36, 39],\n  \'green\' : [32, 39],\n  \'magenta\' : [35, 39],\n  \'red\' : [31, 39],\n  \'yellow\' : [33, 39]\n};\n\ninspect.styles = {\n  \'special\': \'cyan\',\n  \'number\': \'yellow\',\n  \'boolean\': \'yellow\',\n  \'undefined\': \'grey\',\n  \'null\': \'bold\',\n  \'string\': \'green\',\n  \'date\': \'magenta\',\n  \'regexp\': \'red\'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return \'\\u001b[\' + inspect.colors[style][0] + \'m\' + str +\n           \'\\u001b[\' + inspect.colors[style][1] + \'m\';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      value.inspect !== exports.inspect &&\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  if (isError(value)\n      && (keys.indexOf(\'message\') >= 0 || keys.indexOf(\'description\') >= 0)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? \': \' + value.name : \'\';\n      return ctx.stylize(\'[Function\' + name + \']\', \'special\');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), \'regexp\');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), \'date\');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = \'\', array = false, braces = [\'{\', \'}\'];\n\n  if (isArray(value)) {\n    array = true;\n    braces = [\'[\', \']\'];\n  }\n\n  if (isFunction(value)) {\n    var n = value.name ? \': \' + value.name : \'\';\n    base = \' [Function\' + n + \']\';\n  }\n\n  if (isRegExp(value)) {\n    base = \' \' + RegExp.prototype.toString.call(value);\n  }\n\n  if (isDate(value)) {\n    base = \' \' + Date.prototype.toUTCString.call(value);\n  }\n\n  if (isError(value)) {\n    base = \' \' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), \'regexp\');\n    } else {\n      return ctx.stylize(\'[Object]\', \'special\');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize(\'undefined\', \'undefined\');\n  if (isString(value)) {\n    var simple = \'\\\'\' + JSON.stringify(value).replace(/^"|"$/g, \'\')\n                                             .replace(/\'/g, "\\\\\'")\n                                             .replace(/\\\\"/g, \'"\') + \'\\\'\';\n    return ctx.stylize(simple, \'string\');\n  }\n  if (isNumber(value))\n    return ctx.stylize(\'\' + value, \'number\');\n  if (isBoolean(value))\n    return ctx.stylize(\'\' + value, \'boolean\');\n  if (isNull(value))\n    return ctx.stylize(\'null\', \'null\');\n}\n\n\nfunction formatError(value) {\n  return \'[\' + Error.prototype.toString.call(value) + \']\';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push(\'\');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize(\'[Getter/Setter]\', \'special\');\n    } else {\n      str = ctx.stylize(\'[Getter]\', \'special\');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize(\'[Setter]\', \'special\');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = \'[\' + key + \']\';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf(\'\\n\') > -1) {\n        if (array) {\n          str = str.split(\'\\n\').map(function(line) {\n            return \'  \' + line;\n          }).join(\'\\n\').substr(2);\n        } else {\n          str = \'\\n\' + str.split(\'\\n\').map(function(line) {\n            return \'   \' + line;\n          }).join(\'\\n\');\n        }\n      }\n    } else {\n      str = ctx.stylize(\'[Circular]\', \'special\');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify(\'\' + key);\n    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, \'name\');\n    } else {\n      name = name.replace(/\'/g, "\\\\\'")\n                 .replace(/\\\\"/g, \'"\')\n                 .replace(/(^"|"$)/g, "\'");\n      name = ctx.stylize(name, \'string\');\n    }\n  }\n\n  return name + \': \' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf(\'\\n\') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, \'\').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === \'\' ? \'\' : base + \'\\n \') +\n           \' \' +\n           output.join(\',\\n  \') +\n           \' \' +\n           braces[1];\n  }\n\n  return braces[0] + base + \' \' + output.join(\', \') + \' \' + braces[1];\n}\n\n\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === \'boolean\';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === \'number\';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === \'string\';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === \'symbol\';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === \'[object RegExp]\';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === \'object\' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === \'[object Date]\';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === \'[object Error]\' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === \'function\';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === \'boolean\' ||\n         typeof arg === \'number\' ||\n         typeof arg === \'string\' ||\n         typeof arg === \'symbol\' ||  // ES6 symbol\n         typeof arg === \'undefined\';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require(\'./support/isBuffer\');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? \'0\' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = [\'Jan\', \'Feb\', \'Mar\', \'Apr\', \'May\', \'Jun\', \'Jul\', \'Aug\', \'Sep\',\n              \'Oct\', \'Nov\', \'Dec\'];\n\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(\':\');\n  return [d.getDate(), months[d.getMonth()], time].join(\' \');\n}\n\n\nexports.log = function() {\n  console.log(\'%s - %s\', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n\nexports.inherits = require(\'inherits\');\n\nexports._extend = function(origin, add) {\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require(\'_process\'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})\n},{"./support/isBuffer":127,"_process":117,"inherits":126}],129:[function(require,module,exports){\n(function() {\n  var XMLAttribute, create;\n\n  create = require(\'lodash/object/create\');\n\n  module.exports = XMLAttribute = (function() {\n    function XMLAttribute(parent, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error("Missing attribute name of element " + parent.name);\n      }\n      if (value == null) {\n        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);\n      }\n      this.name = this.stringify.attName(name);\n      this.value = this.stringify.attValue(value);\n    }\n\n    XMLAttribute.prototype.clone = function() {\n      return create(XMLAttribute.prototype, this);\n    };\n\n    XMLAttribute.prototype.toString = function(options, level) {\n      return \' \' + this.name + \'="\' + this.value + \'"\';\n    };\n\n    return XMLAttribute;\n\n  })();\n\n}).call(this);\n\n},{"lodash/object/create":111}],130:[function(require,module,exports){\n(function() {\n  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;\n\n  XMLStringifier = require(\'./XMLStringifier\');\n\n  XMLDeclaration = require(\'./XMLDeclaration\');\n\n  XMLDocType = require(\'./XMLDocType\');\n\n  XMLElement = require(\'./XMLElement\');\n\n  module.exports = XMLBuilder = (function() {\n    function XMLBuilder(name, options) {\n      var root, temp;\n      if (name == null) {\n        throw new Error("Root element needs a name");\n      }\n      if (options == null) {\n        options = {};\n      }\n      this.options = options;\n      this.stringify = new XMLStringifier(options);\n      temp = new XMLElement(this, \'doc\');\n      root = temp.element(name);\n      root.isRoot = true;\n      root.documentObject = this;\n      this.rootObject = root;\n      if (!options.headless) {\n        root.declaration(options);\n        if ((options.pubID != null) || (options.sysID != null)) {\n          root.doctype(options);\n        }\n      }\n    }\n\n    XMLBuilder.prototype.root = function() {\n      return this.rootObject;\n    };\n\n    XMLBuilder.prototype.end = function(options) {\n      return this.toString(options);\n    };\n\n    XMLBuilder.prototype.toString = function(options) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      r = \'\';\n      if (this.xmldec != null) {\n        r += this.xmldec.toString(options);\n      }\n      if (this.doctype != null) {\n        r += this.doctype.toString(options);\n      }\n      r += this.rootObject.toString(options);\n      if (pretty && r.slice(-newline.length) === newline) {\n        r = r.slice(0, -newline.length);\n      }\n      return r;\n    };\n\n    return XMLBuilder;\n\n  })();\n\n}).call(this);\n\n},{"./XMLDeclaration":137,"./XMLDocType":138,"./XMLElement":139,"./XMLStringifier":143}],131:[function(require,module,exports){\n(function() {\n  var XMLCData, XMLNode, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = require(\'lodash/object/create\');\n\n  XMLNode = require(\'./XMLNode\');\n\n  module.exports = XMLCData = (function(superClass) {\n    extend(XMLCData, superClass);\n\n    function XMLCData(parent, text) {\n      XMLCData.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error("Missing CDATA text");\n      }\n      this.text = this.stringify.cdata(text);\n    }\n\n    XMLCData.prototype.clone = function() {\n      return create(XMLCData.prototype, this);\n    };\n\n    XMLCData.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<![CDATA[\' + this.text + \']]>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLCData;\n\n  })(XMLNode);\n\n}).call(this);\n\n},{"./XMLNode":140,"lodash/object/create":111}],132:[function(require,module,exports){\n(function() {\n  var XMLComment, XMLNode, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = require(\'lodash/object/create\');\n\n  XMLNode = require(\'./XMLNode\');\n\n  module.exports = XMLComment = (function(superClass) {\n    extend(XMLComment, superClass);\n\n    function XMLComment(parent, text) {\n      XMLComment.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error("Missing comment text");\n      }\n      this.text = this.stringify.comment(text);\n    }\n\n    XMLComment.prototype.clone = function() {\n      return create(XMLComment.prototype, this);\n    };\n\n    XMLComment.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'\x3c!-- \' + this.text + \' --\x3e\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLComment;\n\n  })(XMLNode);\n\n}).call(this);\n\n},{"./XMLNode":140,"lodash/object/create":111}],133:[function(require,module,exports){\n(function() {\n  var XMLDTDAttList, create;\n\n  create = require(\'lodash/object/create\');\n\n  module.exports = XMLDTDAttList = (function() {\n    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      this.stringify = parent.stringify;\n      if (elementName == null) {\n        throw new Error("Missing DTD element name");\n      }\n      if (attributeName == null) {\n        throw new Error("Missing DTD attribute name");\n      }\n      if (!attributeType) {\n        throw new Error("Missing DTD attribute type");\n      }\n      if (!defaultValueType) {\n        throw new Error("Missing DTD attribute default");\n      }\n      if (defaultValueType.indexOf(\'#\') !== 0) {\n        defaultValueType = \'#\' + defaultValueType;\n      }\n      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {\n        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");\n      }\n      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {\n        throw new Error("Default value only applies to #FIXED or #DEFAULT");\n      }\n      this.elementName = this.stringify.eleName(elementName);\n      this.attributeName = this.stringify.attName(attributeName);\n      this.attributeType = this.stringify.dtdAttType(attributeType);\n      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);\n      this.defaultValueType = defaultValueType;\n    }\n\n    XMLDTDAttList.prototype.clone = function() {\n      return create(XMLDTDAttList.prototype, this);\n    };\n\n    XMLDTDAttList.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<!ATTLIST \' + this.elementName + \' \' + this.attributeName + \' \' + this.attributeType;\n      if (this.defaultValueType !== \'#DEFAULT\') {\n        r += \' \' + this.defaultValueType;\n      }\n      if (this.defaultValue) {\n        r += \' "\' + this.defaultValue + \'"\';\n      }\n      r += \'>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDAttList;\n\n  })();\n\n}).call(this);\n\n},{"lodash/object/create":111}],134:[function(require,module,exports){\n(function() {\n  var XMLDTDElement, create, isArray;\n\n  create = require(\'lodash/object/create\');\n\n  isArray = require(\'lodash/lang/isArray\');\n\n  module.exports = XMLDTDElement = (function() {\n    function XMLDTDElement(parent, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error("Missing DTD element name");\n      }\n      if (!value) {\n        value = \'(#PCDATA)\';\n      }\n      if (isArray(value)) {\n        value = \'(\' + value.join(\',\') + \')\';\n      }\n      this.name = this.stringify.eleName(name);\n      this.value = this.stringify.dtdElementValue(value);\n    }\n\n    XMLDTDElement.prototype.clone = function() {\n      return create(XMLDTDElement.prototype, this);\n    };\n\n    XMLDTDElement.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<!ELEMENT \' + this.name + \' \' + this.value + \'>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDElement;\n\n  })();\n\n}).call(this);\n\n},{"lodash/lang/isArray":103,"lodash/object/create":111}],135:[function(require,module,exports){\n(function() {\n  var XMLDTDEntity, create, isObject;\n\n  create = require(\'lodash/object/create\');\n\n  isObject = require(\'lodash/lang/isObject\');\n\n  module.exports = XMLDTDEntity = (function() {\n    function XMLDTDEntity(parent, pe, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error("Missing entity name");\n      }\n      if (value == null) {\n        throw new Error("Missing entity value");\n      }\n      this.pe = !!pe;\n      this.name = this.stringify.eleName(name);\n      if (!isObject(value)) {\n        this.value = this.stringify.dtdEntityValue(value);\n      } else {\n        if (!value.pubID && !value.sysID) {\n          throw new Error("Public and/or system identifiers are required for an external entity");\n        }\n        if (value.pubID && !value.sysID) {\n          throw new Error("System identifier is required for a public external entity");\n        }\n        if (value.pubID != null) {\n          this.pubID = this.stringify.dtdPubID(value.pubID);\n        }\n        if (value.sysID != null) {\n          this.sysID = this.stringify.dtdSysID(value.sysID);\n        }\n        if (value.nData != null) {\n          this.nData = this.stringify.dtdNData(value.nData);\n        }\n        if (this.pe && this.nData) {\n          throw new Error("Notation declaration is not allowed in a parameter entity");\n        }\n      }\n    }\n\n    XMLDTDEntity.prototype.clone = function() {\n      return create(XMLDTDEntity.prototype, this);\n    };\n\n    XMLDTDEntity.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<!ENTITY\';\n      if (this.pe) {\n        r += \' %\';\n      }\n      r += \' \' + this.name;\n      if (this.value) {\n        r += \' "\' + this.value + \'"\';\n      } else {\n        if (this.pubID && this.sysID) {\n          r += \' PUBLIC "\' + this.pubID + \'" "\' + this.sysID + \'"\';\n        } else if (this.sysID) {\n          r += \' SYSTEM "\' + this.sysID + \'"\';\n        }\n        if (this.nData) {\n          r += \' NDATA \' + this.nData;\n        }\n      }\n      r += \'>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDEntity;\n\n  })();\n\n}).call(this);\n\n},{"lodash/lang/isObject":107,"lodash/object/create":111}],136:[function(require,module,exports){\n(function() {\n  var XMLDTDNotation, create;\n\n  create = require(\'lodash/object/create\');\n\n  module.exports = XMLDTDNotation = (function() {\n    function XMLDTDNotation(parent, name, value) {\n      this.stringify = parent.stringify;\n      if (name == null) {\n        throw new Error("Missing notation name");\n      }\n      if (!value.pubID && !value.sysID) {\n        throw new Error("Public or system identifiers are required for an external entity");\n      }\n      this.name = this.stringify.eleName(name);\n      if (value.pubID != null) {\n        this.pubID = this.stringify.dtdPubID(value.pubID);\n      }\n      if (value.sysID != null) {\n        this.sysID = this.stringify.dtdSysID(value.sysID);\n      }\n    }\n\n    XMLDTDNotation.prototype.clone = function() {\n      return create(XMLDTDNotation.prototype, this);\n    };\n\n    XMLDTDNotation.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<!NOTATION \' + this.name;\n      if (this.pubID && this.sysID) {\n        r += \' PUBLIC "\' + this.pubID + \'" "\' + this.sysID + \'"\';\n      } else if (this.pubID) {\n        r += \' PUBLIC "\' + this.pubID + \'"\';\n      } else if (this.sysID) {\n        r += \' SYSTEM "\' + this.sysID + \'"\';\n      }\n      r += \'>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDTDNotation;\n\n  })();\n\n}).call(this);\n\n},{"lodash/object/create":111}],137:[function(require,module,exports){\n(function() {\n  var XMLDeclaration, XMLNode, create, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = require(\'lodash/object/create\');\n\n  isObject = require(\'lodash/lang/isObject\');\n\n  XMLNode = require(\'./XMLNode\');\n\n  module.exports = XMLDeclaration = (function(superClass) {\n    extend(XMLDeclaration, superClass);\n\n    function XMLDeclaration(parent, version, encoding, standalone) {\n      var ref;\n      XMLDeclaration.__super__.constructor.call(this, parent);\n      if (isObject(version)) {\n        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;\n      }\n      if (!version) {\n        version = \'1.0\';\n      }\n      if (version != null) {\n        this.version = this.stringify.xmlVersion(version);\n      }\n      if (encoding != null) {\n        this.encoding = this.stringify.xmlEncoding(encoding);\n      }\n      if (standalone != null) {\n        this.standalone = this.stringify.xmlStandalone(standalone);\n      }\n    }\n\n    XMLDeclaration.prototype.clone = function() {\n      return create(XMLDeclaration.prototype, this);\n    };\n\n    XMLDeclaration.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<?xml\';\n      if (this.version != null) {\n        r += \' version="\' + this.version + \'"\';\n      }\n      if (this.encoding != null) {\n        r += \' encoding="\' + this.encoding + \'"\';\n      }\n      if (this.standalone != null) {\n        r += \' standalone="\' + this.standalone + \'"\';\n      }\n      r += \'?>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLDeclaration;\n\n  })(XMLNode);\n\n}).call(this);\n\n},{"./XMLNode":140,"lodash/lang/isObject":107,"lodash/object/create":111}],138:[function(require,module,exports){\n(function() {\n  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;\n\n  create = require(\'lodash/object/create\');\n\n  isObject = require(\'lodash/lang/isObject\');\n\n  XMLCData = require(\'./XMLCData\');\n\n  XMLComment = require(\'./XMLComment\');\n\n  XMLDTDAttList = require(\'./XMLDTDAttList\');\n\n  XMLDTDEntity = require(\'./XMLDTDEntity\');\n\n  XMLDTDElement = require(\'./XMLDTDElement\');\n\n  XMLDTDNotation = require(\'./XMLDTDNotation\');\n\n  XMLProcessingInstruction = require(\'./XMLProcessingInstruction\');\n\n  module.exports = XMLDocType = (function() {\n    function XMLDocType(parent, pubID, sysID) {\n      var ref, ref1;\n      this.documentObject = parent;\n      this.stringify = this.documentObject.stringify;\n      this.children = [];\n      if (isObject(pubID)) {\n        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;\n      }\n      if (sysID == null) {\n        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];\n      }\n      if (pubID != null) {\n        this.pubID = this.stringify.dtdPubID(pubID);\n      }\n      if (sysID != null) {\n        this.sysID = this.stringify.dtdSysID(sysID);\n      }\n    }\n\n    XMLDocType.prototype.clone = function() {\n      return create(XMLDocType.prototype, this);\n    };\n\n    XMLDocType.prototype.element = function(name, value) {\n      var child;\n      child = new XMLDTDElement(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var child;\n      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.entity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, false, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.pEntity = function(name, value) {\n      var child;\n      child = new XMLDTDEntity(this, true, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.notation = function(name, value) {\n      var child;\n      child = new XMLDTDNotation(this, name, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.instruction = function(target, value) {\n      var child;\n      child = new XMLProcessingInstruction(this, target, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLDocType.prototype.root = function() {\n      return this.documentObject.root();\n    };\n\n    XMLDocType.prototype.document = function() {\n      return this.documentObject;\n    };\n\n    XMLDocType.prototype.toString = function(options, level) {\n      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<!DOCTYPE \' + this.root().name;\n      if (this.pubID && this.sysID) {\n        r += \' PUBLIC "\' + this.pubID + \'" "\' + this.sysID + \'"\';\n      } else if (this.sysID) {\n        r += \' SYSTEM "\' + this.sysID + \'"\';\n      }\n      if (this.children.length > 0) {\n        r += \' [\';\n        if (pretty) {\n          r += newline;\n        }\n        ref3 = this.children;\n        for (i = 0, len = ref3.length; i < len; i++) {\n          child = ref3[i];\n          r += child.toString(options, level + 1);\n        }\n        r += \']\';\n      }\n      r += \'>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    XMLDocType.prototype.ele = function(name, value) {\n      return this.element(name, value);\n    };\n\n    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);\n    };\n\n    XMLDocType.prototype.ent = function(name, value) {\n      return this.entity(name, value);\n    };\n\n    XMLDocType.prototype.pent = function(name, value) {\n      return this.pEntity(name, value);\n    };\n\n    XMLDocType.prototype.not = function(name, value) {\n      return this.notation(name, value);\n    };\n\n    XMLDocType.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLDocType.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLDocType.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLDocType.prototype.up = function() {\n      return this.root();\n    };\n\n    XMLDocType.prototype.doc = function() {\n      return this.document();\n    };\n\n    return XMLDocType;\n\n  })();\n\n}).call(this);\n\n},{"./XMLCData":131,"./XMLComment":132,"./XMLDTDAttList":133,"./XMLDTDElement":134,"./XMLDTDEntity":135,"./XMLDTDNotation":136,"./XMLProcessingInstruction":141,"lodash/lang/isObject":107,"lodash/object/create":111}],139:[function(require,module,exports){\n(function() {\n  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isArray, isFunction, isObject,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = require(\'lodash/object/create\');\n\n  isObject = require(\'lodash/lang/isObject\');\n\n  isArray = require(\'lodash/lang/isArray\');\n\n  isFunction = require(\'lodash/lang/isFunction\');\n\n  every = require(\'lodash/collection/every\');\n\n  XMLNode = require(\'./XMLNode\');\n\n  XMLAttribute = require(\'./XMLAttribute\');\n\n  XMLProcessingInstruction = require(\'./XMLProcessingInstruction\');\n\n  module.exports = XMLElement = (function(superClass) {\n    extend(XMLElement, superClass);\n\n    function XMLElement(parent, name, attributes) {\n      XMLElement.__super__.constructor.call(this, parent);\n      if (name == null) {\n        throw new Error("Missing element name");\n      }\n      this.name = this.stringify.eleName(name);\n      this.children = [];\n      this.instructions = [];\n      this.attributes = {};\n      if (attributes != null) {\n        this.attribute(attributes);\n      }\n    }\n\n    XMLElement.prototype.clone = function() {\n      var att, attName, clonedSelf, i, len, pi, ref, ref1;\n      clonedSelf = create(XMLElement.prototype, this);\n      if (clonedSelf.isRoot) {\n        clonedSelf.documentObject = null;\n      }\n      clonedSelf.attributes = {};\n      ref = this.attributes;\n      for (attName in ref) {\n        if (!hasProp.call(ref, attName)) continue;\n        att = ref[attName];\n        clonedSelf.attributes[attName] = att.clone();\n      }\n      clonedSelf.instructions = [];\n      ref1 = this.instructions;\n      for (i = 0, len = ref1.length; i < len; i++) {\n        pi = ref1[i];\n        clonedSelf.instructions.push(pi.clone());\n      }\n      clonedSelf.children = [];\n      this.children.forEach(function(child) {\n        var clonedChild;\n        clonedChild = child.clone();\n        clonedChild.parent = clonedSelf;\n        return clonedSelf.children.push(clonedChild);\n      });\n      return clonedSelf;\n    };\n\n    XMLElement.prototype.attribute = function(name, value) {\n      var attName, attValue;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (isObject(name)) {\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (!this.options.skipNullAttributes || (value != null)) {\n          this.attributes[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    };\n\n    XMLElement.prototype.removeAttribute = function(name) {\n      var attName, i, len;\n      if (name == null) {\n        throw new Error("Missing attribute name");\n      }\n      name = name.valueOf();\n      if (isArray(name)) {\n        for (i = 0, len = name.length; i < len; i++) {\n          attName = name[i];\n          delete this.attributes[attName];\n        }\n      } else {\n        delete this.attributes[name];\n      }\n      return this;\n    };\n\n    XMLElement.prototype.instruction = function(target, value) {\n      var i, insTarget, insValue, instruction, len;\n      if (target != null) {\n        target = target.valueOf();\n      }\n      if (value != null) {\n        value = value.valueOf();\n      }\n      if (isArray(target)) {\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        instruction = new XMLProcessingInstruction(this, target, value);\n        this.instructions.push(instruction);\n      }\n      return this;\n    };\n\n    XMLElement.prototype.toString = function(options, level) {\n      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      ref3 = this.instructions;\n      for (i = 0, len = ref3.length; i < len; i++) {\n        instruction = ref3[i];\n        r += instruction.toString(options, level + 1);\n      }\n      if (pretty) {\n        r += space;\n      }\n      r += \'<\' + this.name;\n      ref4 = this.attributes;\n      for (name in ref4) {\n        if (!hasProp.call(ref4, name)) continue;\n        att = ref4[name];\n        r += att.toString(options);\n      }\n      if (this.children.length === 0 || every(this.children, function(e) {\n        return e.value === \'\';\n      })) {\n        r += \'/>\';\n        if (pretty) {\n          r += newline;\n        }\n      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {\n        r += \'>\';\n        r += this.children[0].value;\n        r += \'</\' + this.name + \'>\';\n        r += newline;\n      } else {\n        r += \'>\';\n        if (pretty) {\n          r += newline;\n        }\n        ref5 = this.children;\n        for (j = 0, len1 = ref5.length; j < len1; j++) {\n          child = ref5[j];\n          r += child.toString(options, level + 1);\n        }\n        if (pretty) {\n          r += space;\n        }\n        r += \'</\' + this.name + \'>\';\n        if (pretty) {\n          r += newline;\n        }\n      }\n      return r;\n    };\n\n    XMLElement.prototype.att = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.ins = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    XMLElement.prototype.a = function(name, value) {\n      return this.attribute(name, value);\n    };\n\n    XMLElement.prototype.i = function(target, value) {\n      return this.instruction(target, value);\n    };\n\n    return XMLElement;\n\n  })(XMLNode);\n\n}).call(this);\n\n},{"./XMLAttribute":129,"./XMLNode":140,"./XMLProcessingInstruction":141,"lodash/collection/every":69,"lodash/lang/isArray":103,"lodash/lang/isFunction":105,"lodash/lang/isObject":107,"lodash/object/create":111}],140:[function(require,module,exports){\n(function() {\n  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isArray, isEmpty, isFunction, isObject,\n    hasProp = {}.hasOwnProperty;\n\n  isObject = require(\'lodash/lang/isObject\');\n\n  isArray = require(\'lodash/lang/isArray\');\n\n  isFunction = require(\'lodash/lang/isFunction\');\n\n  isEmpty = require(\'lodash/lang/isEmpty\');\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  module.exports = XMLNode = (function() {\n    function XMLNode(parent) {\n      this.parent = parent;\n      this.options = this.parent.options;\n      this.stringify = this.parent.stringify;\n      if (XMLElement === null) {\n        XMLElement = require(\'./XMLElement\');\n        XMLCData = require(\'./XMLCData\');\n        XMLComment = require(\'./XMLComment\');\n        XMLDeclaration = require(\'./XMLDeclaration\');\n        XMLDocType = require(\'./XMLDocType\');\n        XMLRaw = require(\'./XMLRaw\');\n        XMLText = require(\'./XMLText\');\n      }\n    }\n\n    XMLNode.prototype.clone = function() {\n      throw new Error("Cannot clone generic XMLNode");\n    };\n\n    XMLNode.prototype.element = function(name, attributes, text) {\n      var item, j, key, lastChild, len, ref, val;\n      lastChild = null;\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref = [attributes, text], text = ref[0], attributes = ref[1];\n      }\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (isArray(name)) {\n        for (j = 0, len = name.length; j < len; j++) {\n          item = name[j];\n          lastChild = this.element(item);\n        }\n      } else if (isFunction(name)) {\n        lastChild = this.element(name.apply());\n      } else if (isObject(name)) {\n        for (key in name) {\n          if (!hasProp.call(name, key)) continue;\n          val = name[key];\n          if (isFunction(val)) {\n            val = val.apply();\n          }\n          if ((isObject(val)) && (isEmpty(val))) {\n            val = null;\n          }\n          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);\n          } else if (isObject(val)) {\n            if (!this.options.ignoreDecorators && this.stringify.convertListKey && key.indexOf(this.stringify.convertListKey) === 0 && isArray(val)) {\n              lastChild = this.element(val);\n            } else {\n              lastChild = this.element(key);\n              lastChild.element(val);\n            }\n          } else {\n            lastChild = this.element(key, val);\n          }\n        }\n      } else {\n        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n          lastChild = this.text(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n          lastChild = this.cdata(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n          lastChild = this.comment(text);\n        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n          lastChild = this.raw(text);\n        } else {\n          lastChild = this.node(name, attributes, text);\n        }\n      }\n      if (lastChild == null) {\n        throw new Error("Could not create any elements with: " + name);\n      }\n      return lastChild;\n    };\n\n    XMLNode.prototype.insertBefore = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error("Cannot insert elements at root level");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.insertAfter = function(name, attributes, text) {\n      var child, i, removed;\n      if (this.isRoot) {\n        throw new Error("Cannot insert elements at root level");\n      }\n      i = this.parent.children.indexOf(this);\n      removed = this.parent.children.splice(i + 1);\n      child = this.parent.element(name, attributes, text);\n      Array.prototype.push.apply(this.parent.children, removed);\n      return child;\n    };\n\n    XMLNode.prototype.remove = function() {\n      var i, ref;\n      if (this.isRoot) {\n        throw new Error("Cannot remove the root element");\n      }\n      i = this.parent.children.indexOf(this);\n      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;\n      return this.parent;\n    };\n\n    XMLNode.prototype.node = function(name, attributes, text) {\n      var child, ref;\n      if (name != null) {\n        name = name.valueOf();\n      }\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = attributes.valueOf();\n      if (!isObject(attributes)) {\n        ref = [attributes, text], text = ref[0], attributes = ref[1];\n      }\n      child = new XMLElement(this, name, attributes);\n      if (text != null) {\n        child.text(text);\n      }\n      this.children.push(child);\n      return child;\n    };\n\n    XMLNode.prototype.text = function(value) {\n      var child;\n      child = new XMLText(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.cdata = function(value) {\n      var child;\n      child = new XMLCData(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.comment = function(value) {\n      var child;\n      child = new XMLComment(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.raw = function(value) {\n      var child;\n      child = new XMLRaw(this, value);\n      this.children.push(child);\n      return this;\n    };\n\n    XMLNode.prototype.declaration = function(version, encoding, standalone) {\n      var doc, xmldec;\n      doc = this.document();\n      xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n      doc.xmldec = xmldec;\n      return doc.root();\n    };\n\n    XMLNode.prototype.doctype = function(pubID, sysID) {\n      var doc, doctype;\n      doc = this.document();\n      doctype = new XMLDocType(doc, pubID, sysID);\n      doc.doctype = doctype;\n      return doctype;\n    };\n\n    XMLNode.prototype.up = function() {\n      if (this.isRoot) {\n        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");\n      }\n      return this.parent;\n    };\n\n    XMLNode.prototype.root = function() {\n      var child;\n      if (this.isRoot) {\n        return this;\n      }\n      child = this.parent;\n      while (!child.isRoot) {\n        child = child.parent;\n      }\n      return child;\n    };\n\n    XMLNode.prototype.document = function() {\n      return this.root().documentObject;\n    };\n\n    XMLNode.prototype.end = function(options) {\n      return this.document().toString(options);\n    };\n\n    XMLNode.prototype.prev = function() {\n      var i;\n      if (this.isRoot) {\n        throw new Error("Root node has no siblings");\n      }\n      i = this.parent.children.indexOf(this);\n      if (i < 1) {\n        throw new Error("Already at the first node");\n      }\n      return this.parent.children[i - 1];\n    };\n\n    XMLNode.prototype.next = function() {\n      var i;\n      if (this.isRoot) {\n        throw new Error("Root node has no siblings");\n      }\n      i = this.parent.children.indexOf(this);\n      if (i === -1 || i === this.parent.children.length - 1) {\n        throw new Error("Already at the last node");\n      }\n      return this.parent.children[i + 1];\n    };\n\n    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {\n      var clonedRoot;\n      clonedRoot = xmlbuilder.root().clone();\n      clonedRoot.parent = this;\n      clonedRoot.isRoot = false;\n      this.children.push(clonedRoot);\n      return this;\n    };\n\n    XMLNode.prototype.ele = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.nod = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.txt = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.dat = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.com = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.doc = function() {\n      return this.document();\n    };\n\n    XMLNode.prototype.dec = function(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    };\n\n    XMLNode.prototype.dtd = function(pubID, sysID) {\n      return this.doctype(pubID, sysID);\n    };\n\n    XMLNode.prototype.e = function(name, attributes, text) {\n      return this.element(name, attributes, text);\n    };\n\n    XMLNode.prototype.n = function(name, attributes, text) {\n      return this.node(name, attributes, text);\n    };\n\n    XMLNode.prototype.t = function(value) {\n      return this.text(value);\n    };\n\n    XMLNode.prototype.d = function(value) {\n      return this.cdata(value);\n    };\n\n    XMLNode.prototype.c = function(value) {\n      return this.comment(value);\n    };\n\n    XMLNode.prototype.r = function(value) {\n      return this.raw(value);\n    };\n\n    XMLNode.prototype.u = function() {\n      return this.up();\n    };\n\n    return XMLNode;\n\n  })();\n\n}).call(this);\n\n},{"./XMLCData":131,"./XMLComment":132,"./XMLDeclaration":137,"./XMLDocType":138,"./XMLElement":139,"./XMLRaw":142,"./XMLText":144,"lodash/lang/isArray":103,"lodash/lang/isEmpty":104,"lodash/lang/isFunction":105,"lodash/lang/isObject":107}],141:[function(require,module,exports){\n(function() {\n  var XMLProcessingInstruction, create;\n\n  create = require(\'lodash/object/create\');\n\n  module.exports = XMLProcessingInstruction = (function() {\n    function XMLProcessingInstruction(parent, target, value) {\n      this.stringify = parent.stringify;\n      if (target == null) {\n        throw new Error("Missing instruction target");\n      }\n      this.target = this.stringify.insTarget(target);\n      if (value) {\n        this.value = this.stringify.insValue(value);\n      }\n    }\n\n    XMLProcessingInstruction.prototype.clone = function() {\n      return create(XMLProcessingInstruction.prototype, this);\n    };\n\n    XMLProcessingInstruction.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += \'<?\';\n      r += this.target;\n      if (this.value) {\n        r += \' \' + this.value;\n      }\n      r += \'?>\';\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLProcessingInstruction;\n\n  })();\n\n}).call(this);\n\n},{"lodash/object/create":111}],142:[function(require,module,exports){\n(function() {\n  var XMLNode, XMLRaw, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = require(\'lodash/object/create\');\n\n  XMLNode = require(\'./XMLNode\');\n\n  module.exports = XMLRaw = (function(superClass) {\n    extend(XMLRaw, superClass);\n\n    function XMLRaw(parent, text) {\n      XMLRaw.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error("Missing raw text");\n      }\n      this.value = this.stringify.raw(text);\n    }\n\n    XMLRaw.prototype.clone = function() {\n      return create(XMLRaw.prototype, this);\n    };\n\n    XMLRaw.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += this.value;\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLRaw;\n\n  })(XMLNode);\n\n}).call(this);\n\n},{"./XMLNode":140,"lodash/object/create":111}],143:[function(require,module,exports){\n(function() {\n  var XMLStringifier,\n    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },\n    hasProp = {}.hasOwnProperty;\n\n  module.exports = XMLStringifier = (function() {\n    function XMLStringifier(options) {\n      this.assertLegalChar = bind(this.assertLegalChar, this);\n      var key, ref, value;\n      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;\n      ref = (options != null ? options.stringify : void 0) || {};\n      for (key in ref) {\n        if (!hasProp.call(ref, key)) continue;\n        value = ref[key];\n        this[key] = value;\n      }\n    }\n\n    XMLStringifier.prototype.eleName = function(val) {\n      val = \'\' + val || \'\';\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.eleText = function(val) {\n      val = \'\' + val || \'\';\n      return this.assertLegalChar(this.elEscape(val));\n    };\n\n    XMLStringifier.prototype.cdata = function(val) {\n      val = \'\' + val || \'\';\n      if (val.match(/]]>/)) {\n        throw new Error("Invalid CDATA text: " + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.comment = function(val) {\n      val = \'\' + val || \'\';\n      if (val.match(/--/)) {\n        throw new Error("Comment text cannot contain double-hypen: " + val);\n      }\n      return this.assertLegalChar(val);\n    };\n\n    XMLStringifier.prototype.raw = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.attName = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.attValue = function(val) {\n      val = \'\' + val || \'\';\n      return this.attEscape(val);\n    };\n\n    XMLStringifier.prototype.insTarget = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.insValue = function(val) {\n      val = \'\' + val || \'\';\n      if (val.match(/\\?>/)) {\n        throw new Error("Invalid processing instruction value: " + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlVersion = function(val) {\n      val = \'\' + val || \'\';\n      if (!val.match(/1\\.[0-9]+/)) {\n        throw new Error("Invalid version number: " + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlEncoding = function(val) {\n      val = \'\' + val || \'\';\n      if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {\n        throw new Error("Invalid encoding: " + val);\n      }\n      return val;\n    };\n\n    XMLStringifier.prototype.xmlStandalone = function(val) {\n      if (val) {\n        return "yes";\n      } else {\n        return "no";\n      }\n    };\n\n    XMLStringifier.prototype.dtdPubID = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.dtdSysID = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.dtdElementValue = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.dtdAttType = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.dtdAttDefault = function(val) {\n      if (val != null) {\n        return \'\' + val || \'\';\n      } else {\n        return val;\n      }\n    };\n\n    XMLStringifier.prototype.dtdEntityValue = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.dtdNData = function(val) {\n      return \'\' + val || \'\';\n    };\n\n    XMLStringifier.prototype.convertAttKey = \'@\';\n\n    XMLStringifier.prototype.convertPIKey = \'?\';\n\n    XMLStringifier.prototype.convertTextKey = \'#text\';\n\n    XMLStringifier.prototype.convertCDataKey = \'#cdata\';\n\n    XMLStringifier.prototype.convertCommentKey = \'#comment\';\n\n    XMLStringifier.prototype.convertRawKey = \'#raw\';\n\n    XMLStringifier.prototype.convertListKey = \'#list\';\n\n    XMLStringifier.prototype.assertLegalChar = function(str) {\n      var chars, chr;\n      if (this.allowSurrogateChars) {\n        chars = /[\\u0000-\\u0008\\u000B-\\u000C\\u000E-\\u001F\\uFFFE-\\uFFFF]/;\n      } else {\n        chars = /[\\u0000-\\u0008\\u000B-\\u000C\\u000E-\\u001F\\uD800-\\uDFFF\\uFFFE-\\uFFFF]/;\n      }\n      chr = str.match(chars);\n      if (chr) {\n        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);\n      }\n      return str;\n    };\n\n    XMLStringifier.prototype.elEscape = function(str) {\n      return str.replace(/&/g, \'&amp;\').replace(/</g, \'&lt;\').replace(/>/g, \'&gt;\').replace(/\\r/g, \'&#xD;\');\n    };\n\n    XMLStringifier.prototype.attEscape = function(str) {\n      return str.replace(/&/g, \'&amp;\').replace(/</g, \'&lt;\').replace(/"/g, \'&quot;\').replace(/\\t/g, \'&#x9;\').replace(/\\n/g, \'&#xA;\').replace(/\\r/g, \'&#xD;\');\n    };\n\n    return XMLStringifier;\n\n  })();\n\n}).call(this);\n\n},{}],144:[function(require,module,exports){\n(function() {\n  var XMLNode, XMLText, create,\n    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },\n    hasProp = {}.hasOwnProperty;\n\n  create = require(\'lodash/object/create\');\n\n  XMLNode = require(\'./XMLNode\');\n\n  module.exports = XMLText = (function(superClass) {\n    extend(XMLText, superClass);\n\n    function XMLText(parent, text) {\n      XMLText.__super__.constructor.call(this, parent);\n      if (text == null) {\n        throw new Error("Missing element text");\n      }\n      this.value = this.stringify.eleText(text);\n    }\n\n    XMLText.prototype.clone = function() {\n      return create(XMLText.prototype, this);\n    };\n\n    XMLText.prototype.toString = function(options, level) {\n      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;\n      pretty = (options != null ? options.pretty : void 0) || false;\n      indent = (ref = options != null ? options.indent : void 0) != null ? ref : \'  \';\n      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;\n      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : \'\\n\';\n      level || (level = 0);\n      space = new Array(level + offset + 1).join(indent);\n      r = \'\';\n      if (pretty) {\n        r += space;\n      }\n      r += this.value;\n      if (pretty) {\n        r += newline;\n      }\n      return r;\n    };\n\n    return XMLText;\n\n  })(XMLNode);\n\n}).call(this);\n\n},{"./XMLNode":140,"lodash/object/create":111}],145:[function(require,module,exports){\n(function() {\n  var XMLBuilder, assign;\n\n  assign = require(\'lodash/object/assign\');\n\n  XMLBuilder = require(\'./XMLBuilder\');\n\n  module.exports.create = function(name, xmldec, doctype, options) {\n    options = assign({}, xmldec, doctype, options);\n    return new XMLBuilder(name, options).root();\n  };\n\n}).call(this);\n\n},{"./XMLBuilder":130,"lodash/object/assign":110}],146:[function(require,module,exports){\nrequire(\'./browser_loader\');\n\nvar AWS = require(\'./core\');\n\nif (typeof window !== \'undefined\') window.AWS = AWS;\nif (typeof module !== \'undefined\') module.exports = AWS;\nif (typeof self !== \'undefined\') self.AWS = AWS;\n\nif (!Object.prototype.hasOwnProperty.call(AWS, \'Connect\')) {\n  AWS.apiLoader.services[\'connect\'] = {};\n  AWS.Connect = AWS.Service.defineService(\'connect\', [ \'2017-02-15\' ]);\n}\nAWS.apiLoader.services[\'connect\'][\'2017-02-15\'] = require(\'../apis/connect-2017-02-15.min\');\n\nif (!Object.prototype.hasOwnProperty.call(AWS, \'STS\')) {\n  AWS.apiLoader.services[\'sts\'] = {};\n  AWS.STS = AWS.Service.defineService(\'sts\', [ \'2011-06-15\' ]);\n  require(\'./services/sts\');\n}\nAWS.apiLoader.services[\'sts\'][\'2011-06-15\'] = require(\'../apis/sts-2011-06-15.min\');\n\n\n},{"../apis/connect-2017-02-15.min":2,"../apis/sts-2011-06-15.min":4,"./browser_loader":8,"./core":10,"./services/sts":43}]},{},[146]);\n\n/*! @license sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro> | 3 clause BSD license */\n\n(function() {\n   var ctx = this;\n\n\tvar sprintf = function() {\n\t\tif (!sprintf.cache.hasOwnProperty(arguments[0])) {\n\t\t\tsprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);\n\t\t}\n\t\treturn sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);\n\t};\n\n\tsprintf.format = function(parse_tree, argv) {\n\t\tvar cursor = 1, tree_length = parse_tree.length, node_type = \'\', arg, output = [], i, k, match, pad, pad_character, pad_length;\n\t\tfor (i = 0; i < tree_length; i++) {\n\t\t\tnode_type = get_type(parse_tree[i]);\n\t\t\tif (node_type === \'string\') {\n\t\t\t\toutput.push(parse_tree[i]);\n\t\t\t}\n\t\t\telse if (node_type === \'array\') {\n\t\t\t\tmatch = parse_tree[i]; // convenience purposes only\n\t\t\t\tif (match[2]) { // keyword argument\n\t\t\t\t\targ = argv[cursor];\n\t\t\t\t\tfor (k = 0; k < match[2].length; k++) {\n\t\t\t\t\t\tif (!arg.hasOwnProperty(match[2][k])) {\n\t\t\t\t\t\t\tthrow(sprintf(\'[sprintf] property "%s" does not exist\', match[2][k]));\n\t\t\t\t\t\t}\n\t\t\t\t\t\targ = arg[match[2][k]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (match[1]) { // positional argument (explicit)\n\t\t\t\t\targ = argv[match[1]];\n\t\t\t\t}\n\t\t\t\telse { // positional argument (implicit)\n\t\t\t\t\targ = argv[cursor++];\n\t\t\t\t}\n\n\t\t\t\tif (/[^s]/.test(match[8]) && (get_type(arg) != \'number\')) {\n\t\t\t\t\tthrow(sprintf(\'[sprintf] expecting number but found %s\', get_type(arg)));\n\t\t\t\t}\n\t\t\t\tswitch (match[8]) {\n\t\t\t\t\tcase \'b\': arg = arg.toString(2); break;\n\t\t\t\t\tcase \'c\': arg = String.fromCharCode(arg); break;\n\t\t\t\t\tcase \'d\': arg = parseInt(arg, 10); break;\n\t\t\t\t\tcase \'e\': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;\n\t\t\t\t\tcase \'f\': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;\n\t\t\t\t\tcase \'o\': arg = arg.toString(8); break;\n\t\t\t\t\tcase \'s\': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;\n\t\t\t\t\tcase \'u\': arg = arg >>> 0; break;\n\t\t\t\t\tcase \'x\': arg = arg.toString(16); break;\n\t\t\t\t\tcase \'X\': arg = arg.toString(16).toUpperCase(); break;\n\t\t\t\t}\n\t\t\t\targ = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? \'+\'+ arg : arg);\n\t\t\t\tpad_character = match[4] ? match[4] == \'0\' ? \'0\' : match[4].charAt(1) : \' \';\n\t\t\t\tpad_length = match[6] - String(arg).length;\n\t\t\t\tpad = match[6] ? str_repeat(pad_character, pad_length) : \'\';\n\t\t\t\toutput.push(match[5] ? arg + pad : pad + arg);\n\t\t\t}\n\t\t}\n\t\treturn output.join(\'\');\n\t};\n\n\tsprintf.cache = {};\n\n\tsprintf.parse = function(fmt) {\n\t\tvar _fmt = fmt, match = [], parse_tree = [], arg_names = 0;\n\t\twhile (_fmt) {\n\t\t\tif ((match = /^[^\\x25]+/.exec(_fmt)) !== null) {\n\t\t\t\tparse_tree.push(match[0]);\n\t\t\t}\n\t\t\telse if ((match = /^\\x25{2}/.exec(_fmt)) !== null) {\n\t\t\t\tparse_tree.push(\'%\');\n\t\t\t}\n\t\t\telse if ((match = /^\\x25(?:([1-9]\\d*)\\$|\\(([^\\)]+)\\))?(\\+)?(0|\'[^$])?(-)?(\\d+)?(?:\\.(\\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {\n\t\t\t\tif (match[2]) {\n\t\t\t\t\targ_names |= 1;\n\t\t\t\t\tvar field_list = [], replacement_field = match[2], field_match = [];\n\t\t\t\t\tif ((field_match = /^([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\twhile ((replacement_field = replacement_field.substring(field_match[0].length)) !== \'\') {\n\t\t\t\t\t\t\tif ((field_match = /^\\.([a-z_][a-z_\\d]*)/i.exec(replacement_field)) !== null) {\n\t\t\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if ((field_match = /^\\[(\\d+)\\]/.exec(replacement_field)) !== null) {\n\t\t\t\t\t\t\t\tfield_list.push(field_match[1]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tthrow(\'[sprintf] huh?\');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthrow(\'[sprintf] huh?\');\n\t\t\t\t\t}\n\t\t\t\t\tmatch[2] = field_list;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\targ_names |= 2;\n\t\t\t\t}\n\t\t\t\tif (arg_names === 3) {\n\t\t\t\t\tthrow(\'[sprintf] mixing positional and named placeholders is not (yet) supported\');\n\t\t\t\t}\n\t\t\t\tparse_tree.push(match);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow(\'[sprintf] huh?\');\n\t\t\t}\n\t\t\t_fmt = _fmt.substring(match[0].length);\n\t\t}\n\t\treturn parse_tree;\n\t};\n\n\tvar vsprintf = function(fmt, argv, _argv) {\n\t\t_argv = argv.slice(0);\n\t\t_argv.splice(0, 0, fmt);\n\t\treturn sprintf.apply(null, _argv);\n\t};\n\n\t/**\n\t * helpers\n\t */\n\tfunction get_type(variable) {\n\t\treturn Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();\n\t}\n\n\tfunction str_repeat(input, multiplier) {\n\t\tfor (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}\n\t\treturn output.join(\'\');\n\t}\n\n\t/**\n\t * export to either browser or node.js\n\t */\n\tctx.sprintf = sprintf;\n\tctx.vsprintf = vsprintf;\n})();\n\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   // How frequently logs should be collected and reported to shared worker.\n   var LOG_REPORT_INTERVAL_MILLIS = 5000;\n   /**\n    * An enumeration of common logging levels.\n    */\n   var LogLevel = {\n      TEST:          "TEST",\n      TRACE:         "TRACE",\n      DEBUG:         "DEBUG",\n      INFO:          "INFO",\n      LOG:           "LOG",\n      WARN:          "WARN",\n      ERROR:         "ERROR",\n      CRITICAL:      "CRITICAL"\n   };\n\n   /**\n    * An enumeration of common logging components.\n    */\n   var LogComponent = {\n      CCP:          "CCP",\n      SOFTPHONE:    "SOFTPHONE"\n   };\n\n   /**\n    * The numeric order of the logging levels above.\n    * They are spaced to allow the addition of other log\n    * levels at a later time.\n    */\n   var LogLevelOrder = {\n      TEST:          0,\n      TRACE:         10,\n      DEBUG:         20,\n      INFO:          30,\n      LOG:           40,\n      WARN:          50,\n      ERROR:         100,\n      CRITICAL:      200\n\n   };\n\n   /**\n    * A map from log level to console logger function.\n    */\n   var CONSOLE_LOGGER_MAP = {\n      TRACE:         function(text) {console.info(text);},\n      DEBUG:         function(text) {console.info(text);},\n      INFO:          function(text) {console.info(text);},\n      LOG:           function(text) {console.log(text);},\n      TEST:          function(text) {console.log(text);},\n      WARN:          function(text) {console.warn(text);},\n      ERROR:         function(text) {console.error(text);},\n      CRITICAL:      function(text) {console.error(text);}\n   };\n\n    /**\n    * Checks if it is a valid log component enum\n    */\n\n    var isValidLogComponent = function(component) {\n        if (component === LogComponent.CCP || component === LogComponent.SOFTPHONE) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    /**\n    * Extract the custom arguments as required by the logger\n    */\n\n    var extractLoggerArgs = function(loggerArgs) {\n          var args = Array.prototype.slice.call(loggerArgs, 0);\n          var firstArg = args.shift();\n          var format;\n          var component;\n          if (isValidLogComponent(firstArg)) {\n            component = firstArg;\n            format = args.shift();\n          } else {\n            //default to CCP component\n            format= firstArg;\n            component = LogComponent.CCP;\n          }\n          return {format: format,\n                  component: component,\n                  args:  args};\n    };\n\n   /**\n    * A log entry.\n    *\n    * @param level The log level of this log entry.\n    * @param text The text contained in the log entry.\n    *\n    * Log entries are aware of their timestamp, order,\n    * and can contain objects and exception stack traces.\n    */\n   var LogEntry = function(component, level, text) {\n      this.component = component;\n      this.level = level;\n      this.text = text;\n      this.time = new Date();\n      this.exception = null;\n      this.objects = [];\n      this.line = 0;\n   };\n   LogEntry.fromObject = function(obj) {\n      var entry = new LogEntry(LogComponent.CCP, obj.level, obj.text);\n\n      // Required to check for Date objects sent across frame boundaries\n      if (Object.prototype.toString.call(obj.time) === \'[object Date]\') {\n         entry.time = new Date(obj.time.getTime());\n      } else if (typeof obj.time === \'number\') {\n         entry.time = new Date(obj.time);\n      } else if (typeof obj.time === \'string\') {\n         entry.time = Date.parse(obj.time);\n      } else {\n         entry.time = new Date();\n      }\n      entry.exception = obj.exception;\n      entry.objects = obj.objects;\n      return entry;\n   };\n\n   /**\n    * Pulls the type, message, and stack trace\n    * out of the given exception for JSON serialization.\n    */\n   var LoggedException = function(e) {\n      this.type = Object.prototype.toString.call(e);\n      this.message = e.message;\n      this.stack = e.stack ? e.stack.split(\'\\n\') : [];\n   };\n\n   /**\n    * Minimally stringify this log entry for printing\n    * to the console.\n    */\n   LogEntry.prototype.toString = function() {\n      return connect.sprintf("[%s] [%s]: %s",\n         this.getTime() && this.getTime().toISOString ? this.getTime().toISOString() : "???",\n         this.getLevel(),\n         this.getText());\n   };\n\n   /**\n    * Get the log entry timestamp.\n    */\n   LogEntry.prototype.getTime = function() {\n      return this.time;\n   };\n\n   /**\n    * Get the level of the log entry.\n    */\n   LogEntry.prototype.getLevel = function() {\n      return this.level;\n   };\n\n   /**\n    * Get the log entry text.\n    */\n   LogEntry.prototype.getText = function() {\n      return this.text;\n   };\n\n   /**\n    * Get the log entry component.\n    */\n   LogEntry.prototype.getComponent = function() {\n      return this.component;\n   };\n\n   /**\n    * Add an exception stack trace to this log entry.\n    * A log entry may contain only one exception stack trace.\n    */\n   LogEntry.prototype.withException = function(e) {\n      this.exception = new LoggedException(e);\n      return this;\n   };\n\n   /**\n    * Add an arbitrary object to the log entry.  A log entry\n    * may contain any number of objects.\n    */\n   LogEntry.prototype.withObject = function(obj) {\n      this.objects.push(connect.deepcopy(obj));\n      return this;\n   };\n\n   /**\n    * The logger instance.\n    */\n   var Logger = function() {\n      this._logs = [];\n      this._logsToPush = [];\n      this._echoLevel = LogLevelOrder.INFO;\n      this._logLevel = LogLevelOrder.INFO;\n      this._lineCount = 0;\n   };\n\n   /**\n    * Set the log level.  This is the minimum level at which logs will\n    * be kept for later archiving.\n    */\n   Logger.prototype.setLogLevel = function(level) {\n      if (level in LogLevelOrder) {\n         this._logLevel = LogLevelOrder[level];\n      } else {\n         throw new Error("Unknown logging level: " + level);\n      }\n   };\n\n   /**\n    * Set the echo level.  This is the minimum level at which logs will\n    * be printed to the javascript console.\n    */\n   Logger.prototype.setEchoLevel = function(level) {\n      if (level in LogLevelOrder) {\n         this._echoLevel = LogLevelOrder[level];\n      } else {\n         throw new Error("Unknown logging level: " + level);\n      }\n   };\n\n   /**\n    * Begin timed log rolling.  At each interval, the number of logs in the logger will be\n    * culled to the specified amount.\n    *\n    * @param setIntervalProc The proc used to create interval timers, typically should\n    *    just pass window.setInterval here.\n    * @param interval The interval in milliseconds to perform the culling.\n    * @param logEntries The maximum number of log entries to keep.\n    */\n   Logger.prototype.startLogRolling = function(setIntervalProc, interval, logEntries) {\n      setIntervalProc(connect.hitch(this, this.rollLogs, logEntries), interval);\n   };\n\n   /**\n    * Perform log rolling.  Culls the number of logs in the logger to the\n    * specified amount.\n    *\n    * @param logEntries The number of entries to limit the logger to contain.\n    */\n   Logger.prototype.rollLogs = function(logEntries) {\n      if (this._logs.length > logEntries) {\n         this._logs.splice(0, this._logs.length - logEntries);\n      }\n   };\n\n   /**\n    * Write a particular log entry.\n    *\n    * @param level The logging level of the entry.\n    * @param text The text contents of the entry.\n    *\n    * @returns The new log entry.\n    */\n   Logger.prototype.write = function(component, level, text) {\n      var logEntry = new LogEntry(component, level, text);\n      this.addLogEntry(logEntry);\n      return logEntry;\n   };\n\n   Logger.prototype.addLogEntry = function(logEntry) {\n      this._logs.push(logEntry);\n      //For now only send softphone logs only.\n      //TODO add CCP logs once we are sure that no sensitive data is being logged.\n      if (LogComponent.SOFTPHONE === logEntry.component) {\n         this._logsToPush.push(logEntry);\n      }\n\n      if (logEntry.level in LogLevelOrder &&\n          LogLevelOrder[logEntry.level] >= this._logLevel) {\n\n         if (LogLevelOrder[logEntry.level] >= this._echoLevel) {\n            CONSOLE_LOGGER_MAP[logEntry.getLevel()](logEntry.toString());\n         }\n\n         logEntry.line = this._lineCount++;\n      }\n   };\n\n   /**\n    * Remove all objects from all log entries.\n    */\n   Logger.prototype.clearObjects = function() {\n      for (var x = 0; x < this._logs.length; x++) {\n         if (this._logs[x].objects) {\n            delete this._logs[x].objects;\n         }\n      }\n   };\n\n   /**\n    * Remove all exception stack traces from the log entries.\n    */\n   Logger.prototype.clearExceptions = function() {\n      for (var x = 0; x < this._logs.length; x++) {\n         if (this._logs[x].exception) {\n            delete this._logs[x].exception;\n         }\n      }\n   };\n\n   Logger.prototype.trace = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.TRACE, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   Logger.prototype.debug = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.DEBUG, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   Logger.prototype.info = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.INFO, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   Logger.prototype.log = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.LOG, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   Logger.prototype.test = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.TEST, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   Logger.prototype.warn = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.WARN, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   Logger.prototype.error = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   Logger.prototype.critical = function() {\n      var logArgs = extractLoggerArgs(arguments);\n      return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));\n   };\n\n   /**\n    * Create a string representation of the logger contents.\n    */\n   Logger.prototype.toString = function() {\n      var lines = [];\n      for (var x = 0; x < this._logs.length; x++) {\n         lines.push(this._logs[x].toString());\n      }\n\n      return lines.join("\\n");\n   };\n\n   Logger.prototype.download = function() {\n      var logBuffer = "data:text/plain;base64," + window.btoa(JSON.stringify(this, undefined, 4));\n      var downloadLink = document.createElement(\'a\');\n      downloadLink.href = logBuffer;\n      downloadLink.download = \'agent-log.txt\';\n      document.body.appendChild(downloadLink);\n      downloadLink.click();\n      document.body.removeChild(downloadLink);\n   };\n\n   Logger.prototype.scheduleUpstreamLogPush = function(conduit) {\n      if (!connect.upstreamLogPushScheduled) {\n          connect.upstreamLogPushScheduled = true;\n          /** Schedule pushing logs frequently to sharedworker upstream, sharedworker will report to LARS*/\n          global.setInterval(connect.hitch(this, this.reportMasterLogsUpStream, conduit), LOG_REPORT_INTERVAL_MILLIS);\n      }\n   };\n\n   Logger.prototype.reportMasterLogsUpStream = function(conduit) {\n      var logsToPush = this._logsToPush.slice();\n      this._logsToPush = [];\n      connect.ifMaster(connect.MasterTopics.SEND_LOGS, function(){\n          if (logsToPush.length > 0) {\n             conduit.sendUpstream(connect.EventType.SEND_LOGS, logsToPush);\n          }\n      });\n   };\n\n   var DownstreamConduitLogger = function(conduit) {\n      Logger.call(this);\n      this.conduit = conduit;\n      global.setInterval(connect.hitch(this, this._pushLogsDownstream),\n            DownstreamConduitLogger.LOG_PUSH_INTERVAL);\n   };\n   // How frequently logs should be collected and delivered downstream.\n   DownstreamConduitLogger.LOG_PUSH_INTERVAL = 1000;\n   DownstreamConduitLogger.prototype = Object.create(Logger.prototype);\n   DownstreamConduitLogger.prototype.constructor = DownstreamConduitLogger;\n\n   DownstreamConduitLogger.prototype._pushLogsDownstream = function() {\n      var self = this;\n      this._logs.forEach(function(log) {\n         self.conduit.sendDownstream(connect.EventType.LOG, log);\n      });\n      this._logs = [];\n   };\n\n   /** Create the singleton logger instance. */\n   connect.rootLogger = new Logger();\n\n   /** Fetch the singleton logger instance. */\n   var getLog = function() {\n      return connect.rootLogger;\n   };\n\n   connect = connect || {};\n   connect.getLog = getLog;\n   connect.LogEntry = LogEntry;\n   connect.Logger = Logger;\n   connect.LogLevel = LogLevel;\n   connect.LogComponent = LogComponent;\n   connect.DownstreamConduitLogger = DownstreamConduitLogger;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   var ONE_DAY_MILLIS = 24*60*60*1000;\n\n   /**\n    * Unpollute sprintf functions from the global namespace.\n    */\n   connect.sprintf = global.sprintf;\n   connect.vsprintf = global.vsprintf;\n   delete global.sprintf;\n   delete global.vsprintf;\n\n   /**\n    * Binds the given instance object as the context for\n    * the method provided.\n    *\n    * @param scope The instance object to be set as the scope\n    *    of the function.\n    * @param method The method to be encapsulated.\n    *\n    * All other arguments, if any, are bound to the method\n    * invocation inside the closure.\n    *\n    * @return A closure encapsulating the invocation of the\n    *    method provided in context of the given instance.\n    */\n   connect.hitch = function() {\n      var args = Array.prototype.slice.call(arguments);\n      var scope = args.shift();\n      var method = args.shift();\n\n      connect.assertNotNull(scope, \'scope\');\n      connect.assertNotNull(method, \'method\');\n      connect.assertTrue(connect.isFunction(method), \'method must be a function\');\n\n      return function() {\n         var closureArgs = Array.prototype.slice.call(arguments);\n         return method.apply(scope, args.concat(closureArgs));\n      };\n   };\n\n   /**\n    * Determine if the given value is a callable function type.\n    * Borrowed from Underscore.js.\n    */\n   connect.isFunction = function(obj) {\n      return !!(obj && obj.constructor && obj.call && obj.apply);\n   };\n\n   /**\n    * Determine if the given value is an array.\n    */\n   connect.isArray = function(obj) {\n      return Object.prototype.toString.call(obj) === \'[object Array]\';\n   };\n\n   /**\n    * Get a list of keys from a Javascript object used\n    * as a hash map.\n    */\n   connect.keys = function(map) {\n      var keys = [];\n\n      connect.assertNotNull(map, \'map\');\n\n      for (var k in map) {\n         keys.push(k);\n      }\n\n      return keys;\n   };\n\n   /**\n    * Get a list of values from a Javascript object used\n    * as a hash map.\n    */\n   connect.values = function(map) {\n      var values = [];\n\n      connect.assertNotNull(map, \'map\');\n\n      for (var k in map) {\n         values.push(map[k]);\n      }\n\n      return values;\n   };\n\n   /**\n    * Get a list of key/value pairs from the given map.\n    */\n   connect.entries = function(map) {\n      var entries = [];\n\n      for (var k in map) {\n         entries.push({key: k, value: map[k]});\n      }\n\n      return entries;\n   };\n\n   /**\n    * Merge two or more maps together into a new map,\n    * or simply copy a single map.\n    */\n   connect.merge = function() {\n      var argMaps = Array.prototype.slice.call(arguments, 0);\n      var resultMap = {};\n\n      argMaps.forEach(function(map) {\n         connect.entries(map).forEach(function(kv) {\n            resultMap[kv.key] = kv.value;\n         });\n      });\n\n      return resultMap;\n   };\n\n   connect.now = function() {\n      return new Date().getTime();\n   };\n\n   connect.find = function(array, predicate) {\n      for (var x = 0; x < array.length; x++) {\n         if (predicate(array[x])) {\n            return array[x];\n         }\n      }\n\n      return null;\n   };\n\n   connect.contains = function(obj, value) {\n      if (obj instanceof Array) {\n         return connect.find(obj, function(v) { return v === value; }) != null;\n\n      } else {\n         return (value in obj);\n      }\n   };\n\n   connect.containsValue = function(obj, value) {\n      if (obj instanceof Array) {\n         return connect.find(obj, function(v) { return v === value; }) != null;\n\n      } else {\n         return connect.find(connect.values(obj), function(v) { return v === value; }) != null;\n      }\n   };\n\n   /**\n    * Generate a random ID consisting of the current timestamp\n    * and a random base-36 number based on Math.random().\n    */\n   connect.randomId = function() {\n      return connect.sprintf("%s-%s", connect.now(), Math.random().toString(36).slice(2));\n   };\n\n   /**\n    * Generate an enum from the given list of lower-case enum values,\n    * where the enum keys will be upper case.\n    *\n    * Conversion from pascal case based on code from here:\n    * http://stackoverflow.com/questions/30521224\n    */\n   connect.makeEnum = function(values) {\n      var enumObj = {};\n\n      values.forEach(function(value) {\n         var key = value.replace(/\\.?([a-z]+)_?/g, function (x, y) { return y.toUpperCase() + "_"; })\n            .replace(/_$/, "");\n\n         enumObj[key] = value;\n      });\n\n      return enumObj;\n   };\n\n   connect.makeNamespacedEnum = function(prefix, values) {\n      var enumObj = connect.makeEnum(values);\n      connect.keys(enumObj).forEach(function(key) {\n         enumObj[key] = connect.sprintf("%s::%s", prefix, enumObj[key]);\n      });\n      return enumObj;\n   };\n\n   /**\n    * Return a map of items in the given list indexed by\n    * keys determined by the closure provided.\n    *\n    * @param iterable A list-like object.\n    * @param closure A closure to determine the index for the\n    *    items in the iterable.\n    * @return A map from index to item for each item in the iterable.\n    */\n   connect.index = function(iterable, closure) {\n      var map = {};\n\n      iterable.forEach(function(item) {\n         map[closure(item)] = item;\n      });\n\n      return map;\n   };\n\n   /**\n    * Converts the given array into a map as a set,\n    * where elements in the array are mapped to 1.\n    */\n   connect.set = function(arrayIn) {\n      var setMap = {};\n\n      arrayIn.forEach(function(key) {\n         setMap[key] = 1;\n      });\n\n      return setMap;\n   };\n\n   /**\n    * Returns a map for each key in mapB which\n    * is NOT in mapA.\n    */\n   connect.relativeComplement = function(mapA, mapB) {\n      var compMap = {};\n\n      connect.keys(mapB).forEach(function(key) {\n         if (! (key in mapA)) {\n            compMap[key] = mapB[key];\n         }\n      });\n\n      return compMap;\n   };\n\n   /**\n    * Asserts that a premise is true.\n    */\n   connect.assertTrue = function(premise, message) {\n      if (! premise) {\n         throw new connect.ValueError(message);\n      }\n   };\n\n   /**\n    * Asserts that a value is not null or undefined.\n    */\n   connect.assertNotNull = function(value, name) {\n      connect.assertTrue(value != null && typeof value !== undefined,\n            connect.sprintf("%s must be provided", name || \'A value\'));\n      return value;\n   };\n\n   connect.deepcopy = function(src) {\n      return JSON.parse(JSON.stringify(src));\n   };\n\n   /**\n    * Get the current base url of the open page, e.g. if the page is\n    * https://example.com:9494/oranges, this will be "https://example.com:9494".\n    */\n   connect.getBaseUrl = function() {\n      var location = global.location;\n      return connect.sprintf("%s//%s:%s", location.protocol, location.hostname, location.port);\n   };\n\n   /**\n    * Determine if the current window is in an iframe.\n    * Courtesy: http://stackoverflow.com/questions/326069/\n    */\n   connect.isFramed = function() {\n      try {\n         return window.self !== window.top;\n      } catch (e) {\n         return true;\n      }\n   };\n\n   /**\n    * A wrapper around Window.open() for managing single instance popups.\n    */\n   connect.PopupManager = function() {};\n\n   connect.PopupManager.prototype.open = function(url, name) {\n      var then = this._getLastOpenedTimestamp(name);\n      var now = new Date().getTime();\n\n      if (now - then > ONE_DAY_MILLIS) {\n         var win = window.open(\'\', name);\n         if (win.location !== url) {\n            window.open(url, name);\n         }\n         this._setLastOpenedTimestamp(name, now);\n      }\n   };\n\n   connect.PopupManager.prototype.clear = function(name) {\n      var key = this._getLocalStorageKey(name);\n      global.localStorage.removeItem(key);\n   };\n\n   connect.PopupManager.prototype._getLastOpenedTimestamp = function(name) {\n      var key = this._getLocalStorageKey(name);\n      var value = global.localStorage.getItem(key);\n\n      if (value) {\n         return parseInt(value, 10);\n\n      } else {\n         return 0;\n      }\n   };\n\n   connect.PopupManager.prototype._setLastOpenedTimestamp = function(name, ts) {\n      var key = this._getLocalStorageKey(name);\n      global.localStorage.setItem(key, \'\' + ts);\n   };\n\n   connect.PopupManager.prototype._getLocalStorageKey = function(name) {\n      return "connectPopupManager::" + name;\n   };\n\n   /**\n    * An enumeration of the HTML5 notification permission values.\n    */\n   var NotificationPermission = connect.makeEnum([\n      \'granted\',\n      \'denied\',\n      \'default\'\n   ]);\n\n   /**\n    * A simple engine for showing notification popups.\n    */\n   connect.NotificationManager = function() {\n      this.queue = [];\n      this.permission = NotificationPermission.DEFAULT;\n   };\n\n   connect.NotificationManager.prototype.requestPermission = function() {\n      var self = this;\n      if (!("Notification" in global)) {\n         connect.getLog().warn("This browser doesn\'t support notifications.");\n         this.permission = NotificationPermission.DENIED;\n\n      } else if (global.Notification.permission === NotificationPermission.DENIED) {\n         connect.getLog().warn("The user has requested to not receive notifications.");\n         this.permission = NotificationPermission.DENIED;\n\n      } else if (this.permission !== NotificationPermission.GRANTED) {\n         global.Notification.requestPermission(function(permission) {\n            self.permission = permission;\n            if (permission === NotificationPermission.GRANTED) {\n               self._showQueued();\n\n            } else {\n               self.queue = [];\n            }\n         });\n      }\n   };\n\n   connect.NotificationManager.prototype.show = function(title, options) {\n      if (this.permission === NotificationPermission.GRANTED) {\n         return this._showImpl({title: title, options: options});\n\n      } else if (this.permission === NotificationPermission.DENIED) {\n         connect.getLog().warn("Unable to show notification.").withObject({\n            title: title,\n            options: options\n         });\n\n      } else {\n         var params = {title: title, options: options};\n         connect.getLog().warn("Deferring notification until user decides to allow or deny.")\n            .withObject(params);\n         this.queue.push(params);\n      }\n   };\n\n   connect.NotificationManager.prototype._showQueued = function() {\n      var self = this;\n      var notifications = this.queue.map(function(params) {\n         return self._showImpl(params);\n      });\n      this.queue = [];\n      return notifications;\n   };\n\n   connect.NotificationManager.prototype._showImpl = function(params) {\n      var notification = new global.Notification(params.title, params.options);\n      if (params.options.clicked) {\n         notification.onclick = function() {\n            params.options.clicked.call(notification);\n         };\n      }\n      return notification;\n   };\n\n   connect.BaseError = function(format, args) {\n      global.Error.call(this, connect.vsprintf(format, args));\n   };\n   connect.BaseError.prototype = Object.create(Error.prototype);\n   connect.BaseError.prototype.constructor = connect.BaseError;\n\n   connect.ValueError = function() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      var format = args.shift();\n      connect.BaseError.call(this, format, args);\n   };\n   connect.ValueError.prototype = Object.create(connect.BaseError.prototype);\n   connect.ValueError.prototype.constructor = connect.ValueError;\n\n   connect.NotImplementedError = function() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      var format = args.shift();\n      connect.BaseError.call(this, format, args);\n   };\n   connect.NotImplementedError.prototype = Object.create(connect.BaseError.prototype);\n   connect.NotImplementedError.prototype.constructor = connect.NotImplementedError;\n\n   connect.StateError = function() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      var format = args.shift();\n      connect.BaseError.call(this, format, args);\n   };\n   connect.StateError.prototype = Object.create(connect.BaseError.prototype);\n   connect.StateError.prototype.constructor = connect.StateError;\n\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n\n   var ALL_EVENTS = \'<<all>>\';\n\n   /**---------------------------------------------------------------\n    * enum EventType\n    */\n   var EventType = connect.makeEnum([\n         \'acknowledge\',\n         \'ack_timeout\',\n         \'api_request\',\n         \'api_response\',\n         \'auth_fail\',\n         \'close\',\n         \'configure\',\n         \'log\',\n         \'master_request\',\n         \'master_response\',\n         \'synchronize\',\n         \'terminate\',\n         \'terminated\',\n         \'send_logs\',\n         \'reload_agent_configuration\'\n   ]);\n\n   /**---------------------------------------------------------------\n    * enum MasterTopics\n    */\n   var MasterTopics = connect.makeNamespacedEnum(\'connect\', [\n         \'loginPopup\',\n         \'sendLogs\',\n         \'softphone\'\n   ]);\n\n   /**---------------------------------------------------------------\n    * enum AgentEvents\n    */\n   var AgentEvents = connect.makeNamespacedEnum(\'agent\', [\n         \'init\',\n         \'update\',\n         \'refresh\',\n         \'routable\',\n         \'not_routable\',\n         \'pending\',\n         \'contact_pending\',\n         \'offline\',\n         \'error\',\n         \'softphone_error\',\n         \'state_change\',\n         \'acw\'\n   ]);\n\n   /**---------------------------------------------------------------\n    * enum ContactEvents\n    */\n   var ContactEvents = connect.makeNamespacedEnum(\'contact\', [\n         \'init\',\n         \'refresh\',\n         \'destroyed\',\n         \'incoming\',\n         \'pending\',\n         \'connecting\',\n         \'connected\',\n         \'missed\',\n         \'acw\',\n         \'ended\',\n         \'error\',\n         \'accepted\'\n   ]);\n\n   /**---------------------------------------------------------------\n    * class EventFactory\n    */\n   var EventFactory = function() {};\n   EventFactory.createRequest = function(type, method, params) {\n      return {\n         event:      type,\n         requestId:  connect.randomId(),\n         method:     method,\n         params:     params\n      };\n   };\n\n   EventFactory.createResponse = function(type, request, data, err) {\n      return {\n         event:      type,\n         requestId:  request.requestId,\n         data:       data,\n         err:        err || null\n      };\n   };\n\n   /**\n    * An object representing an event subscription in an EventBus.\n    */\n   var Subscription = function(subMap, eventName, f) {\n      this.subMap = subMap;\n      this.id = connect.randomId();\n      this.eventName = eventName;\n      this.f = f;\n   };\n\n   /**\n    * Unsubscribe the handler of this subscription from the EventBus\n    * from which it was created.\n    */\n   Subscription.prototype.unsubscribe = function() {\n      this.subMap.unsubscribe(this.eventName, this.id);\n   };\n\n   /**\n    * A map of event subscriptions, used by the EventBus.\n    */\n   var SubscriptionMap = function() {\n      this.subIdMap = {};\n      this.subEventNameMap = {};\n   };\n\n   /**\n    * Add a subscription for the named event.  Creates a new Subscription\n    * object and returns it.  This object can be used to unsubscribe.\n    */\n   SubscriptionMap.prototype.subscribe = function(eventName, f) {\n      var sub = new Subscription(this, eventName, f);\n\n      this.subIdMap[sub.id] = sub;\n      var subList = this.subEventNameMap[eventName] || [];\n      subList.push(sub);\n      this.subEventNameMap[eventName] = subList;\n   };\n\n   /**\n    * Unsubscribe a subscription matching the given event name and id.\n    */\n   SubscriptionMap.prototype.unsubscribe = function(eventName, subId) {\n      if (connect.contains(this.subEventNameMap, eventName)) {\n         this.subEventNameMap[eventName] = this.subEventNameMap[eventName].filter(function(s) { return s.id !== subId; });\n\n         if (this.subEventNameMap[eventName].length < 1) {\n            delete this.subEventNameMap[eventName];\n         }\n      }\n\n      if (connect.contains(this.subIdMap, subId)) {\n         delete this.subIdMap[subId];\n      }\n   };\n\n   /**\n    * Get a list of all subscriptions in the subscription map.\n    */\n   SubscriptionMap.prototype.getAllSubscriptions = function() {\n      return connect.values(this.subEventNameMap).reduce(function(a, b) {\n         return a.concat(b);\n      }, []);\n   };\n\n   /**\n    * Get a list of subscriptions for the given event name, or an empty\n    * list if there are no subscriptions.\n    */\n   SubscriptionMap.prototype.getSubscriptions = function(eventName) {\n      return this.subEventNameMap[eventName] || [];\n   };\n\n   /**\n    * An object which maintains a map of subscriptions and serves as the\n    * mechanism for triggering events to be handled by subscribers.\n    */\n   var EventBus = function(paramsIn) {\n      var params = paramsIn || {};\n\n      this.subMap = new SubscriptionMap();\n      this.logEvents = params.logEvents || false;\n   };\n\n   /**\n    * Subscribe to the named event.  Returns a new Subscription object\n    * which can be used to unsubscribe.\n    */\n   EventBus.prototype.subscribe = function(eventName, f) {\n      connect.assertNotNull(eventName, \'eventName\');\n      connect.assertNotNull(f, \'f\');\n      connect.assertTrue(connect.isFunction(f), \'f must be a function\');\n      return this.subMap.subscribe(eventName, f);\n   };\n\n   /**\n    * Subscribe a function to be called on all events.\n    */\n   EventBus.prototype.subscribeAll = function(f) {\n      connect.assertNotNull(f, \'f\');\n      connect.assertTrue(connect.isFunction(f), \'f must be a function\');\n      return this.subMap.subscribe(ALL_EVENTS, f);\n   };\n\n   /**\n    * Get a list of subscriptions for the given event name, or an empty\n    * list if there are no subscriptions.\n    */\n   EventBus.prototype.getSubscriptions = function(eventName) {\n      return this.subMap.getSubscriptions(eventName);\n   };\n\n   /**\n    * Trigger the given event with the given data.  All methods subscribed\n    * to this event will be called and are provided with the given arbitrary\n    * data object and the name of the event, in that order.\n    */\n   EventBus.prototype.trigger = function(eventName, data) {\n      connect.assertNotNull(eventName, \'eventName\');\n      var self = this;\n      var allEventSubs = this.subMap.getSubscriptions(ALL_EVENTS);\n      var eventSubs = this.subMap.getSubscriptions(eventName);\n\n      if (this.logEvents) {\n         connect.getLog().trace("Publishing event: %s", eventName);\n      }\n\n      allEventSubs.concat(eventSubs).forEach(function(sub) {\n         try {\n            sub.f(data || null, eventName, self);\n\n         } catch (e) {\n            connect.getLog().error("\'%s\' event handler failed.", eventName).withException(e);\n         }\n      });\n   };\n\n   /**\n    * Returns a closure which bridges an event from another EventBus to this bus.\n    *\n    * Usage:\n    * conduit.onUpstream("MyEvent", bus.bridge());\n    */\n   EventBus.prototype.bridge = function() {\n      var self = this;\n      return function(data, event) {\n         self.trigger(event, data);\n      };\n   };\n\n   /**\n    * Unsubscribe all events in the event bus.\n    */\n   EventBus.prototype.unsubscribeAll = function() {\n      this.subMap.getAllSubscriptions().forEach(function(sub) {\n         sub.unsubscribe();\n      });\n   };\n\n   connect.EventBus = EventBus;\n   connect.EventFactory = EventFactory;\n   connect.EventType = EventType;\n   connect.AgentEvents = AgentEvents;\n   connect.ContactEvents = ContactEvents;\n   connect.MasterTopics = MasterTopics;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   /**---------------------------------------------------------------\n    * class Stream\n    *\n    * Represents an object from which messages can be read and to which\n    * messages can be sent.\n    */\n   var Stream = function() {};\n\n   /**\n    * Send a message to the stream.  This method must be implemented by subclasses.\n    */\n   Stream.prototype.send = function(message) {\n      throw new connect.NotImplementedError();\n   };\n\n   /**\n    * Provide a method to be called when messages are received from this stream.\n    * This method must be implemented by subclasses.\n    */\n   Stream.prototype.onMessage = function(f) {\n      throw new connect.NotImplementedError();\n   };\n\n   /**---------------------------------------------------------------\n    * class NullStream extends Stream\n    *\n    * A null stream which provides no message sending or receiving facilities.\n    */\n   var NullStream = function() {\n      Stream.call(this);\n   };\n   NullStream.prototype = Object.create(Stream.prototype);\n   NullStream.prototype.constructor = NullStream;\n\n   NullStream.prototype.onMessage = function(f) {};\n   NullStream.prototype.send = function(message) {};\n\n   /**---------------------------------------------------------------\n    * class WindowStream extends Stream\n    *\n    * A stream for communicating with a window object.  The domain provided\n    * must match the allowed message domains of the downstream receiver\n    * or messages will be rejected, see https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage\n    * for more info.\n    */\n   var WindowStream = function(win, domain) {\n      Stream.call(this);\n      this.window = win;\n      this.domain = domain || \'*\';\n   };\n   WindowStream.prototype = Object.create(Stream.prototype);\n   WindowStream.prototype.constructor = WindowStream;\n\n   WindowStream.prototype.send = function(message) {\n      this.window.postMessage(message, this.domain);\n   };\n\n   WindowStream.prototype.onMessage = function(f) {\n      this.window.addEventListener("message", f);\n   };\n\n   /**---------------------------------------------------------------\n    * class WindowIOStream extends Stream\n    *\n    * A stream used by IFrame/popup windows to communicate with their parents\n    * and vise versa.\n    *\n    * This object encapsulates the fact that incoming and outgoing messages\n    * arrive on different windows and allows this to be managed as a single\n    * Stream object.\n    */\n   var WindowIOStream = function(inputwin, outputwin, domain) {\n      Stream.call(this);\n      this.input = inputwin;\n      this.output = outputwin;\n      this.domain = domain || \'*\';\n   };\n   WindowIOStream.prototype = Object.create(Stream.prototype);\n   WindowIOStream.prototype.constructor = WindowIOStream;\n\n   WindowIOStream.prototype.send = function(message) {\n      this.output.postMessage(message, this.domain);\n   };\n\n   WindowIOStream.prototype.onMessage = function(f) {\n      this.input.addEventListener("message", f);\n   };\n\n   /**---------------------------------------------------------------\n    * class PortStream extends Stream\n    *\n    * A stream wrapping an HTML5 Worker port.  This could be the port\n    * used to connect to a Worker or one of the multitude of ports\n    * made available to a SharedWorker for communication back to\n    * its connected clients.\n    */\n   var PortStream = function(port) {\n      Stream.call(this);\n      this.port = port;\n      this.id = connect.randomId();\n   };\n   PortStream.prototype = Object.create(Stream.prototype);\n   PortStream.prototype.constructor = PortStream;\n\n   PortStream.prototype.send = function(message) {\n      this.port.postMessage(message);\n   };\n\n   PortStream.prototype.onMessage = function(f) {\n      this.port.addEventListener("message", f);\n   };\n\n   PortStream.prototype.getId = function() {\n      return this.id;\n   };\n\n   /**---------------------------------------------------------------\n    * class StreamMultiplexer extends Stream\n    *\n    * A wrapper for multiplexed downstream communication with\n    * multiple streams at once.  Mainly useful for the SharedWorker to\n    * broadcast events to many PortStream objects at once.\n    */\n   var StreamMultiplexer = function(streams) {\n      Stream.call(this);\n      this.streamMap = streams ?\n         connect.index(streams, function(s) { return s.getId(); }) : {};\n      this.messageListeners = [];\n   };\n   StreamMultiplexer.prototype = Object.create(Stream.prototype);\n   StreamMultiplexer.prototype.constructor = StreamMultiplexer;\n\n   /**\n    * Send a message to all ports in the multiplexer.\n    */\n   StreamMultiplexer.prototype.send = function(message) {\n      this.getStreams().forEach(function(stream) {\n         try {\n            stream.send(message);\n\n         } catch (e) {\n            // Couldn\'t send message to one of the downstreams for some reason...\n            // No reliable logging possible without further failures,\n            // no recovery, just eat it.\n         }\n      });\n   };\n\n   /**\n    * Register a method which will be called when a message is received from\n    * any of the downstreams.\n    */\n   StreamMultiplexer.prototype.onMessage = function(f) {\n      this.messageListeners.push(f);\n\n      // Update existing streams with the new listener.\n      this.getStreams().forEach(function(stream) {\n         stream.onMessage(f);\n      });\n   };\n\n   /**\n    * Add a stream to the multiplexer.\n    */\n   StreamMultiplexer.prototype.addStream = function(stream) {\n      var self = this;\n      this.streamMap[stream.getId()] = stream;\n\n      // Update stream with existing listeners.\n      this.messageListeners.forEach(function(messageListener) {\n         stream.onMessage(messageListener);\n      });\n   };\n\n   /**\n    * Remove the given downstream.  This is typically used in response\n    * to the SharedWorker\'s onclose event, indicating that a consumer\n    * tab has been closed.\n    */\n   StreamMultiplexer.prototype.removeStream = function(stream) {\n      delete this.streamMap[stream.getId()];\n   };\n\n   /**\n    * Get a list of streams in the multiplexer.\n    */\n   StreamMultiplexer.prototype.getStreams = function(stream) {\n      return connect.values(this.streamMap);\n   };\n\n   /**\n    * Get the stream matching the given port.\n    */\n   StreamMultiplexer.prototype.getStreamForPort = function(port) {\n      return connect.find(this.getStreams(), function(s) {\n         return s.port === port;\n      });\n   };\n\n   /**---------------------------------------------------------------\n    * class Conduit\n    *\n    * An object which bridges an upstream and a downstream, allowing messages\n    * to be passed to and from each and providing an event bus for event\n    * subscriptions to be made upstream and downstream.\n    */\n   var Conduit = function(name, upstream, downstream) {\n      this.name = name;\n      this.upstream = upstream || new NullStream();\n      this.downstream = downstream || new NullStream();\n      this.downstreamBus = new connect.EventBus();\n      this.upstreamBus = new connect.EventBus();\n\n      this.upstream.onMessage(connect.hitch(this, this._dispatchEvent, this.upstreamBus));\n      this.downstream.onMessage(connect.hitch(this, this._dispatchEvent, this.downstreamBus));\n   };\n\n   Conduit.prototype.onUpstream = function(eventName, f) {\n      connect.assertNotNull(eventName, \'eventName\');\n      connect.assertNotNull(f, \'f\');\n      connect.assertTrue(connect.isFunction(f), \'f must be a function\');\n      return this.upstreamBus.subscribe(eventName, f);\n   };\n\n   Conduit.prototype.onAllUpstream = function(f) {\n      connect.assertNotNull(f, \'f\');\n      connect.assertTrue(connect.isFunction(f), \'f must be a function\');\n      return this.upstreamBus.subscribeAll(f);\n   };\n\n   Conduit.prototype.onDownstream = function(eventName, f) {\n      connect.assertNotNull(eventName, \'eventName\');\n      connect.assertNotNull(f, \'f\');\n      connect.assertTrue(connect.isFunction(f), \'f must be a function\');\n      return this.downstreamBus.subscribe(eventName, f);\n   };\n\n   Conduit.prototype.onAllDownstream = function(f) {\n      connect.assertNotNull(f, \'f\');\n      connect.assertTrue(connect.isFunction(f), \'f must be a function\');\n      return this.downstreamBus.subscribeAll(f);\n   };\n\n   Conduit.prototype.sendUpstream = function(eventName, data) {\n      connect.assertNotNull(eventName, \'eventName\');\n      this.upstream.send({event: eventName, data: data});\n   };\n\n   Conduit.prototype.sendDownstream = function(eventName, data) {\n      connect.assertNotNull(eventName, \'eventName\');\n      this.downstream.send({event: eventName, data: data});\n   };\n\n   Conduit.prototype._dispatchEvent = function(bus, messageEvent) {\n      var message = messageEvent.data;\n      if (message.event) {\n         bus.trigger(message.event, message.data);\n      }\n   };\n\n   /**\n    * Returns a closure which passes events upstream.\n    *\n    * Usage:\n    * conduit.onUpstream("MyEvent", conduit.passUpstream());\n    */\n   Conduit.prototype.passUpstream = function() {\n      var self = this;\n      return function(data, eventName) {\n         self.upstream.send({event: eventName, data: data});\n      };\n   };\n\n   /**\n    * Returns a closure which passes events downstream.\n    *\n    * Usage:\n    * conduit.onUpstream("MyEvent", conduit.passDownstream());\n    */\n   Conduit.prototype.passDownstream = function() {\n      var self = this;\n      return function(data, eventName) {\n         self.downstream.send({event: eventName, data: data});\n      };\n   };\n\n   /**\n    * Shutdown the conduit\'s event busses and remove all subscriptions.\n    */\n   Conduit.prototype.shutdown = function() {\n      this.upstreamBus.unsubscribeAll();\n      this.downstreamBus.unsubscribeAll();\n   };\n\n   /**---------------------------------------------------------------\n    * class IFrameConduit extends Conduit\n    *\n    * Creates a conduit for the given IFrame element.\n    */\n   var IFrameConduit = function(name, window, iframe, domain) {\n      Conduit.call(this, name, new WindowIOStream(window, iframe.contentWindow, domain || \'*\'), null);\n   };\n   IFrameConduit.prototype = Object.create(Conduit.prototype);\n   IFrameConduit.prototype.constructor = IFrameConduit;\n\n   connect.Stream = Stream;\n   connect.NullStream = NullStream;\n   connect.WindowStream = WindowStream;\n   connect.WindowIOStream = WindowIOStream;\n   connect.PortStream = PortStream;\n   connect.StreamMultiplexer = StreamMultiplexer;\n   connect.Conduit = Conduit;\n   connect.IFrameConduit = IFrameConduit;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   /**---------------------------------------------------------------\n    * enum ClientMethods\n    */\n   connect.ClientMethods = connect.makeEnum([\n         \'getAgentSnapshot\',\n         \'putAgentState\',\n         \'getAgentStates\',\n         \'getDialableCountryCodes\',\n         \'getRoutingProfileQueues\',\n         \'getAgentPermissions\',\n         \'getAgentConfiguration\',\n         \'updateAgentConfiguration\',\n         \'acceptContact\',\n         \'createOutboundContact\',\n         \'destroyContact\',\n         \'notifyContactIssue\',\n         \'updateContactAttributes\',\n         \'createAdditionalConnection\',\n         \'destroyConnection\',\n         \'holdConnection\',\n         \'resumeConnection\',\n         \'toggleActiveConnections\',\n         \'conferenceConnections\',\n         \'sendClientLogs\',\n         \'sendDigits\',\n         \'sendSoftphoneCallReport\',\n         \'sendSoftphoneCallMetrics\',\n         \'getEndpoints\',\n         \'getNewAuthToken\'\n   ]);\n\n   /**---------------------------------------------------------------\n    * enum MasterMethods\n    */\n   connect.MasterMethods = connect.makeEnum([\n         \'becomeMaster\',\n         \'checkMaster\'\n   ]);\n\n   /**---------------------------------------------------------------\n    * abstract class ClientBase\n    */\n   var ClientBase = function() {};\n   ClientBase.EMPTY_CALLBACKS = {\n      success: function() { },\n      failure: function() { }\n   };\n\n   ClientBase.prototype.call = function(method, paramsIn, callbacksIn) {\n      connect.assertNotNull(method, \'method\');\n      var params = paramsIn || {};\n      var callbacks = callbacksIn || ClientBase.EMPTY_CALLBACKS;\n      this._callImpl(method, params, callbacks);\n   };\n\n   ClientBase.prototype._callImpl = function(method, params, callbacks) {\n      throw new connect.NotImplementedError();\n   };\n\n   /**---------------------------------------------------------------\n    * class NullClient extends ClientBase\n    */\n   var NullClient = function() {\n      ClientBase.call(this);\n   };\n   NullClient.prototype = Object.create(ClientBase.prototype);\n   NullClient.prototype.constructor = NullClient;\n\n   NullClient.prototype._callImpl = function(method, params, callbacks) {\n      if (callbacks && callbacks.failure) {\n         var message = connect.sprintf(\'No such method exists on NULL client: %s\', method);\n         callbacks.failure(new connect.ValueError(message), {message: message});\n      }\n   };\n\n   /**---------------------------------------------------------------\n    * abstract class UpstreamConduitClientBase extends ClientBase\n    */\n   var UpstreamConduitClientBase = function(conduit, requestEvent, responseEvent) {\n      ClientBase.call(this);\n      this.conduit = conduit;\n      this.requestEvent = requestEvent;\n      this.responseEvent = responseEvent;\n      this._requestIdCallbacksMap = {};\n\n      this.conduit.onUpstream(responseEvent, connect.hitch(this, this._handleResponse));\n   };\n\n   UpstreamConduitClientBase.prototype = Object.create(ClientBase.prototype);\n   UpstreamConduitClientBase.prototype.constructor = UpstreamConduitClientBase;\n\n   UpstreamConduitClientBase.prototype._callImpl = function(method, params, callbacks) {\n      var request = connect.EventFactory.createRequest(this.requestEvent, method, params);\n      this._requestIdCallbacksMap[request.requestId] = callbacks;\n      this.conduit.sendUpstream(request.event, request);\n   };\n\n   UpstreamConduitClientBase.prototype._getCallbacksForRequest = function(requestId) {\n      var callbacks = this._requestIdCallbacksMap[requestId] || null;\n\n      if (callbacks != null) {\n         delete this._requestIdCallbacksMap[requestId];\n      }\n\n      return callbacks;\n   };\n\n   UpstreamConduitClientBase.prototype._handleResponse = function(data) {\n      var callbacks = this._getCallbacksForRequest(data.requestId);\n      if (callbacks == null) {\n         return;\n      }\n\n      if (data.err && callbacks.failure) {\n         callbacks.failure(data.err, data.data);\n\n      } else if (callbacks.success) {\n         callbacks.success(data.data);\n      }\n   };\n\n   /**---------------------------------------------------------------\n    * class UpstreamConduitClient extends ClientBase\n    */\n   var UpstreamConduitClient = function(conduit) {\n      UpstreamConduitClientBase.call(this, conduit, connect.EventType.API_REQUEST, connect.EventType.API_RESPONSE);\n   };\n   UpstreamConduitClient.prototype = Object.create(UpstreamConduitClientBase.prototype);\n   UpstreamConduitClient.prototype.constructor = UpstreamConduitClient;\n\n   /**---------------------------------------------------------------\n    * class UpstreamConduitMasterClient extends ClientBase\n    */\n   var UpstreamConduitMasterClient = function(conduit) {\n      UpstreamConduitClientBase.call(this, conduit, connect.EventType.MASTER_REQUEST, connect.EventType.MASTER_RESPONSE);\n   };\n   UpstreamConduitMasterClient.prototype = Object.create(UpstreamConduitClientBase.prototype);\n   UpstreamConduitMasterClient.prototype.constructor = UpstreamConduitMasterClient;\n\n   /**---------------------------------------------------------------\n    * class AWSClient extends ClientBase\n    */\n   var AWSClient = function(authToken, region, endpointIn) {\n      connect.assertNotNull(authToken, \'authToken\');\n      connect.assertNotNull(region, \'region\');\n      ClientBase.call(this);\n      AWS.config.credentials = new AWS.Credentials({});\n      AWS.config.region = region;\n      this.authToken = authToken;\n      var endpointUrl = endpointIn || connect.getBaseUrl() + \'/connect/api\';\n      var endpoint = new AWS.Endpoint(endpointUrl);\n      this.client = new AWS.Connect({endpoint: endpoint});\n   };\n   AWSClient.prototype = Object.create(ClientBase.prototype);\n   AWSClient.prototype.constructor = AWSClient;\n\n   AWSClient.prototype._callImpl = function(method, params, callbacks) {\n      var self = this;\n      var log = connect.getLog();\n\n      params.authentication = {\n         authToken: this.authToken\n      };\n\n      if (! connect.contains(this.client, method)) {\n         var message = connect.sprintf(\'No such method exists on AWS client: %s\', method);\n         callbacks.failure(new connect.ValueError(message), {message: message});\n\n      } else {\n         params = this._translateParams(method, params);\n\n         log.trace("AWSClient: --\x3e Calling operation \'%s\'", method);\n\n         this.client[method](params)\n            .on(\'build\', function(request) {\n               request.httpRequest.headers[\'X-Amz-Bearer\'] = self.authToken;\n            })\n            .send(function(err, data) {\n               try {\n                  if (err) {\n                     if (err.code === connect.CTIExceptions.UNAUTHORIZED_EXCEPTION) {\n                        callbacks.authFailure();\n                     } else {\n                        // Can\'t pass err directly to postMessage\n                        // postMessage() tries to clone the err object and failed.\n                        // Refer to https://github.com/goatslacker/alt-devtool/issues/5\n                        var error = {};\n                        error.type = err.code;\n                        error.message = err.message;\n                        error.stack = err.stack ? err.stack.split(\'\\n\') : [];\n                        callbacks.failure(error, data);\n                     }\n\n                     log.trace("AWSClient: <-- Operation \'%s\' failed: %s", method, JSON.stringify(err));\n\n                  } else {\n                     log.trace("AWSClient: <-- Operation \'%s\' succeeded.", method).withObject(data);\n                     callbacks.success(data);\n                  }\n               } catch (e) {\n                  connect.getLog().error("Failed to handle AWS API request for method %s", method)\n                        .withException(e);\n               }\n            });\n      }\n   };\n\n   AWSClient.prototype._translateParams = function(method, params) {\n      switch (method) {\n         case connect.ClientMethods.UPDATE_AGENT_CONFIGURATION:\n            params.configuration = this._translateAgentConfiguration(params.configuration);\n            break;\n\n         case connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS:\n            params.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(\n                  params.softphoneStreamStatistics);\n            break;\n\n         case connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT:\n            params.report = this._translateSoftphoneCallReport(params.report);\n            break;\n\n         default:\n            break;\n      }\n\n      return params;\n   };\n\n   AWSClient.prototype._translateAgentConfiguration = function(config) {\n      return {\n         name: config.name,\n         softphoneEnabled: config.softphoneEnabled,\n         softphoneAutoAccept: config.softphoneAutoAccept,\n         extension: config.extension,\n         routingProfile: this._translateRoutingProfile(config.routingProfile)\n      };\n   };\n\n   AWSClient.prototype._translateRoutingProfile = function(profile) {\n      return {\n         name: profile.name,\n         routingProfileARN: profile.routingProfileARN,\n         defaultOutboundQueue: this._translateQueue(profile.defaultOutboundQueue)\n      };\n   };\n\n   AWSClient.prototype._translateQueue = function(queue) {\n      return {\n         queueARN:   queue.queueARN,\n         name:       queue.name\n      };\n   };\n\n   AWSClient.prototype._translateSoftphoneStreamStatistics = function(stats) {\n      stats.forEach(function(stat) {\n         if (\'packetsCount\' in stat) {\n            stat.packetCount = stat.packetsCount;\n            delete stat.packetsCount;\n         }\n      });\n\n      return stats;\n   };\n\n   AWSClient.prototype._translateSoftphoneCallReport = function(report) {\n      if (\'handshakingTimeMillis\' in report) {\n         report.handshakeTimeMillis = report.handshakingTimeMillis;\n         delete report.handshakingTimeMillis;\n      }\n\n      if (\'preTalkingTimeMillis\' in report) {\n         report.preTalkTimeMillis = report.preTalkingTimeMillis;\n         delete report.preTalkingTimeMillis;\n      }\n\n      if (\'handshakingFailure\' in report) {\n         report.handshakeFailure = report.handshakingFailure;\n         delete report.handshakingFailure;\n      }\n\n      if (\'talkingTimeMillis\' in report) {\n         report.talkTimeMillis = report.talkingTimeMillis;\n         delete report.talkingTimeMillis;\n      }\n\n      report.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(\n            report.softphoneStreamStatistics);\n\n      return report;\n   };\n\n   connect.NullClient = NullClient;\n   connect.UpstreamConduitClient = UpstreamConduitClient;\n   connect.UpstreamConduitMasterClient = UpstreamConduitMasterClient;\n   connect.AWSClient = AWSClient;\n\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   /**-------------------------------------------------------------------------\n    * GraphLink <<abstract class>>\n    *\n    * Represents the association of one or more attributes to a state transition.\n    */\n   var GraphLink = function(fromState, toState) {\n      connect.assertNotNull(fromState, \'fromState\');\n      connect.assertNotNull(toState, \'toState\');\n      this.fromState = fromState;\n      this.toState = toState;\n   };\n\n   GraphLink.prototype.getAssociations = function(context) {\n      throw connect.NotImplementedError();\n   };\n\n   GraphLink.prototype.getFromState = function() {\n      return this.fromState;\n   };\n\n   GraphLink.prototype.getToState = function() {\n      return this.toState;\n   };\n\n   /**-------------------------------------------------------------------------\n    * DirectGraphLink <<concrete class>> extends GraphLink\n    *\n    * Represents the by-value representation of one or more attributes to a\n    * state transition.\n    */\n   var DirectGraphLink = function(fromState, toState, associations) {\n      connect.assertNotNull(fromState, \'fromState\');\n      connect.assertNotNull(toState, \'toState\');\n      connect.assertNotNull(associations, \'associations\');\n      GraphLink.call(this, fromState, toState);\n      this.associations = associations;\n   };\n   DirectGraphLink.prototype = Object.create(GraphLink.prototype);\n   DirectGraphLink.prototype.constructor = DirectGraphLink;\n\n   DirectGraphLink.prototype.getAssociations = function(context) {\n      return this.associations;\n   };\n\n   /**\n    * FunctionalGraphLink <<concrete class>> extends GraphLink\n    *\n    * Represents a functional association of one or more attributes to a\n    * state transition.\n    */\n   var FunctionalGraphLink = function(fromState, toState, closure) {\n      connect.assertNotNull(fromState, \'fromState\');\n      connect.assertNotNull(toState, \'toState\');\n      connect.assertNotNull(closure, \'closure\');\n      connect.assertTrue(connect.isFunction(closure), \'closure must be a function\');\n      GraphLink.call(this, fromState, toState);\n      this.closure = closure;\n   };\n   FunctionalGraphLink.prototype = Object.create(GraphLink.prototype);\n   FunctionalGraphLink.prototype.constructor = FunctionalGraphLink;\n\n   FunctionalGraphLink.prototype.getAssociations = function(context) {\n      return this.closure(context, this.getFromState(), this.getToState());\n   };\n\n   /**-------------------------------------------------------------------------\n    * EventGraph <<class>>\n    *\n    * Builds a map of associations from one state to another in context of a\n    * particular object.  The associations can be direct (one or more values)\n    * or functional (a method returning one or more values), and are used to\n    * provide additional contextual event hooks for the UI to consume.\n    */\n   var EventGraph = function() {\n      this.fromMap = {};\n   };\n   EventGraph.ANY = "<<any>>";\n\n   EventGraph.prototype.assoc = function(fromStateObj, toStateObj, assocObj) {\n      var self = this;\n\n      if (! fromStateObj) {\n         throw new Error("fromStateObj is not defined.");\n      }\n\n      if (! toStateObj) {\n         throw new Error("toStateObj is not defined.");\n      }\n\n      if (! assocObj) {\n         throw new Error("assocObj is not defined.");\n      }\n\n      if (fromStateObj instanceof Array) {\n         fromStateObj.forEach(function(fromState) {\n            self.assoc(fromState, toStateObj, assocObj);\n         });\n      } else if (toStateObj instanceof Array) {\n         toStateObj.forEach(function(toState) {\n            self.assoc(fromStateObj, toState, assocObj);\n         });\n      } else {\n         if (typeof assocObj === "function") {\n            this._addAssociation(new FunctionalGraphLink(fromStateObj, toStateObj, assocObj));\n         } else if (assocObj instanceof Array) {\n            this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, assocObj));\n         } else {\n            this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, [assocObj]));\n         }\n      }\n      return this;\n   };\n\n   EventGraph.prototype.getAssociations = function(context, fromState, toState) {\n      connect.assertNotNull(fromState, \'fromState\');\n      connect.assertNotNull(toState, \'toState\');\n      var associations = [];\n\n      var toMapFromAny = this.fromMap[EventGraph.ANY] || {};\n      var toMap = this.fromMap[fromState] || {};\n\n      associations = associations.concat(this._getAssociationsFromMap(\n               toMapFromAny, context, fromState, toState));\n      associations = associations.concat(this._getAssociationsFromMap(\n               toMap, context, fromState, toState));\n\n      return associations;\n   };\n\n   EventGraph.prototype._addAssociation = function(assoc) {\n      var toMap = this.fromMap[assoc.getFromState()];\n\n      if (! toMap) {\n         toMap = this.fromMap[assoc.getFromState()] = {};\n      }\n\n      var assocList = toMap[assoc.getToState()];\n\n      if (! assocList) {\n         assocList = toMap[assoc.getToState()] = [];\n      }\n\n      assocList.push(assoc);\n   };\n\n   EventGraph.prototype._getAssociationsFromMap = function(map, context, fromState, toState) {\n      var assocList = (map[EventGraph.ANY] || []).concat(map[toState] || []);\n      return assocList.reduce(function(prev, assoc) {\n         return prev.concat(assoc.getAssociations(context));\n      }, []);\n   };\n\n   connect.EventGraph = EventGraph;\n\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   /*----------------------------------------------------------------\n    * enum AgentStateType\n    */\n   connect.AgentStateType = connect.makeEnum([\n         \'init\',\n         \'routable\',\n         \'not_routable\',\n         \'offline\'\n   ]);\n   connect.AgentStatusType = connect.AgentStateType;\n\n   /**\n    * enum AgentAvailStates\n    */\n   connect.AgentAvailStates = connect.makeEnum([\n         \'Init\',\n         \'Busy\',\n         \'AfterCallWork\',\n         \'CallingCustomer\',\n         \'Dialing\',\n         \'Joining\',\n         \'PendingAvailable\',\n         \'PendingBusy\'\n   ]);\n\n   /**\n    * enum AgentErrorStates\n    */\n   connect.AgentErrorStates = connect.makeEnum([\n         \'Error\',\n         \'AgentHungUp\',\n         \'BadAddressAgent\',\n         \'BadAddressCustomer\',\n         \'Default\',\n         \'FailedConnectAgent\',\n         \'FailedConnectCustomer\',\n         \'LineEngagedAgent\',\n         \'LineEngagedCustomer\',\n         \'MissedCallAgent\',\n         \'MissedCallCustomer\',\n         \'MultipleCcpWindows\',\n         \'RealtimeCommunicationError\'\n   ]);\n\n   /*----------------------------------------------------------------\n    * enum AddressType\n    */\n   connect.EndpointType = connect.makeEnum([\n         \'phone_number\',\n         \'agent\',\n         \'queue\'\n   ]);\n   connect.AddressType = connect.EndpointType;\n\n   /*----------------------------------------------------------------\n    * enum ConnectionType\n    */\n   connect.ConnectionType = connect.makeEnum([\n         \'agent\',\n         \'inbound\',\n         \'outbound\',\n         \'monitoring\'\n   ]);\n\n   /*----------------------------------------------------------------\n    * enum ConnectionStateType\n    */\n   connect.ConnectionStateType = connect.makeEnum([\n         \'init\',\n         \'connecting\',\n         \'connected\',\n         \'hold\',\n         \'disconnected\'\n   ]);\n   connect.ConnectionStatusType = connect.ConnectionStateType;\n\n   connect.CONNECTION_ACTIVE_STATES = connect.set([\n         connect.ConnectionStateType.CONNECTING,\n         connect.ConnectionStateType.CONNECTED,\n         connect.ConnectionStateType.HOLD\n   ]);\n\n   /*----------------------------------------------------------------\n    * enum ContactStateType\n    */\n   connect.ContactStateType = connect.makeEnum([\n         \'init\',\n         \'incoming\',\n         \'pending\',\n         \'connecting\',\n         \'connected\',\n         \'missed\',\n         \'error\',\n         \'ended\'\n   ]);\n   connect.ContactStatusType = connect.ContactStateType;\n\n   connect.CONTACT_ACTIVE_STATES = connect.makeEnum([\n         \'incoming\',\n         \'connecting\',\n         \'connected\'\n   ]);\n\n   /*----------------------------------------------------------------\n    * enum ContactType\n    */\n   connect.ContactType = connect.makeEnum([\n         \'voice\',\n         \'queue_callback\'\n   ]);\n\n   /*----------------------------------------------------------------\n    * enum SoftphoneCallType\n    */\n   connect.SoftphoneCallType = connect.makeEnum([\n         \'audio_video\',\n         \'video_only\',\n         \'audio_only\',\n         \'none\'\n   ]);\n\n   /*----------------------------------------------------------------\n    * enum for SoftphoneErrorTypes\n    */\n    connect.SoftphoneErrorTypes = connect.makeEnum([\n        \'unsupported_browser\',\n        \'microphone_not_shared\',\n        \'signalling_handshake_failure\',\n        \'signalling_connection_failure\',\n        \'ice_collection_timeout\',\n        \'user_busy_error\',\n        \'webrtc_error\',\n        \'realtime_communication_error\',\n        \'other\'\n   ]);\n\n   /*----------------------------------------------------------------\n    * enum for CTI exceptions\n    */\n    connect.CTIExceptions = connect.makeEnum([\n        "AccessDeniedException",\n        "InvalidStateException",\n        "BadEndpointException",\n        "InvalidAgentARNException",\n        "InvalidConfigurationException",\n        "InvalidContactTypeException",\n        "PaginationException",\n        "RefreshTokenExpiredException",\n        "SendDataFailedException",\n        "UnauthorizedException"\n    ]);\n   /*----------------------------------------------------------------\n    * class Agent\n    */\n   var Agent = function() {\n      if (! connect.agent.initialized) {\n         throw new connect.StateError("The agent is not yet initialized!");\n      }\n   };\n\n   Agent.prototype._getData = function() {\n      return connect.core.getAgentDataProvider().getAgentData();\n   };\n\n   Agent.prototype._createContactAPI = function(contactData) {\n      return new connect.Contact(contactData.contactId);\n   };\n\n   Agent.prototype.onContactPending = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.CONTACT_PENDING, f);\n   };\n\n   Agent.prototype.onRefresh = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.REFRESH, f);\n   };\n\n   Agent.prototype.onRoutable = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.ROUTABLE, f);\n   };\n\n   Agent.prototype.onNotRoutable = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.NOT_ROUTABLE, f);\n   };\n\n   Agent.prototype.onOffline = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.OFFLINE, f);\n   };\n\n   Agent.prototype.onError = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.ERROR, f);\n   };\n\n   Agent.prototype.onSoftphoneError = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.SOFTPHONE_ERROR, f);\n   };\n\n   Agent.prototype.onAfterCallWork = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.ACW, f);\n   };\n\n   Agent.prototype.onStateChange = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.AgentEvents.STATE_CHANGE, f);\n   };\n\n   Agent.prototype.getState = function() {\n      return this._getData().snapshot.state;\n   };\n\n   Agent.prototype.getStatus = Agent.prototype.getState;\n\n   Agent.prototype.getStateDuration = function() {\n      return connect.now() - connect.core.getLocalTimestamp() + this._getData().snapshot.state.duration * 1000;\n   };\n\n   Agent.prototype.getStatusDuration = Agent.prototype.getStateDuration;\n\n   Agent.prototype.getPermissions = function() {\n      return this.getConfiguration().permissions;\n   };\n\n   Agent.prototype.getContacts = function(contactTypeFilter) {\n      var self = this;\n      return this._getData().snapshot.contacts.map(function(contactData) {\n         return self._createContactAPI(contactData);\n      }).filter(function(contact) {\n         return (! contactTypeFilter) || contact.getType() === contactTypeFilter;\n      });\n   };\n\n   Agent.prototype.getConfiguration = function() {\n      return this._getData().configuration;\n   };\n\n   Agent.prototype.getAgentStates = function() {\n      return this.getConfiguration().agentStates;\n   };\n\n   Agent.prototype.getRoutingProfile = function() {\n      return this.getConfiguration().routingProfile;\n   };\n\n   Agent.prototype.getName = function() {\n      return this.getConfiguration().name;\n   };\n\n   Agent.prototype.getExtension = function() {\n      return this.getConfiguration().extension;\n   };\n\n   Agent.prototype.getDialableCountries = function() {\n      return this.getConfiguration().dialableCountries;\n   };\n\n   Agent.prototype.isSoftphoneEnabled = function() {\n      return this.getConfiguration().softphoneEnabled;\n   };\n\n   Agent.prototype.setConfiguration = function(configuration, callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.UPDATE_AGENT_CONFIGURATION, {\n         configuration: connect.assertNotNull(configuration, \'configuration\')\n      }, {\n         success: function(data) {\n            // We need to ask the shared worker to reload agent config\n            // once we change it so every tab has accurate config.\n            var conduit = connect.core.getUpstream();\n            conduit.sendUpstream(connect.EventType.RELOAD_AGENT_CONFIGURATION);\n\n            if (callbacks.success) {\n               callbacks.success(data);\n            }\n         },\n         failure: callbacks.failure\n      });\n   };\n\n   Agent.prototype.setState = function(state, callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.PUT_AGENT_STATE, {\n         state: connect.assertNotNull(state, \'state\')\n      }, callbacks);\n   };\n\n   Agent.prototype.setStatus = Agent.prototype.setState;\n\n   Agent.prototype.connect = function(endpointIn, params) {\n      var client = connect.core.getClient();\n      var endpoint = new connect.Endpoint(endpointIn);\n      // Have to remove the endpointId field or AWS JS SDK gets mad.\n      delete endpoint.endpointId;\n\n      client.call(connect.ClientMethods.CREATE_OUTBOUND_CONTACT, {\n         endpoint:    connect.assertNotNull(endpoint, \'endpoint\'),\n         queueARN:   params.queueARN || params.queueId || this.getRoutingProfile().defaultOutboundQueue.queueARN\n      }, {\n         success: params.success,\n         failure: params.failure\n      });\n   };\n\n   Agent.prototype.getAllQueueARNs = function() {\n      return this.getConfiguration().routingProfile.queues.map(function(queue) {\n         return queue.queueARN;\n      });\n   };\n\n   Agent.prototype.getEndpoints = function(queueARNs, callbacks, pageInfoIn) {\n      var self = this;\n      var client = connect.core.getClient();\n      var pageInfo = pageInfoIn || {endpoints: []};\n\n      pageInfo.maxResults = pageInfo.maxResults || connect.DEFAULT_BATCH_SIZE;\n\n      // Backwards compatibility allowing a single queueARN to be specified\n      // instead of an array.\n      if (! connect.isArray(queueARNs)) {\n         queueARNs = [queueARNs];\n      }\n\n      client.call(connect.ClientMethods.GET_ENDPOINTS, {\n         queueARNs:   queueARNs,\n         nextToken:   pageInfo.nextToken || null,\n         maxResults:  pageInfo.maxResults\n      }, {\n         success: function(data) {\n            if (data.nextToken) {\n               self.getEndpoints(queueARNs, callbacks, {\n                  nextToken:  data.nextToken,\n                  maxResults: pageInfo.maxResults,\n                  endpoints:  pageInfo.endpoints.concat(data.endpoints)\n               });\n            } else {\n               pageInfo.endpoints = pageInfo.endpoints.concat(data.endpoints);\n               var endpoints = pageInfo.endpoints.map(function(endpoint) {\n                     return new connect.Endpoint(endpoint);\n               });\n\n               callbacks.success({\n                  endpoints: endpoints,\n                  addresses: endpoints\n               });\n            }\n         },\n         failure: callbacks.failure\n      });\n   };\n\n   Agent.prototype.getAddresses = Agent.prototype.getEndpoints;\n\n   Agent.prototype.toSnapshot = function() {\n      return new connect.AgentSnapshot(this._getData());\n   };\n\n   /*----------------------------------------------------------------\n    * class AgentSnapshot\n    */\n   var AgentSnapshot = function(agentData) {\n      connect.Agent.call(this);\n      this.agentData = agentData;\n   };\n   AgentSnapshot.prototype = Object.create(Agent.prototype);\n   AgentSnapshot.prototype.constructor = AgentSnapshot;\n\n   AgentSnapshot.prototype._getData = function() {\n      return this.agentData;\n   };\n\n   AgentSnapshot.prototype._createContactAPI = function(contactData) {\n      return new connect.ContactSnapshot(contactData);\n   };\n\n   /*----------------------------------------------------------------\n    * class Contact\n    */\n   var Contact = function(contactId) {\n      this.contactId = contactId;\n   };\n\n   Contact.prototype._getData = function() {\n      return connect.core.getAgentDataProvider().getContactData(this.getContactId());\n   };\n\n   Contact.prototype._createConnectionAPI = function(connectionData) {\n      return new connect.Connection(this.contactId, connectionData.connectionId);\n   };\n\n   Contact.prototype.getEventName = function(eventName) {\n      return connect.core.getContactEventName(eventName, this.getContactId());\n   };\n\n   Contact.prototype.onRefresh = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.REFRESH), f);\n   };\n\n   Contact.prototype.onIncoming = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.INCOMING), f);\n   };\n\n   Contact.prototype.onConnecting = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTING), f);\n   };\n\n   Contact.prototype.onPending = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.PENDING), f);\n   };\n\n   Contact.prototype.onAccepted = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.ACCEPTED), f);\n   };\n\n   Contact.prototype.onMissed = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.MISSED), f);\n   };\n\n   Contact.prototype.onEnded = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.ENDED), f);\n      bus.subscribe(this.getEventName(connect.ContactEvents.DESTROYED), f);\n   };\n\n   Contact.prototype.onACW = function(f) {\n     var bus = connect.core.getEventBus();\n     bus.subscribe(this.getEventName(connect.ContactEvents.ACW), f);\n   };\n\n   Contact.prototype.onConnected = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTED), f);\n   };\n\n   Contact.prototype.getContactId = function() {\n      return this.contactId;\n   };\n\n   Contact.prototype.getOriginalContactId = function() {\n      return this._getData().originalContactId;\n   };\n\n   Contact.prototype.getType = function() {\n      return this._getData().type;\n   };\n\n   Contact.prototype.getStatus = function() {\n      return this._getData().state;\n   };\n\n   Contact.prototype.getStatusDuration = function() {\n      return connect.now() - connect.core.getLocalTimestamp() + this._getData().state.duration * 1000;\n   };\n\n   Contact.prototype.getQueue = function() {\n      return this._getData().queue;\n   };\n\n   Contact.prototype.getQueueTimestamp = function() {\n      return this._getData().queueTimestamp;\n   };\n\n   Contact.prototype.getConnections = function() {\n      var self = this;\n      return this._getData().connections.map(function(connData) {\n         return new connect.Connection(self.contactId, connData.connectionId);\n      });\n   };\n\n   Contact.prototype.getInitialConnection = function() {\n      return connect.find(this.getConnections(), function(conn) {\n         return conn.isInitialConnection();\n      }) || null;\n   };\n\n   Contact.prototype.getActiveInitialConnection = function() {\n      var initialConn = this.getInitialConnection();\n      if (initialConn != null && initialConn.isActive()) {\n         return initialConn;\n      } else {\n         return null;\n      }\n   };\n\n   Contact.prototype.getThirdPartyConnections = function() {\n      return this.getConnections().filter(function(conn) {\n         return ! conn.isInitialConnection() && conn.getType() !== connect.ConnectionType.AGENT;\n      });\n   };\n\n   Contact.prototype.getSingleActiveThirdPartyConnection = function() {\n      return this.getThirdPartyConnections().filter(function(conn) {\n         return conn.isActive();\n      })[0] || null;\n   };\n\n   Contact.prototype.getAgentConnection = function() {\n      return connect.find(this.getConnections(), function(conn) {\n         var connType =  conn.getType();\n         return connType === connect.ConnectionType.AGENT || connType === connect.ConnectionType.MONITORING;\n      });\n   };\n\n   Contact.prototype.getAttributes = function() {\n      return this._getData().attributes;\n   };\n\n   Contact.prototype.isSoftphoneCall = function() {\n      return connect.find(this.getConnections(), function(conn) {\n         return conn.getSoftphoneMediaInfo() != null;\n      }) != null;\n   };\n\n   Contact.prototype.isInbound = function() {\n      var conn = this.getInitialConnection();\n      return conn ? conn.getType() === connect.ConnectionType.INBOUND : false;\n   };\n\n   Contact.prototype.isConnected = function() {\n      return this.getStatus().type === connect.ContactStateType.CONNECTED;\n   };\n\n   Contact.prototype.accept = function(callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.ACCEPT_CONTACT, {\n         contactId:  this.getContactId()\n      }, callbacks);\n   };\n\n   Contact.prototype.destroy = function(callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.DESTROY_CONTACT, {\n         contactId:  this.getContactId()\n      }, callbacks);\n   };\n\n   Contact.prototype.notifyIssue = function(issueCode, description, callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.NOTIFY_CONTACT_ISSUE, {\n         contactId:     this.getContactId(),\n         issueCode:     issueCode,\n         description:   description\n      }, callbacks);\n   };\n\n   Contact.prototype.addConnection = function(endpointIn, callbacks) {\n      var client = connect.core.getClient();\n      var endpoint = new connect.Endpoint(endpointIn);\n      // Have to remove the endpointId field or AWS JS SDK gets mad.\n      delete endpoint.endpointId;\n\n      client.call(connect.ClientMethods.CREATE_ADDITIONAL_CONNECTION, {\n         contactId:     this.getContactId(),\n         endpoint:      endpoint\n      }, callbacks);\n   };\n\n   Contact.prototype.toggleActiveConnections = function(callbacks) {\n      var client = connect.core.getClient();\n      var connectionId = null;\n      var holdingConn = connect.find(this.getConnections(), function(conn) {\n         return conn.getStatus().type === connect.ConnectionStateType.HOLD;\n      });\n\n      if (holdingConn != null) {\n         connectionId = holdingConn.getConnectionId();\n\n      } else {\n         var activeConns = this.getConnections().filter(function(conn) {\n            return conn.isActive();\n         });\n         if (activeConns.length > 0) {\n            connectionId = activeConns[0].getConnectionId();\n         }\n      }\n\n      client.call(connect.ClientMethods.TOGGLE_ACTIVE_CONNECTIONS, {\n         contactId:     this.getContactId(),\n         connectionId:  connectionId\n      }, callbacks);\n   };\n\n   Contact.prototype.sendSoftphoneMetrics = function(softphoneStreamStatistics, callbacks) {\n      var client = connect.core.getClient();\n\n      client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS, {\n         contactId:     this.getContactId(),\n         softphoneStreamStatistics:  softphoneStreamStatistics\n      }, callbacks);\n   };\n\n   Contact.prototype.sendSoftphoneReport = function(report, callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT, {\n         contactId:     this.getContactId(),\n         report:  report\n      }, callbacks);\n   };\n\n   Contact.prototype.conferenceConnections = function(callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.CONFERENCE_CONNECTIONS, {\n         contactId:     this.getContactId()\n      }, callbacks);\n   };\n\n   Contact.prototype.toSnapshot = function() {\n      return new connect.ContactSnapshot(this._getData());\n   };\n\n   /*----------------------------------------------------------------\n    * class ContactSnapshot\n    */\n   var ContactSnapshot = function(contactData) {\n      connect.Contact.call(this, contactData.contactId);\n      this.contactData = contactData;\n   };\n   ContactSnapshot.prototype = Object.create(Contact.prototype);\n   ContactSnapshot.prototype.constructor = ContactSnapshot;\n\n   ContactSnapshot.prototype._getData = function() {\n      return this.contactData;\n   };\n\n   ContactSnapshot.prototype._createConnectionAPI = function(connectionData) {\n      return new connect.ConnectionSnapshot(connectionData);\n   };\n\n   /*----------------------------------------------------------------\n    * class Connection\n    */\n   var Connection = function(contactId, connectionId) {\n      this.contactId = contactId;\n      this.connectionId = connectionId;\n   };\n\n   Connection.prototype._getData = function() {\n      return connect.core.getAgentDataProvider().getConnectionData(\n            this.getContactId(), this.getConnectionId());\n   };\n\n   Connection.prototype.getContactId = function() {\n      return this.contactId;\n   };\n\n   Connection.prototype.getConnectionId = function() {\n      return this.connectionId;\n   };\n\n   Connection.prototype.getEndpoint = function() {\n      return new connect.Endpoint(this._getData().endpoint);\n   };\n\n   Connection.prototype.getAddress = Connection.prototype.getEndpoint;\n\n   Connection.prototype.getStatus = function() {\n      return this._getData().state;\n   };\n\n   Connection.prototype.getStatusDuration = function() {\n      return connect.now() - connect.core.getLocalTimestamp() + this._getData().state.duration * 1000;\n   };\n\n   Connection.prototype.getType = function() {\n      return this._getData().type;\n   };\n\n   Connection.prototype.isInitialConnection = function() {\n      return this._getData().initial;\n   };\n\n   Connection.prototype.isActive = function() {\n      return connect.contains(connect.CONNECTION_ACTIVE_STATES, this.getStatus().type);\n   };\n\n   Connection.prototype.isConnected = function() {\n      return this.getStatus().type === connect.ConnectionStateType.CONNECTED;\n   };\n\n   Connection.prototype.isConnecting = function() {\n      return this.getStatus().type === connect.ConnectionStateType.CONNECTING;\n   };\n\n   Connection.prototype.isOnHold = function() {\n      return this.getStatus().type === connect.ConnectionStateType.HOLD;\n   };\n\n   Connection.prototype.getSoftphoneMediaInfo = function() {\n      return this._getData().softphoneMediaInfo;\n   };\n\n   Connection.prototype.destroy = function(callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.DESTROY_CONNECTION, {\n         contactId:     this.getContactId(),\n         connectionId:  this.getConnectionId()\n      }, callbacks);\n   };\n\n   Connection.prototype.sendDigits = function(digits, callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.SEND_DIGITS, {\n         contactId:     this.getContactId(),\n         connectionId:  this.getConnectionId(),\n         digits:        digits\n      }, callbacks);\n   };\n\n   Connection.prototype.hold = function(callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.HOLD_CONNECTION, {\n         contactId:     this.getContactId(),\n         connectionId:  this.getConnectionId()\n      }, callbacks);\n   };\n\n   Connection.prototype.resume = function(callbacks) {\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.RESUME_CONNECTION, {\n         contactId:     this.getContactId(),\n         connectionId:  this.getConnectionId()\n      }, callbacks);\n   };\n\n   Connection.prototype.toSnapshot = function() {\n      return new connect.ConnectionSnapshot(this._getData());\n   };\n\n   /*----------------------------------------------------------------\n    * class ConnectionSnapshot\n    */\n   var ConnectionSnapshot = function(connectionData) {\n      connect.Connection.call(this, connectionData.contactId, connectionData.connectionId);\n      this.connectionData = connectionData;\n   };\n   ConnectionSnapshot.prototype = Object.create(Connection.prototype);\n   ConnectionSnapshot.prototype.constructor = ConnectionSnapshot;\n\n   ConnectionSnapshot.prototype._getData = function() {\n      return this.connectionData;\n   };\n\n   var Endpoint = function(paramsIn) {\n      var params = paramsIn || {};\n      this.endpointARN = params.endpointId || params.endpointARN || null;\n      this.endpointId = this.endpointARN;\n      this.type = params.type || null;\n      this.name = params.name || null;\n      this.phoneNumber = params.phoneNumber || null;\n      this.agentLogin = params.agentLogin || null;\n      this.queue = params.queue || null;\n   };\n\n   /**\n    * Strip the SIP endpoint components from the phoneNumber field.\n    */\n   Endpoint.prototype.stripPhoneNumber = function() {\n      return this.phoneNumber ? this.phoneNumber.replace(/sip:([^@]*)@.*/, "$1") : "";\n   };\n\n   /**\n    * Create an Endpoint object from the given phone number and name.\n    */\n   Endpoint.byPhoneNumber = function(number, name) {\n      return new Endpoint({\n         type:          connect.EndpointType.PHONE_NUMBER,\n         phoneNumber:   number,\n         name:          name || null\n      });\n   };\n\n   /*----------------------------------------------------------------\n    * class SoftphoneError\n    */\n   var SoftphoneError =  function(errorType, errorMessage, endPointUrl) {\n        this.errorType = errorType;\n        this.errorMessage = errorMessage;\n        this.endPointUrl = endPointUrl;\n   };\n   SoftphoneError.prototype.getErrorType =  function() {\n        return this.errorType;\n   };\n   SoftphoneError.prototype.getErrorMessage =  function() {\n        return this.errorMessage;\n   };\n   SoftphoneError.prototype.getEndPointUrl =  function() {\n        return this.endPointUrl;\n   };\n\n   /*----------------------------------------------------------------\n    * Root Subscription APIs.\n    */\n   connect.agent = function(f) {\n      if (connect.agent.initialized) {\n         f(new connect.Agent());\n\n      } else {\n         var bus = connect.core.getEventBus();\n         bus.subscribe(connect.AgentEvents.INIT, f);\n      }\n   };\n   connect.agent.initialized = false;\n\n   connect.contact = function(f) {\n      var bus = connect.core.getEventBus();\n      bus.subscribe(connect.ContactEvents.INIT, f);\n   };\n\n   /**\n    * Execute the given function asynchronously only if the shared worker\n    * says we are the master for the given topic.  If there is no master for\n    * the given topic, we become the master and execute the function.\n    *\n    * @param topic The master topic we are concerned about.\n    * @param f_true The callback to be invoked if we are the master.\n    * @param f_else [optional] A callback to be invoked if we are not the master.\n    */\n   connect.ifMaster = function(topic, f_true, f_else) {\n      connect.assertNotNull(topic, "A topic must be provided.");\n      connect.assertNotNull(f_true, "A true callback must be provided.");\n\n      if (! connect.core.masterClient) {\n         // We can\'t be the master because there is no master client!\n         connect.getLog().warn("We can\'t be the master for topic \'%s\' because there is no master client!", topic);\n         if (f_else) {\n            f_else();\n         }\n         return;\n      }\n\n      var masterClient = connect.core.getMasterClient();\n      masterClient.call(connect.MasterMethods.CHECK_MASTER, {\n         topic: topic\n      }, {\n         success: function(data) {\n            if (data.isMaster) {\n               f_true();\n\n            } else if (f_else) {\n               f_else();\n            }\n         }\n      });\n   };\n\n   /**\n    * Notify the shared worker that we are now the master for the given topic.\n    */\n   connect.becomeMaster = function(topic) {\n      connect.assertNotNull(topic, "A topic must be provided.");\n      var masterClient = connect.core.getMasterClient();\n      masterClient.call(connect.MasterMethods.BECOME_MASTER, {\n         topic: topic\n      });\n   };\n\n   connect.Agent = Agent;\n   connect.AgentSnapshot = AgentSnapshot;\n   connect.Contact = Contact;\n   connect.ContactSnapshot = ContactSnapshot;\n   connect.Connection = Connection;\n   connect.ConnectionSnapshot = ConnectionSnapshot;\n   connect.Endpoint = Endpoint;\n   connect.Address = Endpoint;\n   connect.SoftphoneError = SoftphoneError;\n\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   connect.core = {};\n\n   connect.core.initialized = false;\n\n   connect.DEFAULT_BATCH_SIZE = 10;\n\n   var CCP_SYN_TIMEOUT = 1000; // 1 sec\n   var CCP_ACK_TIMEOUT = 3000; // 3 sec\n   var CCP_LOAD_TIMEOUT = 3000; // 3 sec\n   var CCP_IFRAME_REFRESH_INTERVAL = 5000; // 5 sec\n\n   var LOGIN_URL_PATTERN = "https://{alias}.awsapps.com/auth/?client_id={client_id}&redirect_uri={redirect}";\n   var CLIENT_ID_MAP = {\n      "us-east-1":   "06919f4fd8ed324e"\n   };\n\n   /**\n    * @deprecated\n    * We will no longer need this function soon.\n    */\n   var createLoginUrl = function(params) {\n      var redirect = "https://lily.us-east-1.amazonaws.com/taw/auth/code";\n      connect.assertNotNull(redirect);\n\n      if (params.alias) {\n         return LOGIN_URL_PATTERN\n            .replace("{alias}", params.alias)\n            .replace("{client_id}", CLIENT_ID_MAP["us-east-1"])\n            .replace("{redirect}", global.encodeURIComponent(\n               redirect));\n      } else {\n         return params.ccpUrl;\n      }\n   };\n\n   /**-------------------------------------------------------------------------\n    * Print a warning message if the Connect core is not initialized.\n    */\n   connect.core.checkNotInitialized = function() {\n      if (connect.core.initialized) {\n         var log = connect.getLog();\n         log.warn("Connect core already initialized, only needs to be initialized once.");\n      }\n   };\n\n   /**-------------------------------------------------------------------------\n    * Basic Connect client initialization.\n    * Should be used only by the API Shared Worker.\n    */\n   connect.core.init = function(params) {\n      connect.assertNotNull(params, \'params\');\n\n      var authToken = connect.assertNotNull(params.authToken, \'params.authToken\');\n      var region = connect.assertNotNull(params.region, \'params.region\');\n      var endpoint = params.endpoint || null;\n\n      connect.core.eventBus = new connect.EventBus();\n      connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());\n      connect.core.client = new connect.AWSClient(authToken, region, endpoint);\n      connect.core.initialized = true;\n   };\n\n   /**-------------------------------------------------------------------------\n    * Uninitialize Connect.\n    */\n   connect.core.terminate = function() {\n      connect.core.client = new connect.NullClient();\n      connect.core.masterClient = new connect.NullClient();\n      connect.core.eventBus = new connect.EventBus();\n      connect.core.initialized = false;\n   };\n\n   /**-------------------------------------------------------------------------\n    * Setup the SoftphoneManager to be initialized when the agent\n    * is determined to have softphone enabled.\n    */\n   connect.core.softphoneUserMediaStream = null;\n\n   connect.core.getSoftphoneUserMediaStream = function() {\n        return connect.core.softphoneUserMediaStream;\n   };\n\n   connect.core.setSoftphoneUserMediaStream = function(stream) {\n        connect.core.softphoneUserMediaStream = stream;\n   };\n\n   connect.core.initSoftphoneManager = function(paramsIn) {\n      var params = paramsIn || {};\n\n      var competeForMasterOnAgentUpdate = function(softphoneParamsIn) {\n         var softphoneParams = connect.merge(params.softphone || {}, softphoneParamsIn);\n\n         connect.agent(function(agent) {\n            agent.onRefresh(function() {\n               var sub = this;\n\n               connect.ifMaster(connect.MasterTopics.SOFTPHONE, function() {\n                  if (! connect.core.softphoneManager && agent.isSoftphoneEnabled()) {\n                     // Become master to send logs, since we need logs from softphone tab.\n                     connect.becomeMaster(connect.MasterTopics.SEND_LOGS);\n                     connect.core.softphoneManager = new connect.SoftphoneManager(softphoneParams);\n                     sub.unsubscribe();\n                  }\n               });\n            });\n         });\n      };\n\n      /**\n       * If the window is framed, we need to wait for a CONFIGURE message from\n       * downstream before we try to initialize, unless params.allowFramedSoftphone is true.\n       */\n      if (connect.isFramed() && ! params.allowFramedSoftphone) {\n         var bus = connect.core.getEventBus();\n         bus.subscribe(connect.EventType.CONFIGURE, function(data) {\n            if (data.softphone && data.softphone.allowFramedSoftphone) {\n               competeForMasterOnAgentUpdate(data.softphone);\n            }\n         });\n      } else {\n         competeForMasterOnAgentUpdate(params);\n      }\n   };\n\n   /**-------------------------------------------------------------------------\n    * Initializes Connect by creating or connecting to the API Shared Worker.\n    * Used primarily by the CCP.\n    */\n   connect.core.initSharedWorker = function(params) {\n      connect.core.checkNotInitialized();\n      if (connect.core.initialized) {\n         return;\n      }\n      connect.assertNotNull(params, \'params\');\n\n      var sharedWorkerUrl = connect.assertNotNull(params.sharedWorkerUrl, \'params.sharedWorkerUrl\');\n      var authToken = connect.assertNotNull(params.authToken, \'params.authToken\');\n      var refreshToken = connect.assertNotNull(params.refreshToken, \'params.refreshToken\');\n      var authTokenExpiration = connect.assertNotNull(params.authTokenExpiration, \'params.authTokenExpiration\');\n      var region = connect.assertNotNull(params.region, \'params.region\');\n      var endpoint = params.endpoint || null;\n\n      try {\n         // Initialize the event bus and agent data providers.\n         connect.core.eventBus = new connect.EventBus({logEvents: true});\n         connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());\n\n         // Create the shared worker and upstream conduit.\n         var worker = new SharedWorker(sharedWorkerUrl, "ConnectSharedWorker");\n         var conduit = new connect.Conduit("ConnectSharedWorkerConduit",\n               new connect.PortStream(worker.port),\n               new connect.WindowIOStream(window, parent));\n\n         // Set the global upstream conduit for external use.\n         connect.core.upstream = conduit;\n\n         // Close our port to the shared worker before the window closes.\n         global.onbeforeunload = function() {\n            conduit.sendUpstream(connect.EventType.CLOSE);\n            worker.port.close();\n         };\n\n         connect.getLog().scheduleUpstreamLogPush(conduit);\n         // Bridge all upstream messages into the event bus.\n         conduit.onAllUpstream(connect.core.getEventBus().bridge());\n         // Bridge all downstream messages into the event bus.\n         conduit.onAllDownstream(connect.core.getEventBus().bridge());\n         // Pass all upstream messages (from shared worker) downstream (to CCP consumer).\n         conduit.onAllUpstream(conduit.passDownstream());\n         // Pass all downstream messages (from CCP consumer) upstream (to shared worker).\n         conduit.onAllDownstream(conduit.passUpstream());\n         // Send configuration up to the shared worker.\n         conduit.sendUpstream(connect.EventType.CONFIGURE, {\n            authToken:     authToken,\n            authTokenExpiration: authTokenExpiration,\n            refreshToken:  refreshToken,\n            endpoint:      endpoint,\n            region:        region\n         });\n         conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {\n            connect.getLog().info("Acknowledged by the ConnectSharedWorker!");\n            connect.core.initialized = true;\n            this.unsubscribe();\n         });\n         // Add all upstream log entries to our own logger.\n         conduit.onUpstream(connect.EventType.LOG, function(logEntry) {\n            connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));\n         });\n         // Reload the page if the shared worker detects an API auth failure.\n         conduit.onUpstream(connect.EventType.AUTH_FAIL, function(logEntry) {\n            location.reload();\n         });\n\n         connect.core.client = new connect.UpstreamConduitClient(conduit);\n         connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit);\n\n         // Pass the TERMINATE request upstream to the shared worker.\n         connect.core.getEventBus().subscribe(connect.EventType.TERMINATE,\n            conduit.passUpstream());\n\n         // Refresh the page when we receive the TERMINATED response from the\n         // shared worker.\n         connect.core.getEventBus().subscribe(connect.EventType.TERMINATED, function() {\n            window.location.reload(true);\n         });\n\n         worker.port.start();\n\n         // Attempt to get permission to show notifications.\n         var nm = connect.core.getNotificationManager();\n         nm.requestPermission();\n\n      } catch (e) {\n         connect.getLog().error("Failed to initialize the API shared worker, we\'re dead!")\n            .withException(e);\n      }\n   };\n\n   /**-------------------------------------------------------------------------\n    * Initializes Connect by creating or connecting to the API Shared Worker.\n    * Initializes Connect by loading the CCP in an iframe and connecting to it.\n    */\n   connect.core.initCCP = function(containerDiv, paramsIn) {\n      connect.core.checkNotInitialized();\n      if (connect.core.initialized) {\n         return;\n      }\n\n      // For backwards compatibility, when instead of taking a params object\n      // as input we only accepted ccpUrl.\n      var params = {};\n      if (typeof(paramsIn) === \'string\') {\n         params.ccpUrl = paramsIn;\n      } else {\n         params = paramsIn;\n      }\n\n      var softphoneParams = params.softphone || null;\n\n      connect.assertNotNull(containerDiv, \'containerDiv\');\n      connect.assertNotNull(params.ccpUrl, \'params.ccpUrl\');\n\n      // Create the CCP iframe and append it to the container div.\n      var iframe = document.createElement(\'iframe\');\n      iframe.src = params.ccpUrl;\n      iframe.style = "width: 100%; height: 100%";\n      containerDiv.appendChild(iframe);\n\n      // Initialize the event bus and agent data providers.\n      // NOTE: Setting logEvents here to FALSE in order to avoid duplicating\n      // events which are logged in CCP.\n      connect.core.eventBus = new connect.EventBus({logEvents: false});\n      connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());\n\n      // Build the upstream conduit communicating with the CCP iframe.\n      var conduit = new connect.IFrameConduit(params.ccpUrl, window, iframe);\n\n      // Set the global upstream conduit for external use.\n      connect.core.upstream = conduit;\n\n      conduit.onAllUpstream(connect.core.getEventBus().bridge());\n\n      // Initialize the keepalive manager.\n      connect.core.keepaliveManager = new KeepaliveManager(conduit,\n                                                        connect.core.getEventBus(),\n                                                        params.ccpSynTimeout || CCP_SYN_TIMEOUT,\n                                                        params.ccpAckTimeout || CCP_ACK_TIMEOUT);\n      connect.core.iframeRefreshInterval = null;\n\n      // Allow 10 sec (default) before receiving the first ACK from the CCP.\n      connect.core.ccpLoadTimeoutInstance = global.setTimeout(function() {\n         connect.core.ccpLoadTimeoutInstance = null;\n         connect.core.getEventBus().trigger(connect.EventType.ACK_TIMEOUT);\n      }, params.ccpLoadTimeout || CCP_LOAD_TIMEOUT);\n\n      // Once we receive the first ACK, setup our upstream API client and establish\n      // the SYN/ACK refresh flow.\n      conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {\n         connect.getLog().info("Acknowledged by the CCP!");\n         connect.core.client = new connect.UpstreamConduitClient(conduit);\n         connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit);\n         connect.core.initialized = true;\n\n         if (softphoneParams) {\n            // Send configuration up to the CCP.\n            conduit.sendUpstream(connect.EventType.CONFIGURE, {\n               softphone:  softphoneParams\n            });\n         }\n\n         if (connect.core.ccpLoadTimeoutInstance) {\n            global.clearTimeout(connect.core.ccpLoadTimeoutInstance);\n            connect.core.ccpLoadTimeoutInstance = null;\n         }\n\n         connect.core.keepaliveManager.start();\n         this.unsubscribe();\n      });\n\n      // Add any logs from the upstream to our own logger.\n      conduit.onUpstream(connect.EventType.LOG, function(logEntry) {\n         connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));\n      });\n\n      // Pop a login page when we encounter an ACK timeout.\n      connect.core.getEventBus().subscribe(connect.EventType.ACK_TIMEOUT, function() {\n         // loginPopup is true by default, only false if explicitly set to false.\n         if (params.loginPopup !== false) {\n            try {\n               var loginUrl = createLoginUrl(params);\n               connect.getLog().warn("ACK_TIMEOUT occurred, attempting to pop the login page if not already open.");\n               connect.core.getPopupManager().open(loginUrl, connect.MasterTopics.LOGIN_POPUP);\n\n            } catch (e) {\n               connect.getLog().error("ACK_TIMEOUT occurred but we are unable to open the login popup.").withException(e);\n            }\n         }\n\n         if (connect.core.iframeRefreshInterval == null) {\n            connect.core.iframeRefreshInterval = window.setInterval(function() {\n               iframe.src = params.ccpUrl;\n            }, CCP_IFRAME_REFRESH_INTERVAL);\n\n            conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {\n               this.unsubscribe();\n               global.clearInterval(connect.core.iframeRefreshInterval);\n               connect.core.iframeRefreshInterval = null;\n               connect.core.getPopupManager().clear(connect.MasterTopics.LOGIN_POPUP);\n            });\n         }\n      });\n   };\n\n   /**-----------------------------------------------------------------------*/\n   var KeepaliveManager = function(conduit, eventBus, synTimeout, ackTimeout) {\n      this.conduit = conduit;\n      this.eventBus = eventBus;\n      this.synTimeout = synTimeout;\n      this.ackTimeout = ackTimeout;\n      this.ackTimer = null;\n      this.synTimer = null;\n      this.ackSub = null;\n   };\n\n   KeepaliveManager.prototype.start = function() {\n      var self = this;\n\n      this.conduit.sendUpstream(connect.EventType.SYNCHRONIZE);\n      this.ackSub = this.conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {\n         this.unsubscribe();\n         global.clearTimeout(self.ackTimer);\n         self.deferStart();\n      });\n      this.ackTimer = global.setTimeout(function() {\n         self.ackSub.unsubscribe();\n         self.eventBus.trigger(connect.EventType.ACK_TIMEOUT);\n         self.deferStart();\n      }, this.ackTimeout);\n   };\n\n   KeepaliveManager.prototype.deferStart = function() {\n      if (this.synTimer == null) {\n         this.synTimer = global.setTimeout(connect.hitch(this, this.start), this.synTimeout);\n      }\n   };\n\n   /**-----------------------------------------------------------------------*/\n   var AgentDataProvider = function(bus) {\n      var agentData = null;\n      this.bus = bus;\n      this.bus.subscribe(connect.AgentEvents.UPDATE, connect.hitch(this, this.updateAgentData));\n   };\n\n   AgentDataProvider.prototype.updateAgentData = function(agentData) {\n      var oldAgentData = this.agentData;\n      this.agentData = agentData;\n\n      this._calculateDurations();\n\n      if (oldAgentData == null) {\n         connect.agent.initialized = true;\n         this.bus.trigger(connect.AgentEvents.INIT, new connect.Agent());\n      }\n\n      this.bus.trigger(connect.AgentEvents.REFRESH, new connect.Agent());\n\n      this._fireAgentUpdateEvents(oldAgentData);\n   };\n\n   AgentDataProvider.prototype.getAgentData = function() {\n      if (this.agentData == null) {\n         throw new connect.StateError(\'No agent data is available yet!\');\n      }\n\n      return this.agentData;\n   };\n\n   AgentDataProvider.prototype.getContactData = function(contactId) {\n      var agentData = this.getAgentData();\n      var contactData = connect.find(agentData.snapshot.contacts, function(ctdata) {\n         return ctdata.contactId === contactId;\n      });\n\n      if (contactData == null) {\n         throw new connect.StateError(\'Contact %s no longer exists.\', contactId);\n      }\n\n      return contactData;\n   };\n\n   AgentDataProvider.prototype.getConnectionData = function(contactId, connectionId) {\n      var contactData = this.getContactData(contactId);\n      var connectionData = connect.find(contactData.connections, function(cdata) {\n         return cdata.connectionId === connectionId;\n      });\n\n      if (connectionData == null) {\n         throw new connect.StateError(\'Connection %s for contact %s no longer exists.\', connectionId, contactId);\n      }\n\n      return connectionData;\n   };\n\n   AgentDataProvider.prototype._calculateDurations = function() {\n      var now = connect.now();\n      var self = this;\n      this.agentData.snapshot.localTimestamp = now;\n\n      var skew = this.agentData.snapshot.snapshotTimestamp - this.agentData.snapshot.localTimestamp;\n\n      this.agentData.snapshot.state.duration = Math.round(now - this.agentData.snapshot.state.startTimestamp.getTime() + skew);\n\n      this.agentData.snapshot.contacts.forEach(function(contact) {\n         var ts = new Date(contact.timestamp).getTime();\n         contact.state.duration = Math.round(now - contact.state.timestamp.getTime() + skew);\n\n         contact.connections.forEach(function(conn) {\n            conn.state.duration = Math.round(now - conn.state.timestamp.getTime() + skew);\n         });\n      });\n   };\n\n   AgentDataProvider.prototype._diffContacts = function(oldAgentData) {\n      var diff = {\n         added:      {},\n         removed:    {},\n         common:     {},\n         oldMap:     connect.index(oldAgentData == null ? [] : oldAgentData.snapshot.contacts, function(contact) { return contact.contactId; }),\n         newMap:     connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; })\n      };\n\n      connect.keys(diff.oldMap).forEach(function(contactId) {\n         if (connect.contains(diff.newMap, contactId)) {\n            diff.common[contactId] = diff.newMap[contactId];\n         } else {\n            diff.removed[contactId] = diff.oldMap[contactId];\n         }\n      });\n\n      connect.keys(diff.newMap).forEach(function(contactId) {\n         if (! connect.contains(diff.oldMap, contactId)) {\n            diff.added[contactId] = diff.newMap[contactId];\n         }\n      });\n\n      return diff;\n   };\n\n   AgentDataProvider.prototype._fireAgentUpdateEvents = function(oldAgentData) {\n      var self = this;\n      var diff = null;\n      var oldAgentState = oldAgentData == null ? connect.AgentAvailStates.INIT : oldAgentData.snapshot.state.name;\n      var newAgentState = this.agentData.snapshot.state.name;\n      var oldRoutingState = oldAgentData == null ? connect.AgentStateType.INIT : oldAgentData.snapshot.state.type;\n      var newRoutingState = this.agentData.snapshot.state.type;\n\n      if (oldRoutingState !== newRoutingState) {\n         connect.core.getAgentRoutingEventGraph().getAssociations(this, oldRoutingState, newRoutingState).forEach(function(event) {\n            self.bus.trigger(event, new connect.Agent());\n         });\n      }\n\n      if (oldAgentState !== newAgentState) {\n         this.bus.trigger(connect.AgentEvents.STATE_CHANGE, {\n            agent:      new connect.Agent(),\n            oldState:  oldAgentState,\n            newState:  newAgentState\n\n         });\n         connect.core.getAgentStateEventGraph().getAssociations(this, oldAgentState, newAgentState).forEach(function(event) {\n            self.bus.trigger(event, new connect.Agent());\n         });\n      }\n\n      if (oldAgentData !== null) {\n         diff = this._diffContacts(oldAgentData);\n\n      } else {\n         diff =  {\n            added:      connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; }),\n            removed:    {},\n            common:     {},\n            oldMap:     {},\n            newMap:     connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; })\n         };\n      }\n\n      connect.values(diff.added).forEach(function(contactData) {\n         self.bus.trigger(connect.ContactEvents.INIT, new connect.Contact(contactData.contactId));\n         self._fireContactUpdateEvents(contactData.contactId, connect.ContactStateType.INIT, contactData.state.type);\n      });\n\n      connect.values(diff.removed).forEach(function(contactData) {\n         self.bus.trigger(connect.ContactEvents.DESTROYED, new connect.ContactSnapshot(contactData));\n         self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.DESTROYED, contactData.contactId), new connect.ContactSnapshot(contactData));\n         self._unsubAllContactEventsForContact(contactData.contactId);\n      });\n\n      connect.keys(diff.common).forEach(function(contactId) {\n         self._fireContactUpdateEvents(contactId, diff.oldMap[contactId].state.type, diff.newMap[contactId].state.type);\n      });\n   };\n\n   AgentDataProvider.prototype._fireContactUpdateEvents = function(contactId, oldContactState, newContactState) {\n      var self = this;\n      if (oldContactState !== newContactState) {\n         connect.core.getContactEventGraph().getAssociations(this, oldContactState, newContactState).forEach(function(event) {\n            self.bus.trigger(event, new connect.Contact(contactId));\n            self.bus.trigger(connect.core.getContactEventName(event, contactId), new connect.Contact(contactId));\n         });\n      }\n\n      self.bus.trigger(connect.ContactEvents.REFRESH, new connect.Contact(contactId));\n      self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.REFRESH, contactId), new connect.Contact(contactId));\n   };\n\n   AgentDataProvider.prototype._unsubAllContactEventsForContact = function(contactId) {\n      var self = this;\n      connect.values(connect.ContactEvents).forEach(function(eventName) {\n         self.bus.getSubscriptions(connect.core.getContactEventName(eventName, contactId))\n            .map(function(sub) { sub.unsubscribe(); });\n      });\n   };\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getContactEventName = function(eventName, contactId) {\n      connect.assertNotNull(eventName, \'eventName\');\n      connect.assertNotNull(contactId, \'contactId\');\n      if (! connect.contains(connect.values(connect.ContactEvents), eventName)) {\n         throw new connect.ValueError(\'%s is not a valid contact event.\', eventName);\n      }\n      return connect.sprintf(\'%s::%s\', eventName, contactId);\n   };\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getEventBus = function() {\n      return connect.core.eventBus;\n   };\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getAgentDataProvider = function() {\n      return connect.core.agentDataProvider;\n   };\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getLocalTimestamp = function() {\n      return connect.core.getAgentDataProvider().getAgentData().snapshot.localTimestamp;\n   };\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getAgentRoutingEventGraph = function() {\n      return connect.core.agentRoutingEventGraph;\n   };\n   connect.core.agentRoutingEventGraph = new connect.EventGraph()\n      .assoc(connect.EventGraph.ANY, connect.AgentStateType.ROUTABLE,\n             connect.AgentEvents.ROUTABLE)\n      .assoc(connect.EventGraph.ANY, connect.AgentStateType.NOT_ROUTABLE,\n             connect.AgentEvents.NOT_ROUTABLE)\n      .assoc(connect.EventGraph.ANY, connect.AgentStateType.OFFLINE,\n             connect.AgentEvents.OFFLINE);\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getAgentStateEventGraph = function() {\n      return connect.core.agentStateEventGraph;\n   };\n   connect.core.agentStateEventGraph = new connect.EventGraph()\n      .assoc(connect.EventGraph.ANY,\n             connect.values(connect.AgentErrorStates),\n             connect.AgentEvents.ERROR)\n      .assoc(connect.EventGraph.ANY, connect.AgentAvailStates.AFTER_CALL_WORK,\n             connect.AgentEvents.ACW);\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getContactEventGraph = function() {\n      return connect.core.contactEventGraph;\n   };\n\n   connect.core.contactEventGraph = new connect.EventGraph()\n      .assoc(connect.EventGraph.ANY,\n             connect.ContactStateType.INCOMING,\n             connect.ContactEvents.INCOMING)\n      .assoc(connect.EventGraph.ANY,\n             connect.ContactStateType.PENDING,\n             connect.ContactEvents.PENDING)\n      .assoc(connect.EventGraph.ANY,\n             connect.ContactStateType.CONNECTING,\n             connect.ContactEvents.CONNECTING)\n      .assoc(connect.EventGraph.ANY,\n             connect.ContactStateType.CONNECTED,\n             connect.ContactEvents.CONNECTED)\n      .assoc(connect.ContactStateType.INCOMING,\n             connect.ContactStateType.ERROR,\n             connect.ContactEvents.MISSED)\n      .assoc(connect.EventGraph.ANY,\n             connect.ContactStateType.ENDED,\n             connect.ContactEvents.ACW)\n      .assoc(connect.values(connect.CONTACT_ACTIVE_STATES),\n             connect.values(connect.relativeComplement(connect.CONTACT_ACTIVE_STATES, connect.ContactStateType)),\n             connect.ContactEvents.ENDED);\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getClient = function() {\n      if (! connect.core.client) {\n         throw new connect.StateError(\'The connect core has not been initialized!\');\n      }\n      return connect.core.client;\n   };\n   connect.core.client = null;\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getMasterClient = function() {\n      if (! connect.core.masterClient) {\n         throw new connect.StateError(\'The connect master client has not been initialized!\');\n      }\n      return connect.core.masterClient;\n   };\n   connect.core.masterClient = null;\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getSoftphoneManager = function() {\n      return connect.core.softphoneManager;\n   };\n   connect.core.softphoneManager = null;\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getNotificationManager = function() {\n      if (! connect.core.notificationManager) {\n         connect.core.notificationManager = new connect.NotificationManager();\n      }\n      return connect.core.notificationManager;\n   };\n   connect.core.notificationManager = null;\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getPopupManager = function() {\n      return connect.core.popupManager;\n   };\n   connect.core.popupManager = new connect.PopupManager();\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getPopupManager = function() {\n      return connect.core.popupManager;\n   };\n   connect.core.popupManager = new connect.PopupManager();\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.getUpstream = function() {\n      if (! connect.core.upstream) {\n         throw new connect.StateError(\'There is no upstream conduit!\');\n      }\n      return connect.core.upstream;\n   };\n   connect.core.upstream = null;\n\n   /**-----------------------------------------------------------------------*/\n   connect.core.AgentDataProvider = AgentDataProvider;\n\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   var connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   var RingtoneEngine = function(softphoneParams) {\n      var self = this;\n\n      this._prevContactId = null;\n\n      connect.assertNotNull(softphoneParams, "softphoneParams");\n      if (! softphoneParams.ringtoneUrl || softphoneParams.ringtoneUrl === "") {\n         throw new Error("ringtoneUrl is required!");\n      }\n\n      if (global.Audio && typeof global.Promise !== "undefined") {\n         this._playableAudioPromise = new Promise(function(resolve, reject) {\n            self._audio = new Audio(softphoneParams.ringtoneUrl);\n            self._audio.loop = true;\n            self._audio.addEventListener("canplay", function(){\n               self._audioPlayable = true;\n               resolve(self._audio);\n            });\n         });\n\n      } else {\n         this._audio = null;\n         connect.getLog().error("Unable to provide a ringtone.");\n      }\n\n      // TODO: this should triggers onIncoming instead of onConnecting\n      // https://issues.amazon.com/issues/ConnectGatekeepers-974\n      connect.contact(function(contact) {\n         contact.onConnecting(function() {\n            if (contact.getType() === connect.ContactType.VOICE &&\n               contact.isSoftphoneCall() &&\n               contact.isInbound()) {\n\n               self._startRingtone();\n               self._prevContactId = contact.getContactId();\n\n               contact.onConnected(connect.hitch(self, self._stopRingtone));\n               contact.onAccepted(connect.hitch(self, self._stopRingtone));\n               contact.onEnded(connect.hitch(self, self._stopRingtone));\n            }\n         });\n      });\n   };\n\n   RingtoneEngine.prototype._startRingtone = function() {\n      if (this._audio) {\n         this._audio.play();\n      }\n   };\n\n   RingtoneEngine.prototype._stopRingtone = function() {\n      if (this._audio) {\n         this._audio.pause();\n         this._audio.currentTime = 0;\n      }\n   };\n\n   /**\n    * Stop ringtone.\n    */\n   RingtoneEngine.prototype.stopRingtone = function() {\n      this._stopRingtone();\n   };\n\n   /**\n    * Change the audio device used to play ringtone.\n    * If audio element is not fully initialized, the API will wait _audioPlayablePromise for 3 seconds and fail on timeout.\n    * This API is supported only by browsers that implemented ES6 Promise and http://www.w3.org/TR/audio-output/\n    * Return a Promise that indicates the result of changing output device.\n    */\n   RingtoneEngine.prototype.setOutputDevice = function(deviceId) {\n      if (this._playableAudioPromise) {\n         var playableAudioWithTimeout = Promise.race([\n            this._playableAudioPromise,\n            new Promise(function(resolve, reject){\n               global.setTimeout(function(){reject("Timed out waiting for playable audio");}, 3000/*ms*/);\n            })\n         ]);\n         return playableAudioWithTimeout.then(function(audio){\n            if (audio.setSinkId) {\n               return Promise.resolve(audio.setSinkId(deviceId));\n            } else {\n               return Promise.reject("Not supported");\n            }\n         });\n\n      }\n\n      if (global.Promise) {\n         return Promise.reject("Not eligible ringtone owner");\n      }\n   };\n\n   /* export connect.RingtoneEngine */\n   connect.RingtoneEngine = RingtoneEngine;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   var RTPJobIntervalMs = 1000;\n   var statsReportingJobIntervalMs = 30000;\n   var streamBufferSize = 500;\n   var CallTypeMap = {};\n   CallTypeMap[connect.SoftphoneCallType.AUDIO_ONLY] = \'Audio\';\n   CallTypeMap[connect.SoftphoneCallType.VIDEO_ONLY] = \'Video\';\n   CallTypeMap[connect.SoftphoneCallType.AUDIO_VIDEO] = \'AudioVideo\';\n   CallTypeMap[connect.SoftphoneCallType.NONE] = \'None\';\n\n   var MediaTypeMap = {};\n   MediaTypeMap[connect.ContactType.VOICE] = "Voice";\n   var UNKNOWN_MEDIA_TYPE = "Unknown";\n\n   var timeSeriesStreamStatsBuffer = [];\n   var aggregatedUserAudioStats = null;\n   var aggregatedRemoteAudioStats = null;\n   var rtpStatsJob = null;\n   var reportStatsJob = null;\n   //Logger specific to softphone.\n   var logger = null;\n\n   var SoftphoneErrorTypes = connect.SoftphoneErrorTypes;\n\n   var SoftphoneManager = function(softphoneParams) {\n      logger = new SoftphoneLogger(connect.getLog());\n      if (!isBrowserSoftPhoneSupported()) {\n         publishError(SoftphoneErrorTypes.UNSUPPORTED_BROWSER,\n                      "Connect does not support this browser. Some functionality may not work. ",\n                      "");\n      }\n      var gumPromise = fetchUserMedia({\n         success: function(stream) {\n            connect.core.setSoftphoneUserMediaStream(stream);\n         },\n         failure: function(err) {\n            publishError(err, "Your microphone is not enabled in your browser. ", "");\n         }\n      });\n\n      this.ringtoneEngine = null;\n\n      if (! softphoneParams.disableRingtone) {\n         this.ringtoneEngine = new connect.RingtoneEngine(softphoneParams);\n\n      } else {\n         logger.warn("Softphone ringtone has been disabled.");\n      }\n\n      connect.contact(function(contact) {\n         var callDetected = false;\n\n         contact.onRefresh(function() {\n            if (contact.isSoftphoneCall() && !callDetected && (\n                     contact.getStatus().type === connect.ContactStatusType.CONNECTING ||\n                     contact.getStatus().type === connect.ContactStatusType.INCOMING)) {\n\n               callDetected = true;\n               logger.info("Softphone call detected: ", contact.getContactId());\n               initializeParams();\n               var softphoneInfo = contact.getAgentConnection().getSoftphoneMediaInfo();\n               var callConfig = parseCallConfig(softphoneInfo.callConfigJson);\n\n               var session = new connect.RTCSession(\n                     callConfig.signalingEndpoint,\n                     callConfig.iceServers,\n                     softphoneInfo.callContextToken,\n                     logger,\n                     contact.getContactId());\n               session.mediaStream = connect.core.getSoftphoneUserMediaStream();\n               session.onSessionFailed = function(rtcSession, reason) {\n                   if (reason === connect.RTCErrors.ICE_COLLECTION_TIMEOUT) {\n                        var endPointUrl = "\\n";\n                        for (var i=0; i < rtcSession._iceServers.length; i++) {\n                            for (var j=0; j < rtcSession._iceServers[i].urls.length; j++) {\n                                endPointUrl = endPointUrl + rtcSession._iceServers[i].urls[j] + "\\n";\n                            }\n                        }\n                        publishError(SoftphoneErrorTypes.ICE_COLLECTION_TIMEOUT, "Ice collection timedout. " ,endPointUrl);\n                   } else if (reason === connect.RTCErrors.USER_BUSY) {\n                        publishError(SoftphoneErrorTypes.USER_BUSY_ERROR,\n                        "Softphone call UserBusy error. ",\n                        "");\n                   } else if (reason === connect.RTCErrors.SIGNALLING_HANDSHAKE_FAILURE) {\n                        publishError(SoftphoneErrorTypes.SIGNALLING_HANDSHAKE_FAILURE,\n                        "Handshaking with Signalling Server " + rtcSession._signalingUri + " failed. ",\n                        rtcSession._signalingUri);\n                   } else if (reason === connect.RTCErrors.GUM_TIMEOUT_FAILURE || reason === connect.RTCErrors.GUM_OTHER_FAILURE) {\n                        publishError(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED,\n                        "Your microphone is not enabled in your browser. ",\n                        "");\n                   } else if (reason === connect.RTCErrors.SIGNALLING_CONNECTION_FAILURE) {\n                        publishError(SoftphoneErrorTypes.SIGNALLING_CONNECTION_FAILURE,\n                        "URL " +  rtcSession._signalingUri + " cannot be reached. ",\n                        rtcSession._signalingUri);\n                   } else if (reason === connect.RTCErrors.CALL_NOT_FOUND) {\n                        //No need to publish any softphone error for this case. CCP UX will handle this case.\n                        logger.error("Softphone call failed due to CallNotFoundException.");\n                   } else {\n                        publishError(SoftphoneErrorTypes.WEBRTC_ERROR,\n                        "webrtc system error. ",\n                        "");\n                   }\n                   stopJobsAndReport(contact, rtcSession.sessionReport);\n               };\n               session.onSessionConnected = function(rtcSession) {\n                    //Become master to send logs, since we need logs from softphone tab.\n                    connect.becomeMaster(connect.MasterTopics.SEND_LOGS);\n                    //start stats collection and reporting jobs\n                    startStatsCollectionJob(rtcSession);\n                    startStatsReportingJob(contact);\n               };\n\n               session.onSessionCompleted = function(rtcSession) {\n                    //stop all jobs and perform one last job\n                    stopJobsAndReport(contact, rtcSession.sessionReport);\n               };\n               session.remoteAudioElement = document.getElementById(\'remote-audio\');\n               session.connect();\n            }\n         });\n      });\n   };\n\n   /** Parse the JSON encoded web call config into the data it represents. */\n   var parseCallConfig = function(serializedConfig) {\n       // Our underscore is too old for unescape\n       // https://issues.amazon.com/issues/CSWF-1467\n       var decodedJSON = serializedConfig.replace(/&quot;/g, \'"\');\n       return JSON.parse(decodedJSON);\n   };\n\n   var fetchUserMedia = function(callbacksIn) {\n      var callbacks = callbacksIn || {};\n      callbacks.success = callbacks.success || function() {};\n      callbacks.failure = callbacks.failure || function() {};\n\n      var CONSTRAINT = {\n         audio: true\n      };\n\n      var promise = null;\n\n      if (typeof Promise !== "function") {\n         callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);\n         return;\n      }\n\n      if (typeof navigator.mediaDevices === "object" && typeof navigator.mediaDevices.getUserMedia === "function") {\n         promise = navigator.mediaDevices.getUserMedia(CONSTRAINT);\n\n      } else if (typeof navigator.webkitGetUserMedia === "function") {\n         promise = new Promise(function(resolve, reject) {\n            navigator.webkitGetUserMedia(CONSTRAINT, resolve, reject);\n         });\n\n      } else {\n         callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);\n         return;\n      }\n\n      promise.then(function(stream) {\n         var audioTracks = stream.getAudioTracks();\n         if (audioTracks && audioTracks.length > 0) {\n            callbacks.success(stream);\n         } else {\n            callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);\n         }\n      }, function(err) {\n         callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);\n      });\n      return promise;\n   };\n\n   var publishError = function(errorType, message, endPointUrl) {\n      var bus = connect.core.getEventBus();\n      logger.error("Softphone error occurred : ", errorType,\n            message || "");\n      bus.trigger(connect.AgentEvents.SOFTPHONE_ERROR, new connect.SoftphoneError(errorType, message, endPointUrl));\n   };\n\n    var isBrowserSoftPhoneSupported = function () {\n        var userAgent = navigator.userAgent;\n        var browserVersion;\n        // In Opera, the true version is after "Opera" or after "Version"\n        if (userAgent.indexOf("Opera") !== -1) {\n            var versionOffset = userAgent.indexOf("Opera");\n            browserVersion = (userAgent.indexOf("Version") !== -1) ? userAgent.substring(versionOffset+8) : userAgent.substring(versionOffset+6);\n            if (browserVersion  && parseFloat(browserVersion, 10) > 17) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        // In Chrome, the true version is after "Chrome"\n        else if (userAgent.indexOf("Chrome") !== -1) {\n            browserVersion = userAgent.substring(userAgent.indexOf("Chrome")+7);\n            if (browserVersion && parseFloat(browserVersion, 10) > 22) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        // In Firefox, the true version is after "Firefox"\n        else if (userAgent.indexOf("Firefox") !== -1) {\n            browserVersion = userAgent.substring(userAgent.indexOf("Firefox")+8);\n            if (browserVersion && parseFloat(browserVersion, 10) > 21) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n        return false;\n    };\n\n    var sendSoftphoneMetrics = function(contact) {\n        var streamStats = timeSeriesStreamStatsBuffer.slice();\n        timeSeriesStreamStatsBuffer = [];\n        if (streamStats.length > 0) {\n            contact.sendSoftphoneMetrics(streamStats, {\n               success: function(){\n                   logger.info("sendSoftphoneMetrics success");\n               },\n               failure: function(data){\n                   logger.error("sendSoftphoneMetrics failed.")\n                      .withObject(data);\n               }\n            });\n        }\n    };\n\n    var sendSoftphoneReport = function(contact, report, userAudioStats, remoteAudioStats) {\n        report.streamStats = [userAudioStats || {}, remoteAudioStats || {}];\n        var callReport = {\n                        callStartTime: report.sessionStartTime,\n                        callEndTime: report.sessionEndTime,\n                        gumTimeMillis: report.gumTimeMillis,\n                        initializationTimeMillis: report.initializationTimeMillis,\n                        iceCollectionTimeMillis: report.iceCollectionTimeMillis,\n                        signallingConnectTimeMillis: report.signallingConnectTimeMillis,\n                        handshakingTimeMillis: report.handshakingTimeMillis,\n                        preTalkingTimeMillis: report.preTalkingTimeMillis,\n                        talkingTimeMillis: report.talkingTimeMillis,\n                        cleanupTimeMillis: report.cleanupTimeMillis,\n                        iceCollectionFailure: report.iceCollectionFailure,\n                        signallingConnectionFailure: report.signallingConnectionFailure,\n                        handshakingFailure: report.handshakingFailure,\n                        gumOtherFailure: report.gumOtherFailure,\n                        gumTimeoutFailure: report.gumTimeoutFailure,\n                        createOfferFailure: report.createOfferFailure,\n                        setLocalDescriptionFailure: report.setLocalDescriptionFailure,\n                        userBusyFailure: report.userBusyFailure,\n                        invalidRemoteSDPFailure: report.invalidRemoteSDPFailure,\n                        noRemoteIceCandidateFailure: report.noRemoteIceCandidateFailure,\n                        setRemoteDescriptionFailure: report.setRemoteDescriptionFailure,\n                        softphoneStreamStatistics: [userAudioStats, remoteAudioStats]\n                      };\n        contact.sendSoftphoneReport(callReport, {\n            success: function(){\n                logger.info("sendSoftphoneReport success");\n            },\n            failure: function(data){\n                logger.error("sendSoftphoneReport failed.")\n                    .withObject(data);\n            }\n        });\n    };\n\n    var startStatsCollectionJob = function(rtcSession) {\n        rtpStatsJob = window.setInterval(function() {\n            rtcSession.getUserAudioStats().then(function(stats) {\n                var previousUserStats = aggregatedUserAudioStats;\n                var timestamp = new Date();\n                aggregatedUserAudioStats = evaluateReportStats(timestamp, stats, \'audio_input\');\n                timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedUserAudioStats, previousUserStats));\n            }, function(error) {\n                logger.debug("Failed to get user audio stats.", error);\n            });\n            rtcSession.getRemoteAudioStats().then(function(stats) {\n                var previousRemoteStats = aggregatedRemoteAudioStats;\n                var timestamp = new Date();\n                aggregatedRemoteAudioStats = evaluateReportStats(timestamp, stats, \'audio_output\');\n                timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedRemoteAudioStats, previousRemoteStats));\n            }, function(error) {\n                logger.debug("Failed to get remote audio stats.", error);\n            });\n        }, 1000);\n    };\n\n    var startStatsReportingJob = function(contact) {\n        reportStatsJob = window.setInterval(function() {\n                           sendSoftphoneMetrics(contact);\n        }, statsReportingJobIntervalMs);\n    };\n\n    var initializeParams = function() {\n        aggregatedUserAudioStats = null;\n        aggregatedRemoteAudioStats = null;\n        timeSeriesStreamStatsBuffer = [];\n        rtpStatsJob = null;\n        reportStatsJob = null;\n    };\n\n    var getTimeSeriesStats = function(currentStats, previousStats) {\n        if (previousStats && currentStats) {\n            var packetsLost = currentStats.getPacketsLost() > previousStats.getPacketsLost() ? currentStats.getPacketsLost() - previousStats.getPacketsLost() : 0;\n            var packetsCount = currentStats.getPacketsCount() > previousStats.getPacketsCount() ? currentStats.getPacketsCount() - previousStats.getPacketsCount()  : 0;\n            return new AudioRtpStats(currentStats.getTimestamp(), packetsLost, packetsCount, previousStats.getSoftphoneStreamType(), currentStats.getAudioLevel());\n        } else {\n            return currentStats;\n        }\n    };\n\n    var stopJob = function(task) {\n        if (task !== null){\n            window.clearInterval(task);\n        }\n        return null;\n    };\n\n    var stopJobsAndReport = function(contact, sessionReport) {\n       rtpStatsJob = stopJob(rtpStatsJob);\n       reportStatsJob = stopJob(reportStatsJob);\n       sendSoftphoneReport(contact, sessionReport, aggregatedUserAudioStats, aggregatedRemoteAudioStats);\n       sendSoftphoneMetrics(contact);\n    };\n\n    /**\n     * Extract rtp stats from RTCStatsReport\n     */\n    var evaluateReportStats = function (timestamp, stats, streamType) {\n        var callStats = null;\n        if (!stats) {\n            return callStats;\n        }\n        var statsReports = Object.keys(stats);\n        if (statsReports) {\n            for (var i = 0; i < statsReports.length; i++) {\n                var statsReport = stats[statsReports[i]];\n                if (statsReport && (statsReport.type === \'outboundrtp\' ||\n                                        statsReport.type === \'inboundrtp\' ||\n                                            statsReport.type === \'ssrc\')) {\n                    var packetsLost = 0;\n                    var audioLevel = null;\n                    if (typeof statsReport.packetsLost === \'undefined\' || statsReport.packetsLost < 0) { // Chrome reports -1 when there is no packet loss\n                        packetsLost = 0;\n                    }\n                    if (typeof statsReport.packetsSent !== \'undefined\') {\n                        //no audio level in firefox\n                        if (typeof statsReport.audioInputLevel !== \'undefined\') {\n                            audioLevel = statsReport.audioInputLevel;\n                        }\n                        callStats = new AudioRtpStats(timestamp, packetsLost, statsReport.packetsSent, streamType, audioLevel);\n                    } else if (typeof statsReport.packetsReceived !== \'undefined\') {\n                        //no audio level in firefox\n                        if (typeof statsReport.audioOutputLevel !== \'undefined\') {\n                            audioLevel = statsReport.audioOutputLevel;\n                        }\n                        callStats = new AudioRtpStats(timestamp, packetsLost, statsReport.packetsReceived, streamType, audioLevel);\n                    }\n                }\n            }\n        }\n        return callStats;\n    };\n\n    var AudioRtpStats = function(timestamp, packetsLost, packetsCount, streamType, audioLevel) {\n        this.timestamp = timestamp;\n        this.packetsLost = packetsLost;\n        this.packetsCount = packetsCount;\n        this.softphoneStreamType = streamType;\n        //Currently firefox doesn\'t provide audio level in rtp stats.\n        this.audioLevel = audioLevel;\n    };\n    /** {number} number of packets sent to the channel */\n    AudioRtpStats.prototype.getPacketsCount = function() {\n        return this.packetsCount;\n    };\n    /** {number} number of packets lost after travelling through the channel */\n    AudioRtpStats.prototype.getPacketsLost = function() {\n        return this.packetsLost;\n    };\n    /** {number} number of packets lost after travelling through the channel */\n    AudioRtpStats.prototype.getPacketLossPercentage = function() {\n        return this.packetsCount > 0 ? this.packetsLost/this.packetsCount : 0;\n    };\n    /** Audio volume level */\n    AudioRtpStats.prototype.getAudioLevel = function() {\n        return this.audioLevel;\n    };\n    /** Audio stream type */\n    AudioRtpStats.prototype.getSoftphoneStreamType = function() {\n        return this.softphoneStreamType;\n    };\n    /** Timestamp when stats are collected. */\n    AudioRtpStats.prototype.getTimestamp = function() {\n        return this.timestamp;\n    };\n\n    var SoftphoneLogger = function(logger) {\n        this._originalLogger = logger;\n        var self = this;\n        this._tee = function(level, method) {\n            return function() {\n                // call the original logger object to output to browser\n                //Connect logger follows %s format to print objects to console.\n                var args = Array.prototype.slice.call(arguments[0]);\n                var format = "";\n                args.forEach(function(){\n                    format = format + " %s";\n                });\n                method.apply(self._originalLogger, [connect.LogComponent.SOFTPHONE, format].concat(args));\n            };\n        };\n    };\n\n    SoftphoneLogger.prototype.debug =  function() {\n        this._tee(1, this._originalLogger.debug)(arguments);\n    };\n    SoftphoneLogger.prototype.info =  function() {\n        this._tee(2, this._originalLogger.info)(arguments);\n    };\n    SoftphoneLogger.prototype.log =  function() {\n        this._tee(3, this._originalLogger.log)(arguments);\n    };\n    SoftphoneLogger.prototype.warn =  function() {\n        this._tee(4, this._originalLogger.warn)(arguments);\n    };\n    SoftphoneLogger.prototype.error =  function() {\n        this._tee(5, this._originalLogger.error)(arguments);\n    };\n\n    connect.SoftphoneManager = SoftphoneManager;\n})();\n/*\n * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n *\n * Licensed under the Amazon Software License (the "License"). You may not use\n * this file except in compliance with the License. A copy of the License is\n * located at\n *\n *    http://aws.amazon.com/asl/\n *\n * or in the "license" file accompanying this file. This file is distributed\n * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express\n * or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n(function() {\n   var global = this;\n   connect = global.connect || {};\n   global.connect = connect;\n   global.lily = connect;\n\n   connect.worker = {};\n\n   var GET_AGENT_TIMEOUT = 30000;\n   var GET_AGENT_RECOVERY_TIMEOUT = 5000;\n   var GET_AGENT_SUCCESS_TIMEOUT = 100;\n   var LOG_BUFFER_CAP_SIZE = 400;\n\n   var GET_AGENT_CONFIGURATION_INTERVAL = 30000;      // 30sec\n\n   /**-----------------------------------------------------------------------*/\n   var MasterTopicCoordinator = function() {\n      this.topicMasterMap = {};\n   };\n\n   MasterTopicCoordinator.prototype.getMaster = function(topic) {\n      connect.assertNotNull(topic, \'topic\');\n      return this.topicMasterMap[topic] || null;\n   };\n\n   MasterTopicCoordinator.prototype.setMaster = function(topic, id) {\n      connect.assertNotNull(topic, \'topic\');\n      connect.assertNotNull(id, \'id\');\n      this.topicMasterMap[topic] = id;\n   };\n\n   MasterTopicCoordinator.prototype.removeMaster = function(id) {\n      connect.assertNotNull(id, \'id\');\n      var self = this;\n\n      connect.entries(this.topicMasterMap).filter(function(entry) {\n         return entry.value === id;\n      }).forEach(function(entry) {\n         delete self.topicMasterMap[entry.key];\n      });\n   };\n\n   /**-------------------------------------------------------------------------\n    * The object responsible for polling and passing data downstream to all\n    * consumer ports.\n    */\n   var ClientEngine = function() {\n      var self = this;\n\n      this.client = null;\n      this.multiplexer = new connect.StreamMultiplexer();\n      this.conduit = new connect.Conduit("AmazonConnectSharedWorker", null, this.multiplexer);\n      this.timeout = null;\n      this.agent = null;\n      this.nextToken = null;\n      this.initData = {};\n      this.portConduitMap = {};\n      this.masterCoord = new MasterTopicCoordinator();\n      this.logsBuffer = [];\n\n      connect.rootLogger = new connect.DownstreamConduitLogger(this.conduit);\n\n      this.conduit.onDownstream(connect.EventType.SEND_LOGS, function(logsToUpload) {\n         self.logsBuffer = self.logsBuffer.concat(logsToUpload);\n         //only call API to send logs if buffer reached cap\n         if (self.logsBuffer.length > LOG_BUFFER_CAP_SIZE) {\n            self.handleSendLogsRequest(self.logsBuffer);\n         }\n      });\n      this.conduit.onDownstream(connect.EventType.CONFIGURE, function(data) {\n         if (data.authToken && data.authToken !== self.initData.authToken) {\n            self.initData = data;\n            connect.core.init(data);\n\n            // Start polling for agent data.\n            self.pollForAgent();\n            self.pollForAgentConfiguration({repeatForever: true});\n         }\n      });\n      this.conduit.onDownstream(connect.EventType.TERMINATE, function() {\n         //upload pending logs before terminating.\n         self.handleSendLogsRequest(self.logsBuffer);\n         connect.core.terminate();\n         self.conduit.sendDownstream(connect.EventType.TERMINATED);\n      });\n      this.conduit.onDownstream(connect.EventType.SYNCHRONIZE, function() {\n         self.conduit.sendDownstream(connect.EventType.ACKNOWLEDGE);\n      });\n\n      /**\n       * Called when a consumer port connects to this SharedWorker.\n       * Let\'s add them to our multiplexer.\n       */\n      global.onconnect = function(event) {\n         var port = event.ports[0];\n         var stream = new connect.PortStream(port);\n         self.multiplexer.addStream(stream);\n         port.start();\n\n         var portConduit = new connect.Conduit(stream.getId(), null, stream);\n         portConduit.sendDownstream(connect.EventType.ACKNOWLEDGE, {id: stream.getId()});\n\n         self.portConduitMap[stream.getId()] = portConduit;\n\n         if (self.agent !== null) {\n            portConduit.sendDownstream(connect.AgentEvents.UPDATE, self.agent);\n         }\n\n         portConduit.onDownstream(connect.EventType.API_REQUEST,\n               connect.hitch(self, self.handleAPIRequest, portConduit));\n         portConduit.onDownstream(connect.EventType.MASTER_REQUEST,\n               connect.hitch(self, self.handleMasterRequest, portConduit, stream.getId()));\n         portConduit.onDownstream(connect.EventType.RELOAD_AGENT_CONFIGURATION,\n               connect.hitch(self, self.pollForAgentConfiguration));\n         portConduit.onDownstream(connect.EventType.CLOSE, function() {\n            self.multiplexer.removeStream(stream);\n            delete self.portConduitMap[stream.getId()];\n            self.masterCoord.removeMaster(stream.getId());\n         });\n      };\n   };\n\n   ClientEngine.prototype.pollForAgent = function() {\n      var self = this;\n      var client = connect.core.getClient();\n\n      this.checkAuthToken();\n\n      client.call(connect.ClientMethods.GET_AGENT_SNAPSHOT, {\n         nextToken:     self.nextToken,\n         timeout:       GET_AGENT_TIMEOUT\n      }, {\n         success: function(data) {\n            self.agent = self.agent || {};\n            self.agent.snapshot = data.snapshot;\n            self.nextToken = data.nextToken;\n            self.updateAgent();\n            global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_SUCCESS_TIMEOUT);\n         },\n         failure: function(err, data) {\n            try {\n               connect.getLog().error("Failed to get agent data.")\n                  .withObject({\n                     err: err,\n                     data: data\n                  });\n\n            } finally {\n               global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_RECOVERY_TIMEOUT);\n            }\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n\n   };\n\n   ClientEngine.prototype.pollForAgentConfiguration = function(paramsIn) {\n      var self = this;\n      var client = connect.core.getClient();\n      var params = paramsIn || {};\n\n      client.call(connect.ClientMethods.GET_AGENT_CONFIGURATION, {}, {\n         success: function(data) {\n            var configuration = data.configuration;\n            self.pollForAgentPermissions(configuration);\n            self.pollForAgentStates(configuration);\n            self.pollForDialableCountryCodes(configuration);\n            self.pollForRoutingProfileQueues(configuration);\n            if (params.repeatForever) {\n               global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration, params),\n                  GET_AGENT_CONFIGURATION_INTERVAL);\n            }\n         },\n         failure: function(err, data) {\n            try {\n               connect.getLog().error("Failed to fetch agent configuration data.")\n                  .withObject({\n                     err: err,\n                     data: data\n                  });\n            } finally {\n               if (params.repeatForever) {\n                  global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration),\n                     GET_AGENT_CONFIGURATION_INTERVAL, params);\n               }\n            }\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   ClientEngine.prototype.pollForAgentStates = function(configuration, paramsIn) {\n      var self = this;\n      var client = connect.core.getClient();\n      var params = paramsIn || {};\n      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n\n      client.call(connect.ClientMethods.GET_AGENT_STATES, {\n         nextToken: params.nextToken || null,\n         maxResults: params.maxResults\n\n      }, {\n         success: function(data) {\n            if (data.nextToken) {\n               self.pollForAgentStates(configuration, {\n                  states:   (params.states || []).concat(data.states),\n                  nextToken:     data.nextToken,\n                  maxResults:    params.maxResults\n               });\n\n            } else {\n               configuration.agentStates = (params.states || []).concat(data.states);\n               self.updateAgentConfiguration(configuration);\n            }\n         },\n         failure: function(err, data) {\n            connect.getLog().error("Failed to fetch agent states list.")\n               .withObject({\n                  err: err,\n                  data: data\n               });\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   ClientEngine.prototype.pollForAgentPermissions = function(configuration, paramsIn) {\n      var self = this;\n      var client = connect.core.getClient();\n      var params = paramsIn || {};\n      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n\n      client.call(connect.ClientMethods.GET_AGENT_PERMISSIONS, {\n         nextToken: params.nextToken || null,\n         maxResults: params.maxResults\n\n      }, {\n         success: function(data) {\n            if (data.nextToken) {\n               self.pollForAgentPermissions(configuration, {\n                  permissions:   (params.permissions || []).concat(data.permissions),\n                  nextToken:     data.nextToken,\n                  maxResults:    params.maxResults\n               });\n\n            } else {\n               configuration.permissions = (params.permissions || []).concat(data.permissions);\n               self.updateAgentConfiguration(configuration);\n            }\n         },\n         failure: function(err, data) {\n            connect.getLog().error("Failed to fetch agent permissions list.")\n               .withObject({\n                  err: err,\n                  data: data\n               });\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   ClientEngine.prototype.pollForDialableCountryCodes = function(configuration, paramsIn) {\n      var self = this;\n      var client = connect.core.getClient();\n      var params = paramsIn || {};\n      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n\n      client.call(connect.ClientMethods.GET_DIALABLE_COUNTRY_CODES, {\n         nextToken: params.nextToken || null,\n         maxResults: params.maxResults\n      }, {\n         success: function(data) {\n            if (data.nextToken) {\n               self.pollForDialableCountryCodes(configuration, {\n                  countryCodes:  (params.countryCodes || []).concat(data.countryCodes),\n                  nextToken:     data.nextToken,\n                  maxResults:    params.maxResults\n               });\n\n            } else {\n               configuration.dialableCountries = (params.countryCodes || []).concat(data.countryCodes);\n               self.updateAgentConfiguration(configuration);\n            }\n         },\n         failure: function(err, data) {\n            connect.getLog().error("Failed to fetch dialable country codes list.")\n               .withObject({\n                  err: err,\n                  data: data\n               });\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   ClientEngine.prototype.pollForRoutingProfileQueues = function(configuration, paramsIn) {\n      var self = this;\n      var client = connect.core.getClient();\n      var params = paramsIn || {};\n      params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;\n\n      client.call(connect.ClientMethods.GET_ROUTING_PROFILE_QUEUES, {\n         routingProfileARN: configuration.routingProfile.routingProfileARN,\n         nextToken: params.nextToken || null,\n         maxResults: params.maxResults\n      }, {\n         success: function(data) {\n            if (data.nextToken) {\n               self.pollForRoutingProfileQueues(configuration, {\n                  countryCodes:  (params.queues || []).concat(data.queues),\n                  nextToken:     data.nextToken,\n                  maxResults:    params.maxResults\n               });\n\n            } else {\n               configuration.routingProfile.queues = (params.queues || []).concat(data.queues);\n               self.updateAgentConfiguration(configuration);\n            }\n         },\n         failure: function(err, data) {\n            connect.getLog().error("Failed to fetch routing profile queues list.")\n               .withObject({\n                  err: err,\n                  data: data\n               });\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   ClientEngine.prototype.handleAPIRequest = function(portConduit, request) {\n      var self = this;\n      var client = connect.core.getClient();\n\n      client.call(request.method, request.params, {\n         success: function(data) {\n            var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data);\n            portConduit.sendDownstream(response.event, response);\n         },\n         failure: function(err, data) {\n            var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data, JSON.stringify(err));\n            portConduit.sendDownstream(response.event, response);\n            connect.getLog().error("\'%s\' API request failed: %s", request.method, err)\n               .withObject({request: request, response: response});\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   /**\n    * Handle incoming master query or modification requests from connected tab ports.\n    */\n   ClientEngine.prototype.handleMasterRequest = function(portConduit, portId, request) {\n      var response = null;\n\n      switch(request.method) {\n      case connect.MasterMethods.BECOME_MASTER:\n         this.masterCoord.setMaster(request.params.topic, portId);\n         response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {\n            masterId:   portId,\n            isMaster:   true,\n            topic:      request.params.topic\n         });\n\n         break;\n\n      case connect.MasterMethods.CHECK_MASTER:\n         var masterId = this.masterCoord.getMaster(request.params.topic);\n         if (!masterId) {\n            this.masterCoord.setMaster(request.params.topic, portId);\n            masterId = portId;\n         }\n\n         response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {\n            masterId:   masterId,\n            isMaster:   portId === masterId,\n            topic:      request.params.topic\n         });\n\n         break;\n\n      default:\n         throw new Error("Unknown master method: " + request.method);\n      }\n\n      portConduit.sendDownstream(response.event, response);\n   };\n\n   ClientEngine.prototype.updateAgentConfiguration = function(configuration) {\n      if (configuration.permissions &&\n          configuration.dialableCountries &&\n          configuration.agentStates &&\n          configuration.routingProfile.queues) {\n\n         this.agent = this.agent || {};\n         this.agent.configuration = configuration;\n         this.updateAgent();\n\n      } else {\n         connect.getLog().trace("Waiting to update agent configuration until all config data has been fetched.");\n      }\n   };\n\n   ClientEngine.prototype.updateAgent = function() {\n      if (! this.agent) {\n         connect.getLog().trace("Waiting to update agent until the agent has been fully constructed.");\n\n      } else if (! this.agent.snapshot) {\n         connect.getLog().trace("Waiting to update agent until the agent snapshot is available.");\n\n      } else if (! this.agent.configuration) {\n         connect.getLog().trace("Waiting to update agent until the agent configuration is available.");\n\n      } else {\n         // Alias some of the properties for backwards compatibility.\n         this.agent.snapshot.status = this.agent.state;\n         this.agent.snapshot.contacts.forEach(function(contact) {\n            contact.status = contact.state;\n\n            contact.connections.forEach(function(connection) {\n               connection.address = connection.endpoint;\n            });\n         });\n\n         this.agent.configuration.routingProfile.defaultOutboundQueue.queueId =\n            this.agent.configuration.routingProfile.defaultOutboundQueue.queueARN;\n         this.agent.configuration.routingProfile.queues.forEach(function(queue) {\n            queue.queueId = queue.queueARN;\n         });\n         this.agent.snapshot.contacts.forEach(function(contact) {\n            //contact.queue is null when monitoring\n            if (contact.queue !== undefined) {\n                contact.queue.queueId = contact.queue.queueARN;\n            }\n         });\n         this.agent.configuration.routingProfile.routingProfileId =\n            this.agent.configuration.routingProfile.routingProfileARN;\n\n         this.conduit.sendDownstream(connect.AgentEvents.UPDATE, this.agent);\n      }\n   };\n\n   /**\n    * Send a message downstream to all consumers when we detect that authentication\n    * against one of our APIs has failed.\n    */\n   ClientEngine.prototype.handleSendLogsRequest = function() {\n      var self = this;\n      var client = connect.core.getClient();\n      var logEvents = [];\n      var logsToSend = self.logsBuffer.slice();\n      self.logsBuffer = [];\n      logsToSend.forEach(function(log) {\n         logEvents.push({\n            timestamp:  log.time,\n            component:  log.component,\n            message: log.text\n         });\n      });\n      client.call(connect.ClientMethods.SEND_CLIENT_LOGS, {logEvents: logEvents}, {\n         success: function(data) {\n            connect.getLog().info("SendLogs request succeeded.");\n         },\n         failure: function(err, data) {\n            connect.getLog().error("SendLogs request failed. %s", err);\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   ClientEngine.prototype.handleAuthFail = function() {\n      var self = this;\n      self.conduit.sendDownstream(connect.EventType.AUTH_FAIL);\n   };\n\n   ClientEngine.prototype.checkAuthToken = function() {\n      var self = this;\n      var expirationDate = new Date(self.initData.authTokenExpiration);\n      var currentTimeStamp = new Date().getTime();\n      var fiveMins = 5 * 60 * 1000;\n\n      // refresh token 5 minutes before expiration\n      if (expirationDate.getTime() < (currentTimeStamp + fiveMins)) {\n        this.refreshAuthToken();\n      }\n   };\n\n   ClientEngine.prototype.refreshAuthToken = function() {\n      var self = this;\n      connect.assertNotNull(self.initData.refreshToken, \'initData.refreshToken\');\n\n      var client = connect.core.getClient();\n      client.call(connect.ClientMethods.GET_NEW_AUTH_TOKEN, {refreshToken: self.initData.refreshToken}, {\n         success: function(data) {\n            connect.getLog().info("Get new auth token succeeded. New auth token expired at %s", data.expirationDateTime);\n            self.initData.authToken = data.newAuthToken;\n            self.initData.authTokenExpiration = new Date(data.expirationDateTime);\n            connect.core.init(self.initData);\n         },\n         failure: function(err, data) {\n            connect.getLog().error("Get new auth token failed. %s ", err);\n         },\n         authFailure: connect.hitch(self, self.handleAuthFail)\n      });\n   };\n\n   /**-----------------------------------------------------------------------*/\n   connect.worker.main = function() {\n      connect.worker.clientEngine = new ClientEngine();\n   };\n\n})();\n'},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js":function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/index.js!./deskapp/js/amazon-connect-v1.0.5.js":function(n,e,t){t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js")(t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/amazon-connect-v1.0.5.js"))}}]);