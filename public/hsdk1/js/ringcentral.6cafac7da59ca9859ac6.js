(window.deskappJsonp=window.deskappJsonp||[]).push([[133],{"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/es6-promise.js":function(n,e){n.exports="/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.2.2+35df15ea\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n    function lib$es6$promise$then$$then(onFulfillment, onRejection) {\n      var parent = this;\n\n      var child = new this.constructor(lib$es6$promise$$internal$$noop);\n\n      if (child[lib$es6$promise$$internal$$PROMISE_ID] === undefined) {\n        lib$es6$promise$$internal$$makePromise(child);\n      }\n\n      var state = parent._state;\n\n      if (state) {\n        var callback = arguments[state - 1];\n        lib$es6$promise$asap$$asap(function(){\n          lib$es6$promise$$internal$$invokeCallback(state, child, callback, parent._result);\n        });\n      } else {\n        lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n      }\n\n      return child;\n    }\n    var lib$es6$promise$then$$default = lib$es6$promise$then$$then;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    var lib$es6$promise$$internal$$PROMISE_ID = Math.random().toString(36).substring(16);\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable, then) {\n      if (maybeThenable.constructor === promise.constructor &&\n          then === lib$es6$promise$then$$default &&\n          constructor.resolve === lib$es6$promise$promise$resolve$$default) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value, lib$es6$promise$$internal$$getThen(value));\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    var lib$es6$promise$$internal$$id = 0;\n    function lib$es6$promise$$internal$$nextId() {\n      return lib$es6$promise$$internal$$id++;\n    }\n\n    function lib$es6$promise$$internal$$makePromise(promise) {\n      promise[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$id++;\n      promise._state = undefined;\n      promise._result = undefined;\n      promise._subscribers = [];\n    }\n\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        return new Constructor(function(resolve, reject) {\n          reject(new TypeError('You must pass an array to race.'));\n        });\n      } else {\n        return new Constructor(function(resolve, reject) {\n          var length = entries.length;\n          for (var i = 0; i < length; i++) {\n            Constructor.resolve(entries[i]).then(resolve, reject);\n          }\n        });\n      }\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this[lib$es6$promise$$internal$$PROMISE_ID] = lib$es6$promise$$internal$$nextId();\n      this._result = this._state = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        typeof resolver !== 'function' && lib$es6$promise$promise$$needsResolver();\n        this instanceof lib$es6$promise$promise$$Promise ? lib$es6$promise$$internal$$initializePromise(this, resolver) : lib$es6$promise$promise$$needsNew();\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: lib$es6$promise$then$$default,\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      this._instanceConstructor = Constructor;\n      this.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!this.promise[lib$es6$promise$$internal$$PROMISE_ID]) {\n        lib$es6$promise$$internal$$makePromise(this.promise);\n      }\n\n      if (lib$es6$promise$utils$$isArray(input)) {\n        this._input     = input;\n        this.length     = input.length;\n        this._remaining = input.length;\n\n        this._result = new Array(this.length);\n\n        if (this.length === 0) {\n          lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n        } else {\n          this.length = this.length || 0;\n          this._enumerate();\n          if (this._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(this.promise, this._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(this.promise, lib$es6$promise$enumerator$$validationError());\n      }\n    }\n\n    function lib$es6$promise$enumerator$$validationError() {\n      return new Error('Array Methods must be provided an Array');\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var length  = this.length;\n      var input   = this._input;\n\n      for (var i = 0; this._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        this._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var c = this._instanceConstructor;\n      var resolve = c.resolve;\n\n      if (resolve === lib$es6$promise$promise$resolve$$default) {\n        var then = lib$es6$promise$$internal$$getThen(entry);\n\n        if (then === lib$es6$promise$then$$default &&\n            entry._state !== lib$es6$promise$$internal$$PENDING) {\n          this._settledAt(entry._state, i, entry._result);\n        } else if (typeof then !== 'function') {\n          this._remaining--;\n          this._result[i] = entry;\n        } else if (c === lib$es6$promise$promise$$default) {\n          var promise = new c(lib$es6$promise$$internal$$noop);\n          lib$es6$promise$$internal$$handleMaybeThenable(promise, entry, then);\n          this._willSettleAt(promise, i);\n        } else {\n          this._willSettleAt(new c(function(resolve) { resolve(entry); }), i);\n        }\n      } else {\n        this._willSettleAt(resolve(entry), i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var promise = this.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        this._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          this._result[i] = value;\n        }\n      }\n\n      if (this._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, this._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n"},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/fetch.js":function(n,e){n.exports="(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var list = this.map[name]\n    if (!list) {\n      list = []\n      this.map[name] = list\n    }\n    list.push(value)\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    var values = this.map[normalizeName(name)]\n    return values ? values[0] : null\n  }\n\n  Headers.prototype.getAll = function(name) {\n    return this.map[normalizeName(name)] || []\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = [normalizeValue(value)]\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    Object.getOwnPropertyNames(this.map).forEach(function(name) {\n      this.map[name].forEach(function(value) {\n        callback.call(thisArg, value, name, this)\n      }, this)\n    }, this)\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    reader.readAsArrayBuffer(blob)\n    return fileReaderReady(reader)\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    reader.readAsText(blob)\n    return fileReaderReady(reader)\n  }\n\n  var support = {\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (!body) {\n        this._bodyText = ''\n      } else if (support.arrayBuffer && ArrayBuffer.prototype.isPrototypeOf(body)) {\n        // Only support ArrayBuffers for POST method.\n        // Receiving ArrayBuffers happens via Blobs, instead.\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        return this.blob().then(readBlobAsArrayBuffer)\n      }\n\n      this.text = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return readBlobAsText(this._bodyBlob)\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as text')\n        } else {\n          return Promise.resolve(this._bodyText)\n        }\n      }\n    } else {\n      this.text = function() {\n        var rejected = consumed(this)\n        return rejected ? rejected : Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n    if (Request.prototype.isPrototypeOf(input)) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = input\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this)\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function headers(xhr) {\n    var head = new Headers()\n    var pairs = (xhr.getAllResponseHeaders() || '').trim().split('\\n')\n    pairs.forEach(function(header) {\n      var split = header.trim().split(':')\n      var key = split.shift().trim()\n      var value = split.join(':').trim()\n      head.append(key, value)\n    })\n    return head\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = options.statusText\n    this.headers = options.headers instanceof Headers ? options.headers : new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request\n      if (Request.prototype.isPrototypeOf(input) && !init) {\n        request = input\n      } else {\n        request = new Request(input, init)\n      }\n\n      var xhr = new XMLHttpRequest()\n\n      function responseURL() {\n        if ('responseURL' in xhr) {\n          return xhr.responseURL\n        }\n\n        // Avoid security warnings on getResponseHeader when not allowed by CORS\n        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n          return xhr.getResponseHeader('X-Request-URL')\n        }\n\n        return\n      }\n\n      xhr.onload = function() {\n        var status = (xhr.status === 1223) ? 204 : xhr.status\n        if (status < 100 || status > 599) {\n          reject(new TypeError('Network request failed'))\n          return\n        }\n        var options = {\n          status: status,\n          statusText: xhr.statusText,\n          headers: headers(xhr),\n          url: responseURL()\n        }\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n"},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/pubnub.4.20.1.js":function(n,e){n.exports="/*! 4.20.1 / Consumer  */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PubNub\"] = factory();\n\telse\n\t\troot[\"PubNub\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _pubnubCommon = __webpack_require__(1);\n\n\tvar _pubnubCommon2 = _interopRequireDefault(_pubnubCommon);\n\n\tvar _networking = __webpack_require__(39);\n\n\tvar _networking2 = _interopRequireDefault(_networking);\n\n\tvar _web = __webpack_require__(40);\n\n\tvar _web2 = _interopRequireDefault(_web);\n\n\tvar _webNode = __webpack_require__(41);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tfunction sendBeacon(url) {\n\t  if (navigator && navigator.sendBeacon) {\n\t    navigator.sendBeacon(url);\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\n\tvar _class = function (_PubNubCore) {\n\t  _inherits(_class, _PubNubCore);\n\n\t  function _class(setup) {\n\t    _classCallCheck(this, _class);\n\n\t    var _setup$listenToBrowse = setup.listenToBrowserNetworkEvents,\n\t        listenToBrowserNetworkEvents = _setup$listenToBrowse === undefined ? true : _setup$listenToBrowse;\n\n\n\t    setup.db = _web2.default;\n\t    setup.sdkFamily = 'Web';\n\t    setup.networking = new _networking2.default({ del: _webNode.del, get: _webNode.get, post: _webNode.post, sendBeacon: sendBeacon });\n\n\t    var _this = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this, setup));\n\n\t    if (listenToBrowserNetworkEvents) {\n\t      window.addEventListener('offline', function () {\n\t        _this.networkDownDetected();\n\t      });\n\n\t      window.addEventListener('online', function () {\n\t        _this.networkUpDetected();\n\t      });\n\t    }\n\t    return _this;\n\t  }\n\n\t  return _class;\n\t}(_pubnubCommon2.default);\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _config2 = _interopRequireDefault(_config);\n\n\tvar _index = __webpack_require__(6);\n\n\tvar _index2 = _interopRequireDefault(_index);\n\n\tvar _subscription_manager = __webpack_require__(8);\n\n\tvar _subscription_manager2 = _interopRequireDefault(_subscription_manager);\n\n\tvar _listener_manager = __webpack_require__(9);\n\n\tvar _listener_manager2 = _interopRequireDefault(_listener_manager);\n\n\tvar _endpoint = __webpack_require__(16);\n\n\tvar _endpoint2 = _interopRequireDefault(_endpoint);\n\n\tvar _add_channels = __webpack_require__(17);\n\n\tvar addChannelsChannelGroupConfig = _interopRequireWildcard(_add_channels);\n\n\tvar _remove_channels = __webpack_require__(18);\n\n\tvar removeChannelsChannelGroupConfig = _interopRequireWildcard(_remove_channels);\n\n\tvar _delete_group = __webpack_require__(19);\n\n\tvar deleteChannelGroupConfig = _interopRequireWildcard(_delete_group);\n\n\tvar _list_groups = __webpack_require__(20);\n\n\tvar listChannelGroupsConfig = _interopRequireWildcard(_list_groups);\n\n\tvar _list_channels = __webpack_require__(21);\n\n\tvar listChannelsInChannelGroupConfig = _interopRequireWildcard(_list_channels);\n\n\tvar _add_push_channels = __webpack_require__(22);\n\n\tvar addPushChannelsConfig = _interopRequireWildcard(_add_push_channels);\n\n\tvar _remove_push_channels = __webpack_require__(23);\n\n\tvar removePushChannelsConfig = _interopRequireWildcard(_remove_push_channels);\n\n\tvar _list_push_channels = __webpack_require__(24);\n\n\tvar listPushChannelsConfig = _interopRequireWildcard(_list_push_channels);\n\n\tvar _remove_device = __webpack_require__(25);\n\n\tvar removeDevicePushConfig = _interopRequireWildcard(_remove_device);\n\n\tvar _leave = __webpack_require__(26);\n\n\tvar presenceLeaveEndpointConfig = _interopRequireWildcard(_leave);\n\n\tvar _where_now = __webpack_require__(27);\n\n\tvar presenceWhereNowEndpointConfig = _interopRequireWildcard(_where_now);\n\n\tvar _heartbeat = __webpack_require__(28);\n\n\tvar presenceHeartbeatEndpointConfig = _interopRequireWildcard(_heartbeat);\n\n\tvar _get_state = __webpack_require__(29);\n\n\tvar presenceGetStateConfig = _interopRequireWildcard(_get_state);\n\n\tvar _set_state = __webpack_require__(30);\n\n\tvar presenceSetStateConfig = _interopRequireWildcard(_set_state);\n\n\tvar _here_now = __webpack_require__(31);\n\n\tvar presenceHereNowConfig = _interopRequireWildcard(_here_now);\n\n\tvar _audit = __webpack_require__(32);\n\n\tvar auditEndpointConfig = _interopRequireWildcard(_audit);\n\n\tvar _grant = __webpack_require__(33);\n\n\tvar grantEndpointConfig = _interopRequireWildcard(_grant);\n\n\tvar _publish = __webpack_require__(34);\n\n\tvar publishEndpointConfig = _interopRequireWildcard(_publish);\n\n\tvar _get_history = __webpack_require__(35);\n\n\tvar historyEndpointConfig = _interopRequireWildcard(_get_history);\n\n\tvar _delete_messages = __webpack_require__(36);\n\n\tvar deleteMessagesEndpointConfig = _interopRequireWildcard(_delete_messages);\n\n\tvar _fetch_messages = __webpack_require__(37);\n\n\tvar fetchMessagesEndpointConfig = _interopRequireWildcard(_fetch_messages);\n\n\tvar _time = __webpack_require__(12);\n\n\tvar timeEndpointConfig = _interopRequireWildcard(_time);\n\n\tvar _subscribe = __webpack_require__(38);\n\n\tvar subscribeEndpointConfig = _interopRequireWildcard(_subscribe);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _categories = __webpack_require__(10);\n\n\tvar _categories2 = _interopRequireDefault(_categories);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _uuid = __webpack_require__(3);\n\n\tvar _uuid2 = _interopRequireDefault(_uuid);\n\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar _class = function () {\n\t  function _class(setup) {\n\t    var _this = this;\n\n\t    _classCallCheck(this, _class);\n\n\t    var db = setup.db,\n\t        networking = setup.networking;\n\n\n\t    var config = this._config = new _config2.default({ setup: setup, db: db });\n\t    var crypto = new _index2.default({ config: config });\n\n\t    networking.init(config);\n\n\t    var modules = { config: config, networking: networking, crypto: crypto };\n\n\t    var timeEndpoint = _endpoint2.default.bind(this, modules, timeEndpointConfig);\n\t    var leaveEndpoint = _endpoint2.default.bind(this, modules, presenceLeaveEndpointConfig);\n\t    var heartbeatEndpoint = _endpoint2.default.bind(this, modules, presenceHeartbeatEndpointConfig);\n\t    var setStateEndpoint = _endpoint2.default.bind(this, modules, presenceSetStateConfig);\n\t    var subscribeEndpoint = _endpoint2.default.bind(this, modules, subscribeEndpointConfig);\n\n\t    var listenerManager = this._listenerManager = new _listener_manager2.default();\n\n\t    var subscriptionManager = new _subscription_manager2.default({\n\t      timeEndpoint: timeEndpoint,\n\t      leaveEndpoint: leaveEndpoint,\n\t      heartbeatEndpoint: heartbeatEndpoint,\n\t      setStateEndpoint: setStateEndpoint,\n\t      subscribeEndpoint: subscribeEndpoint,\n\t      crypto: modules.crypto,\n\t      config: modules.config,\n\t      listenerManager: listenerManager\n\t    });\n\n\t    this.addListener = listenerManager.addListener.bind(listenerManager);\n\t    this.removeListener = listenerManager.removeListener.bind(listenerManager);\n\t    this.removeAllListeners = listenerManager.removeAllListeners.bind(listenerManager);\n\n\t    this.channelGroups = {\n\t      listGroups: _endpoint2.default.bind(this, modules, listChannelGroupsConfig),\n\t      listChannels: _endpoint2.default.bind(this, modules, listChannelsInChannelGroupConfig),\n\t      addChannels: _endpoint2.default.bind(this, modules, addChannelsChannelGroupConfig),\n\t      removeChannels: _endpoint2.default.bind(this, modules, removeChannelsChannelGroupConfig),\n\t      deleteGroup: _endpoint2.default.bind(this, modules, deleteChannelGroupConfig)\n\t    };\n\n\t    this.push = {\n\t      addChannels: _endpoint2.default.bind(this, modules, addPushChannelsConfig),\n\t      removeChannels: _endpoint2.default.bind(this, modules, removePushChannelsConfig),\n\t      deleteDevice: _endpoint2.default.bind(this, modules, removeDevicePushConfig),\n\t      listChannels: _endpoint2.default.bind(this, modules, listPushChannelsConfig)\n\t    };\n\n\t    this.hereNow = _endpoint2.default.bind(this, modules, presenceHereNowConfig);\n\t    this.whereNow = _endpoint2.default.bind(this, modules, presenceWhereNowEndpointConfig);\n\t    this.getState = _endpoint2.default.bind(this, modules, presenceGetStateConfig);\n\t    this.setState = subscriptionManager.adaptStateChange.bind(subscriptionManager);\n\n\t    this.grant = _endpoint2.default.bind(this, modules, grantEndpointConfig);\n\t    this.audit = _endpoint2.default.bind(this, modules, auditEndpointConfig);\n\n\t    this.publish = _endpoint2.default.bind(this, modules, publishEndpointConfig);\n\n\t    this.fire = function (args, callback) {\n\t      args.replicate = false;\n\t      args.storeInHistory = false;\n\t      return _this.publish(args, callback);\n\t    };\n\n\t    this.history = _endpoint2.default.bind(this, modules, historyEndpointConfig);\n\t    this.deleteMessages = _endpoint2.default.bind(this, modules, deleteMessagesEndpointConfig);\n\t    this.fetchMessages = _endpoint2.default.bind(this, modules, fetchMessagesEndpointConfig);\n\n\t    this.time = timeEndpoint;\n\n\t    this.subscribe = subscriptionManager.adaptSubscribeChange.bind(subscriptionManager);\n\t    this.presence = subscriptionManager.adaptPresenceChange.bind(subscriptionManager);\n\t    this.unsubscribe = subscriptionManager.adaptUnsubscribeChange.bind(subscriptionManager);\n\t    this.disconnect = subscriptionManager.disconnect.bind(subscriptionManager);\n\t    this.reconnect = subscriptionManager.reconnect.bind(subscriptionManager);\n\n\t    this.destroy = function (isOffline) {\n\t      subscriptionManager.unsubscribeAll(isOffline);\n\t      subscriptionManager.disconnect();\n\t    };\n\n\t    this.stop = this.destroy;\n\n\t    this.unsubscribeAll = subscriptionManager.unsubscribeAll.bind(subscriptionManager);\n\n\t    this.getSubscribedChannels = subscriptionManager.getSubscribedChannels.bind(subscriptionManager);\n\t    this.getSubscribedChannelGroups = subscriptionManager.getSubscribedChannelGroups.bind(subscriptionManager);\n\n\t    this.encrypt = crypto.encrypt.bind(crypto);\n\t    this.decrypt = crypto.decrypt.bind(crypto);\n\n\t    this.getAuthKey = modules.config.getAuthKey.bind(modules.config);\n\t    this.setAuthKey = modules.config.setAuthKey.bind(modules.config);\n\t    this.setCipherKey = modules.config.setCipherKey.bind(modules.config);\n\t    this.getUUID = modules.config.getUUID.bind(modules.config);\n\t    this.setUUID = modules.config.setUUID.bind(modules.config);\n\t    this.getFilterExpression = modules.config.getFilterExpression.bind(modules.config);\n\t    this.setFilterExpression = modules.config.setFilterExpression.bind(modules.config);\n\n\t    this.setHeartbeatInterval = modules.config.setHeartbeatInterval.bind(modules.config);\n\n\t    if (networking.hasModule('proxy')) {\n\t      this.setProxy = function (proxy) {\n\t        modules.config.setProxy(proxy);\n\t        _this.reconnect();\n\t      };\n\t    }\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'getVersion',\n\t    value: function getVersion() {\n\t      return this._config.getVersion();\n\t    }\n\t  }, {\n\t    key: 'networkDownDetected',\n\t    value: function networkDownDetected() {\n\t      this._listenerManager.announceNetworkDown();\n\n\t      if (this._config.restore) {\n\t        this.disconnect();\n\t      } else {\n\t        this.destroy(true);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'networkUpDetected',\n\t    value: function networkUpDetected() {\n\t      this._listenerManager.announceNetworkUp();\n\t      this.reconnect();\n\t    }\n\t  }], [{\n\t    key: 'generateUUID',\n\t    value: function generateUUID() {\n\t      return _uuid2.default.createUUID();\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\t_class.OPERATIONS = _operations2.default;\n\t_class.CATEGORIES = _categories2.default;\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _uuid = __webpack_require__(3);\n\n\tvar _uuid2 = _interopRequireDefault(_uuid);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar _class = function () {\n\t  function _class(_ref) {\n\t    var setup = _ref.setup,\n\t        db = _ref.db;\n\n\t    _classCallCheck(this, _class);\n\n\t    this._db = db;\n\n\t    this.instanceId = 'pn-' + _uuid2.default.createUUID();\n\t    this.secretKey = setup.secretKey || setup.secret_key;\n\t    this.subscribeKey = setup.subscribeKey || setup.subscribe_key;\n\t    this.publishKey = setup.publishKey || setup.publish_key;\n\t    this.sdkName = setup.sdkName;\n\t    this.sdkFamily = setup.sdkFamily;\n\t    this.partnerId = setup.partnerId;\n\t    this.setAuthKey(setup.authKey);\n\t    this.setCipherKey(setup.cipherKey);\n\n\t    this.setFilterExpression(setup.filterExpression);\n\n\t    this.origin = setup.origin || 'pubsub.pndsn.com';\n\t    this.secure = setup.ssl || false;\n\t    this.restore = setup.restore || false;\n\t    this.proxy = setup.proxy;\n\t    this.keepAlive = setup.keepAlive;\n\t    this.keepAliveSettings = setup.keepAliveSettings;\n\t    this.autoNetworkDetection = setup.autoNetworkDetection || false;\n\n\t    this.dedupeOnSubscribe = setup.dedupeOnSubscribe || false;\n\t    this.maximumCacheSize = setup.maximumCacheSize || 100;\n\n\t    this.customEncrypt = setup.customEncrypt;\n\t    this.customDecrypt = setup.customDecrypt;\n\n\t    if (typeof location !== 'undefined' && location.protocol === 'https:') {\n\t      this.secure = true;\n\t    }\n\n\t    this.logVerbosity = setup.logVerbosity || false;\n\t    this.suppressLeaveEvents = setup.suppressLeaveEvents || false;\n\n\t    this.announceFailedHeartbeats = setup.announceFailedHeartbeats || true;\n\t    this.announceSuccessfulHeartbeats = setup.announceSuccessfulHeartbeats || false;\n\n\t    this.useInstanceId = setup.useInstanceId || false;\n\t    this.useRequestId = setup.useRequestId || false;\n\n\t    this.requestMessageCountThreshold = setup.requestMessageCountThreshold;\n\n\t    this.setTransactionTimeout(setup.transactionalRequestTimeout || 15 * 1000);\n\n\t    this.setSubscribeTimeout(setup.subscribeRequestTimeout || 310 * 1000);\n\n\t    this.setSendBeaconConfig(setup.useSendBeacon || true);\n\n\t    this.setPresenceTimeout(setup.presenceTimeout || 300);\n\n\t    if (setup.heartbeatInterval != null) {\n\t      this.setHeartbeatInterval(setup.heartbeatInterval);\n\t    }\n\n\t    this.setUUID(this._decideUUID(setup.uuid));\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'getAuthKey',\n\t    value: function getAuthKey() {\n\t      return this.authKey;\n\t    }\n\t  }, {\n\t    key: 'setAuthKey',\n\t    value: function setAuthKey(val) {\n\t      this.authKey = val;return this;\n\t    }\n\t  }, {\n\t    key: 'setCipherKey',\n\t    value: function setCipherKey(val) {\n\t      this.cipherKey = val;return this;\n\t    }\n\t  }, {\n\t    key: 'getUUID',\n\t    value: function getUUID() {\n\t      return this.UUID;\n\t    }\n\t  }, {\n\t    key: 'setUUID',\n\t    value: function setUUID(val) {\n\t      if (this._db && this._db.set) this._db.set(this.subscribeKey + 'uuid', val);\n\t      this.UUID = val;\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'getFilterExpression',\n\t    value: function getFilterExpression() {\n\t      return this.filterExpression;\n\t    }\n\t  }, {\n\t    key: 'setFilterExpression',\n\t    value: function setFilterExpression(val) {\n\t      this.filterExpression = val;return this;\n\t    }\n\t  }, {\n\t    key: 'getPresenceTimeout',\n\t    value: function getPresenceTimeout() {\n\t      return this._presenceTimeout;\n\t    }\n\t  }, {\n\t    key: 'setPresenceTimeout',\n\t    value: function setPresenceTimeout(val) {\n\t      this._presenceTimeout = val;\n\t      this.setHeartbeatInterval(this._presenceTimeout / 2 - 1);\n\t      return this;\n\t    }\n\t  }, {\n\t    key: 'setProxy',\n\t    value: function setProxy(proxy) {\n\t      this.proxy = proxy;\n\t    }\n\t  }, {\n\t    key: 'getHeartbeatInterval',\n\t    value: function getHeartbeatInterval() {\n\t      return this._heartbeatInterval;\n\t    }\n\t  }, {\n\t    key: 'setHeartbeatInterval',\n\t    value: function setHeartbeatInterval(val) {\n\t      this._heartbeatInterval = val;return this;\n\t    }\n\t  }, {\n\t    key: 'getSubscribeTimeout',\n\t    value: function getSubscribeTimeout() {\n\t      return this._subscribeRequestTimeout;\n\t    }\n\t  }, {\n\t    key: 'setSubscribeTimeout',\n\t    value: function setSubscribeTimeout(val) {\n\t      this._subscribeRequestTimeout = val;return this;\n\t    }\n\t  }, {\n\t    key: 'getTransactionTimeout',\n\t    value: function getTransactionTimeout() {\n\t      return this._transactionalRequestTimeout;\n\t    }\n\t  }, {\n\t    key: 'setTransactionTimeout',\n\t    value: function setTransactionTimeout(val) {\n\t      this._transactionalRequestTimeout = val;return this;\n\t    }\n\t  }, {\n\t    key: 'isSendBeaconEnabled',\n\t    value: function isSendBeaconEnabled() {\n\t      return this._useSendBeacon;\n\t    }\n\t  }, {\n\t    key: 'setSendBeaconConfig',\n\t    value: function setSendBeaconConfig(val) {\n\t      this._useSendBeacon = val;return this;\n\t    }\n\t  }, {\n\t    key: 'getVersion',\n\t    value: function getVersion() {\n\t      return '4.20.1';\n\t    }\n\t  }, {\n\t    key: '_decideUUID',\n\t    value: function _decideUUID(providedUUID) {\n\t      if (providedUUID) {\n\t        return providedUUID;\n\t      }\n\n\t      if (this._db && this._db.get && this._db.get(this.subscribeKey + 'uuid')) {\n\t        return this._db.get(this.subscribeKey + 'uuid');\n\t      }\n\n\t      return 'pn-' + _uuid2.default.createUUID();\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _lilUuid = __webpack_require__(4);\n\n\tvar _lilUuid2 = _interopRequireDefault(_lilUuid);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\texports.default = {\n\t  createUUID: function createUUID() {\n\t    if (_lilUuid2.default.uuid) {\n\t      return _lilUuid2.default.uuid();\n\t    } else {\n\t      return (0, _lilUuid2.default)();\n\t    }\n\t  }\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! lil-uuid - v0.1 - MIT License - https://github.com/lil-js/uuid */\n\t(function (root, factory) {\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\t  } else if (typeof exports === 'object') {\n\t    factory(exports)\n\t    if (typeof module === 'object' && module !== null) {\n\t      module.exports = exports.uuid\n\t    }\n\t  } else {\n\t    factory((root.lil = root.lil || {}))\n\t  }\n\t}(this, function (exports) {\n\t  var VERSION = '0.1.0'\n\t  var uuidRegex = {\n\t    '3': /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,\n\t    '4': /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n\t    '5': /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,\n\t    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i\n\t  }\n\n\t  function uuid() {\n\t    var uuid = '', i, random\n\t    for (i = 0; i < 32; i++) {\n\t      random = Math.random() * 16 | 0;\n\t      if (i === 8 || i === 12 || i === 16 || i === 20) uuid += '-'\n\t      uuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16)\n\t    }\n\t    return uuid\n\t  }\n\n\t  function isUUID(str, version) {\n\t    var pattern = uuidRegex[version || 'all']\n\t    return pattern && pattern.test(str) || false\n\t  }\n\n\t  uuid.isUUID = isUUID\n\t  uuid.VERSION = VERSION\n\n\t  exports.uuid = uuid\n\t  exports.isUUID = isUUID\n\t}));\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tmodule.exports = {};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _config2 = _interopRequireDefault(_config);\n\n\tvar _hmacSha = __webpack_require__(7);\n\n\tvar _hmacSha2 = _interopRequireDefault(_hmacSha);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar _class = function () {\n\t  function _class(_ref) {\n\t    var config = _ref.config;\n\n\t    _classCallCheck(this, _class);\n\n\t    this._config = config;\n\n\t    this._iv = '0123456789012345';\n\n\t    this._allowedKeyEncodings = ['hex', 'utf8', 'base64', 'binary'];\n\t    this._allowedKeyLengths = [128, 256];\n\t    this._allowedModes = ['ecb', 'cbc'];\n\n\t    this._defaultOptions = {\n\t      encryptKey: true,\n\t      keyEncoding: 'utf8',\n\t      keyLength: 256,\n\t      mode: 'cbc'\n\t    };\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'HMACSHA256',\n\t    value: function HMACSHA256(data) {\n\t      var hash = _hmacSha2.default.HmacSHA256(data, this._config.secretKey);\n\t      return hash.toString(_hmacSha2.default.enc.Base64);\n\t    }\n\t  }, {\n\t    key: 'SHA256',\n\t    value: function SHA256(s) {\n\t      return _hmacSha2.default.SHA256(s).toString(_hmacSha2.default.enc.Hex);\n\t    }\n\t  }, {\n\t    key: '_parseOptions',\n\t    value: function _parseOptions(incomingOptions) {\n\t      var options = incomingOptions || {};\n\t      if (!options.hasOwnProperty('encryptKey')) options.encryptKey = this._defaultOptions.encryptKey;\n\t      if (!options.hasOwnProperty('keyEncoding')) options.keyEncoding = this._defaultOptions.keyEncoding;\n\t      if (!options.hasOwnProperty('keyLength')) options.keyLength = this._defaultOptions.keyLength;\n\t      if (!options.hasOwnProperty('mode')) options.mode = this._defaultOptions.mode;\n\n\t      if (this._allowedKeyEncodings.indexOf(options.keyEncoding.toLowerCase()) === -1) {\n\t        options.keyEncoding = this._defaultOptions.keyEncoding;\n\t      }\n\n\t      if (this._allowedKeyLengths.indexOf(parseInt(options.keyLength, 10)) === -1) {\n\t        options.keyLength = this._defaultOptions.keyLength;\n\t      }\n\n\t      if (this._allowedModes.indexOf(options.mode.toLowerCase()) === -1) {\n\t        options.mode = this._defaultOptions.mode;\n\t      }\n\n\t      return options;\n\t    }\n\t  }, {\n\t    key: '_decodeKey',\n\t    value: function _decodeKey(key, options) {\n\t      if (options.keyEncoding === 'base64') {\n\t        return _hmacSha2.default.enc.Base64.parse(key);\n\t      } else if (options.keyEncoding === 'hex') {\n\t        return _hmacSha2.default.enc.Hex.parse(key);\n\t      } else {\n\t        return key;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getPaddedKey',\n\t    value: function _getPaddedKey(key, options) {\n\t      key = this._decodeKey(key, options);\n\t      if (options.encryptKey) {\n\t        return _hmacSha2.default.enc.Utf8.parse(this.SHA256(key).slice(0, 32));\n\t      } else {\n\t        return key;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getMode',\n\t    value: function _getMode(options) {\n\t      if (options.mode === 'ecb') {\n\t        return _hmacSha2.default.mode.ECB;\n\t      } else {\n\t        return _hmacSha2.default.mode.CBC;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getIV',\n\t    value: function _getIV(options) {\n\t      return options.mode === 'cbc' ? _hmacSha2.default.enc.Utf8.parse(this._iv) : null;\n\t    }\n\t  }, {\n\t    key: 'encrypt',\n\t    value: function encrypt(data, customCipherKey, options) {\n\t      if (this._config.customEncrypt) {\n\t        return this._config.customEncrypt(data);\n\t      } else {\n\t        return this.pnEncrypt(data, customCipherKey, options);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'decrypt',\n\t    value: function decrypt(data, customCipherKey, options) {\n\t      if (this._config.customDecrypt) {\n\t        return this._config.customDecrypt(data);\n\t      } else {\n\t        return this.pnDecrypt(data, customCipherKey, options);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'pnEncrypt',\n\t    value: function pnEncrypt(data, customCipherKey, options) {\n\t      if (!customCipherKey && !this._config.cipherKey) return data;\n\t      options = this._parseOptions(options);\n\t      var iv = this._getIV(options);\n\t      var mode = this._getMode(options);\n\t      var cipherKey = this._getPaddedKey(customCipherKey || this._config.cipherKey, options);\n\t      var encryptedHexArray = _hmacSha2.default.AES.encrypt(data, cipherKey, { iv: iv, mode: mode }).ciphertext;\n\t      var base64Encrypted = encryptedHexArray.toString(_hmacSha2.default.enc.Base64);\n\t      return base64Encrypted || data;\n\t    }\n\t  }, {\n\t    key: 'pnDecrypt',\n\t    value: function pnDecrypt(data, customCipherKey, options) {\n\t      if (!customCipherKey && !this._config.cipherKey) return data;\n\t      options = this._parseOptions(options);\n\t      var iv = this._getIV(options);\n\t      var mode = this._getMode(options);\n\t      var cipherKey = this._getPaddedKey(customCipherKey || this._config.cipherKey, options);\n\t      try {\n\t        var ciphertext = _hmacSha2.default.enc.Base64.parse(data);\n\t        var plainJSON = _hmacSha2.default.AES.decrypt({ ciphertext: ciphertext }, cipherKey, { iv: iv, mode: mode }).toString(_hmacSha2.default.enc.Utf8);\n\t        var plaintext = JSON.parse(plainJSON);\n\t        return plaintext;\n\t      } catch (e) {\n\t        return null;\n\t      }\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\n\tvar CryptoJS = CryptoJS || function (h, s) {\n\t  var f = {},\n\t      g = f.lib = {},\n\t      q = function q() {},\n\t      m = g.Base = { extend: function extend(a) {\n\t      q.prototype = this;var c = new q();a && c.mixIn(a);c.hasOwnProperty(\"init\") || (c.init = function () {\n\t        c.$super.init.apply(this, arguments);\n\t      });c.init.prototype = c;c.$super = this;return c;\n\t    }, create: function create() {\n\t      var a = this.extend();a.init.apply(a, arguments);return a;\n\t    }, init: function init() {}, mixIn: function mixIn(a) {\n\t      for (var c in a) {\n\t        a.hasOwnProperty(c) && (this[c] = a[c]);\n\t      }a.hasOwnProperty(\"toString\") && (this.toString = a.toString);\n\t    }, clone: function clone() {\n\t      return this.init.prototype.extend(this);\n\t    } },\n\t      r = g.WordArray = m.extend({ init: function init(a, c) {\n\t      a = this.words = a || [];this.sigBytes = c != s ? c : 4 * a.length;\n\t    }, toString: function toString(a) {\n\t      return (a || k).stringify(this);\n\t    }, concat: function concat(a) {\n\t      var c = this.words,\n\t          d = a.words,\n\t          b = this.sigBytes;a = a.sigBytes;this.clamp();if (b % 4) for (var e = 0; e < a; e++) {\n\t        c[b + e >>> 2] |= (d[e >>> 2] >>> 24 - 8 * (e % 4) & 255) << 24 - 8 * ((b + e) % 4);\n\t      } else if (65535 < d.length) for (e = 0; e < a; e += 4) {\n\t        c[b + e >>> 2] = d[e >>> 2];\n\t      } else c.push.apply(c, d);this.sigBytes += a;return this;\n\t    }, clamp: function clamp() {\n\t      var a = this.words,\n\t          c = this.sigBytes;a[c >>> 2] &= 4294967295 << 32 - 8 * (c % 4);a.length = h.ceil(c / 4);\n\t    }, clone: function clone() {\n\t      var a = m.clone.call(this);a.words = this.words.slice(0);return a;\n\t    }, random: function random(a) {\n\t      for (var c = [], d = 0; d < a; d += 4) {\n\t        c.push(4294967296 * h.random() | 0);\n\t      }return new r.init(c, a);\n\t    } }),\n\t      l = f.enc = {},\n\t      k = l.Hex = { stringify: function stringify(a) {\n\t      var c = a.words;a = a.sigBytes;for (var d = [], b = 0; b < a; b++) {\n\t        var e = c[b >>> 2] >>> 24 - 8 * (b % 4) & 255;d.push((e >>> 4).toString(16));d.push((e & 15).toString(16));\n\t      }return d.join(\"\");\n\t    }, parse: function parse(a) {\n\t      for (var c = a.length, d = [], b = 0; b < c; b += 2) {\n\t        d[b >>> 3] |= parseInt(a.substr(b, 2), 16) << 24 - 4 * (b % 8);\n\t      }return new r.init(d, c / 2);\n\t    } },\n\t      n = l.Latin1 = { stringify: function stringify(a) {\n\t      var c = a.words;a = a.sigBytes;for (var d = [], b = 0; b < a; b++) {\n\t        d.push(String.fromCharCode(c[b >>> 2] >>> 24 - 8 * (b % 4) & 255));\n\t      }return d.join(\"\");\n\t    }, parse: function parse(a) {\n\t      for (var c = a.length, d = [], b = 0; b < c; b++) {\n\t        d[b >>> 2] |= (a.charCodeAt(b) & 255) << 24 - 8 * (b % 4);\n\t      }return new r.init(d, c);\n\t    } },\n\t      j = l.Utf8 = { stringify: function stringify(a) {\n\t      try {\n\t        return decodeURIComponent(escape(n.stringify(a)));\n\t      } catch (c) {\n\t        throw Error(\"Malformed UTF-8 data\");\n\t      }\n\t    }, parse: function parse(a) {\n\t      return n.parse(unescape(encodeURIComponent(a)));\n\t    } },\n\t      u = g.BufferedBlockAlgorithm = m.extend({ reset: function reset() {\n\t      this._data = new r.init();this._nDataBytes = 0;\n\t    }, _append: function _append(a) {\n\t      \"string\" == typeof a && (a = j.parse(a));this._data.concat(a);this._nDataBytes += a.sigBytes;\n\t    }, _process: function _process(a) {\n\t      var c = this._data,\n\t          d = c.words,\n\t          b = c.sigBytes,\n\t          e = this.blockSize,\n\t          f = b / (4 * e),\n\t          f = a ? h.ceil(f) : h.max((f | 0) - this._minBufferSize, 0);a = f * e;b = h.min(4 * a, b);if (a) {\n\t        for (var g = 0; g < a; g += e) {\n\t          this._doProcessBlock(d, g);\n\t        }g = d.splice(0, a);c.sigBytes -= b;\n\t      }return new r.init(g, b);\n\t    }, clone: function clone() {\n\t      var a = m.clone.call(this);\n\t      a._data = this._data.clone();return a;\n\t    }, _minBufferSize: 0 });g.Hasher = u.extend({ cfg: m.extend(), init: function init(a) {\n\t      this.cfg = this.cfg.extend(a);this.reset();\n\t    }, reset: function reset() {\n\t      u.reset.call(this);this._doReset();\n\t    }, update: function update(a) {\n\t      this._append(a);this._process();return this;\n\t    }, finalize: function finalize(a) {\n\t      a && this._append(a);return this._doFinalize();\n\t    }, blockSize: 16, _createHelper: function _createHelper(a) {\n\t      return function (c, d) {\n\t        return new a.init(d).finalize(c);\n\t      };\n\t    }, _createHmacHelper: function _createHmacHelper(a) {\n\t      return function (c, d) {\n\t        return new t.HMAC.init(a, d).finalize(c);\n\t      };\n\t    } });var t = f.algo = {};return f;\n\t}(Math);\n\n\t(function (h) {\n\t  for (var s = CryptoJS, f = s.lib, g = f.WordArray, q = f.Hasher, f = s.algo, m = [], r = [], l = function l(a) {\n\t    return 4294967296 * (a - (a | 0)) | 0;\n\t  }, k = 2, n = 0; 64 > n;) {\n\t    var j;a: {\n\t      j = k;for (var u = h.sqrt(j), t = 2; t <= u; t++) {\n\t        if (!(j % t)) {\n\t          j = !1;break a;\n\t        }\n\t      }j = !0;\n\t    }j && (8 > n && (m[n] = l(h.pow(k, 0.5))), r[n] = l(h.pow(k, 1 / 3)), n++);k++;\n\t  }var a = [],\n\t      f = f.SHA256 = q.extend({ _doReset: function _doReset() {\n\t      this._hash = new g.init(m.slice(0));\n\t    }, _doProcessBlock: function _doProcessBlock(c, d) {\n\t      for (var b = this._hash.words, e = b[0], f = b[1], g = b[2], j = b[3], h = b[4], m = b[5], n = b[6], q = b[7], p = 0; 64 > p; p++) {\n\t        if (16 > p) a[p] = c[d + p] | 0;else {\n\t          var k = a[p - 15],\n\t              l = a[p - 2];a[p] = ((k << 25 | k >>> 7) ^ (k << 14 | k >>> 18) ^ k >>> 3) + a[p - 7] + ((l << 15 | l >>> 17) ^ (l << 13 | l >>> 19) ^ l >>> 10) + a[p - 16];\n\t        }k = q + ((h << 26 | h >>> 6) ^ (h << 21 | h >>> 11) ^ (h << 7 | h >>> 25)) + (h & m ^ ~h & n) + r[p] + a[p];l = ((e << 30 | e >>> 2) ^ (e << 19 | e >>> 13) ^ (e << 10 | e >>> 22)) + (e & f ^ e & g ^ f & g);q = n;n = m;m = h;h = j + k | 0;j = g;g = f;f = e;e = k + l | 0;\n\t      }b[0] = b[0] + e | 0;b[1] = b[1] + f | 0;b[2] = b[2] + g | 0;b[3] = b[3] + j | 0;b[4] = b[4] + h | 0;b[5] = b[5] + m | 0;b[6] = b[6] + n | 0;b[7] = b[7] + q | 0;\n\t    }, _doFinalize: function _doFinalize() {\n\t      var a = this._data,\n\t          d = a.words,\n\t          b = 8 * this._nDataBytes,\n\t          e = 8 * a.sigBytes;\n\t      d[e >>> 5] |= 128 << 24 - e % 32;d[(e + 64 >>> 9 << 4) + 14] = h.floor(b / 4294967296);d[(e + 64 >>> 9 << 4) + 15] = b;a.sigBytes = 4 * d.length;this._process();return this._hash;\n\t    }, clone: function clone() {\n\t      var a = q.clone.call(this);a._hash = this._hash.clone();return a;\n\t    } });s.SHA256 = q._createHelper(f);s.HmacSHA256 = q._createHmacHelper(f);\n\t})(Math);\n\n\t(function () {\n\t  var h = CryptoJS,\n\t      s = h.enc.Utf8;h.algo.HMAC = h.lib.Base.extend({ init: function init(f, g) {\n\t      f = this._hasher = new f.init();\"string\" == typeof g && (g = s.parse(g));var h = f.blockSize,\n\t          m = 4 * h;g.sigBytes > m && (g = f.finalize(g));g.clamp();for (var r = this._oKey = g.clone(), l = this._iKey = g.clone(), k = r.words, n = l.words, j = 0; j < h; j++) {\n\t        k[j] ^= 1549556828, n[j] ^= 909522486;\n\t      }r.sigBytes = l.sigBytes = m;this.reset();\n\t    }, reset: function reset() {\n\t      var f = this._hasher;f.reset();f.update(this._iKey);\n\t    }, update: function update(f) {\n\t      this._hasher.update(f);return this;\n\t    }, finalize: function finalize(f) {\n\t      var g = this._hasher;f = g.finalize(f);g.reset();return g.finalize(this._oKey.clone().concat(f));\n\t    } });\n\t})();\n\n\t(function () {\n\t  var u = CryptoJS,\n\t      p = u.lib.WordArray;u.enc.Base64 = { stringify: function stringify(d) {\n\t      var l = d.words,\n\t          p = d.sigBytes,\n\t          t = this._map;d.clamp();d = [];for (var r = 0; r < p; r += 3) {\n\t        for (var w = (l[r >>> 2] >>> 24 - 8 * (r % 4) & 255) << 16 | (l[r + 1 >>> 2] >>> 24 - 8 * ((r + 1) % 4) & 255) << 8 | l[r + 2 >>> 2] >>> 24 - 8 * ((r + 2) % 4) & 255, v = 0; 4 > v && r + 0.75 * v < p; v++) {\n\t          d.push(t.charAt(w >>> 6 * (3 - v) & 63));\n\t        }\n\t      }if (l = t.charAt(64)) for (; d.length % 4;) {\n\t        d.push(l);\n\t      }return d.join(\"\");\n\t    }, parse: function parse(d) {\n\t      var l = d.length,\n\t          s = this._map,\n\t          t = s.charAt(64);t && (t = d.indexOf(t), -1 != t && (l = t));for (var t = [], r = 0, w = 0; w < l; w++) {\n\t        if (w % 4) {\n\t          var v = s.indexOf(d.charAt(w - 1)) << 2 * (w % 4),\n\t              b = s.indexOf(d.charAt(w)) >>> 6 - 2 * (w % 4);t[r >>> 2] |= (v | b) << 24 - 8 * (r % 4);r++;\n\t        }\n\t      }return p.create(t, r);\n\t    }, _map: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\" };\n\t})();\n\n\t(function (u) {\n\t  function p(b, n, a, c, e, j, k) {\n\t    b = b + (n & a | ~n & c) + e + k;return (b << j | b >>> 32 - j) + n;\n\t  }function d(b, n, a, c, e, j, k) {\n\t    b = b + (n & c | a & ~c) + e + k;return (b << j | b >>> 32 - j) + n;\n\t  }function l(b, n, a, c, e, j, k) {\n\t    b = b + (n ^ a ^ c) + e + k;return (b << j | b >>> 32 - j) + n;\n\t  }function s(b, n, a, c, e, j, k) {\n\t    b = b + (a ^ (n | ~c)) + e + k;return (b << j | b >>> 32 - j) + n;\n\t  }for (var t = CryptoJS, r = t.lib, w = r.WordArray, v = r.Hasher, r = t.algo, b = [], x = 0; 64 > x; x++) {\n\t    b[x] = 4294967296 * u.abs(u.sin(x + 1)) | 0;\n\t  }r = r.MD5 = v.extend({ _doReset: function _doReset() {\n\t      this._hash = new w.init([1732584193, 4023233417, 2562383102, 271733878]);\n\t    },\n\t    _doProcessBlock: function _doProcessBlock(q, n) {\n\t      for (var a = 0; 16 > a; a++) {\n\t        var c = n + a,\n\t            e = q[c];q[c] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;\n\t      }var a = this._hash.words,\n\t          c = q[n + 0],\n\t          e = q[n + 1],\n\t          j = q[n + 2],\n\t          k = q[n + 3],\n\t          z = q[n + 4],\n\t          r = q[n + 5],\n\t          t = q[n + 6],\n\t          w = q[n + 7],\n\t          v = q[n + 8],\n\t          A = q[n + 9],\n\t          B = q[n + 10],\n\t          C = q[n + 11],\n\t          u = q[n + 12],\n\t          D = q[n + 13],\n\t          E = q[n + 14],\n\t          x = q[n + 15],\n\t          f = a[0],\n\t          m = a[1],\n\t          g = a[2],\n\t          h = a[3],\n\t          f = p(f, m, g, h, c, 7, b[0]),\n\t          h = p(h, f, m, g, e, 12, b[1]),\n\t          g = p(g, h, f, m, j, 17, b[2]),\n\t          m = p(m, g, h, f, k, 22, b[3]),\n\t          f = p(f, m, g, h, z, 7, b[4]),\n\t          h = p(h, f, m, g, r, 12, b[5]),\n\t          g = p(g, h, f, m, t, 17, b[6]),\n\t          m = p(m, g, h, f, w, 22, b[7]),\n\t          f = p(f, m, g, h, v, 7, b[8]),\n\t          h = p(h, f, m, g, A, 12, b[9]),\n\t          g = p(g, h, f, m, B, 17, b[10]),\n\t          m = p(m, g, h, f, C, 22, b[11]),\n\t          f = p(f, m, g, h, u, 7, b[12]),\n\t          h = p(h, f, m, g, D, 12, b[13]),\n\t          g = p(g, h, f, m, E, 17, b[14]),\n\t          m = p(m, g, h, f, x, 22, b[15]),\n\t          f = d(f, m, g, h, e, 5, b[16]),\n\t          h = d(h, f, m, g, t, 9, b[17]),\n\t          g = d(g, h, f, m, C, 14, b[18]),\n\t          m = d(m, g, h, f, c, 20, b[19]),\n\t          f = d(f, m, g, h, r, 5, b[20]),\n\t          h = d(h, f, m, g, B, 9, b[21]),\n\t          g = d(g, h, f, m, x, 14, b[22]),\n\t          m = d(m, g, h, f, z, 20, b[23]),\n\t          f = d(f, m, g, h, A, 5, b[24]),\n\t          h = d(h, f, m, g, E, 9, b[25]),\n\t          g = d(g, h, f, m, k, 14, b[26]),\n\t          m = d(m, g, h, f, v, 20, b[27]),\n\t          f = d(f, m, g, h, D, 5, b[28]),\n\t          h = d(h, f, m, g, j, 9, b[29]),\n\t          g = d(g, h, f, m, w, 14, b[30]),\n\t          m = d(m, g, h, f, u, 20, b[31]),\n\t          f = l(f, m, g, h, r, 4, b[32]),\n\t          h = l(h, f, m, g, v, 11, b[33]),\n\t          g = l(g, h, f, m, C, 16, b[34]),\n\t          m = l(m, g, h, f, E, 23, b[35]),\n\t          f = l(f, m, g, h, e, 4, b[36]),\n\t          h = l(h, f, m, g, z, 11, b[37]),\n\t          g = l(g, h, f, m, w, 16, b[38]),\n\t          m = l(m, g, h, f, B, 23, b[39]),\n\t          f = l(f, m, g, h, D, 4, b[40]),\n\t          h = l(h, f, m, g, c, 11, b[41]),\n\t          g = l(g, h, f, m, k, 16, b[42]),\n\t          m = l(m, g, h, f, t, 23, b[43]),\n\t          f = l(f, m, g, h, A, 4, b[44]),\n\t          h = l(h, f, m, g, u, 11, b[45]),\n\t          g = l(g, h, f, m, x, 16, b[46]),\n\t          m = l(m, g, h, f, j, 23, b[47]),\n\t          f = s(f, m, g, h, c, 6, b[48]),\n\t          h = s(h, f, m, g, w, 10, b[49]),\n\t          g = s(g, h, f, m, E, 15, b[50]),\n\t          m = s(m, g, h, f, r, 21, b[51]),\n\t          f = s(f, m, g, h, u, 6, b[52]),\n\t          h = s(h, f, m, g, k, 10, b[53]),\n\t          g = s(g, h, f, m, B, 15, b[54]),\n\t          m = s(m, g, h, f, e, 21, b[55]),\n\t          f = s(f, m, g, h, v, 6, b[56]),\n\t          h = s(h, f, m, g, x, 10, b[57]),\n\t          g = s(g, h, f, m, t, 15, b[58]),\n\t          m = s(m, g, h, f, D, 21, b[59]),\n\t          f = s(f, m, g, h, z, 6, b[60]),\n\t          h = s(h, f, m, g, C, 10, b[61]),\n\t          g = s(g, h, f, m, j, 15, b[62]),\n\t          m = s(m, g, h, f, A, 21, b[63]);a[0] = a[0] + f | 0;a[1] = a[1] + m | 0;a[2] = a[2] + g | 0;a[3] = a[3] + h | 0;\n\t    }, _doFinalize: function _doFinalize() {\n\t      var b = this._data,\n\t          n = b.words,\n\t          a = 8 * this._nDataBytes,\n\t          c = 8 * b.sigBytes;n[c >>> 5] |= 128 << 24 - c % 32;var e = u.floor(a / 4294967296);n[(c + 64 >>> 9 << 4) + 15] = (e << 8 | e >>> 24) & 16711935 | (e << 24 | e >>> 8) & 4278255360;n[(c + 64 >>> 9 << 4) + 14] = (a << 8 | a >>> 24) & 16711935 | (a << 24 | a >>> 8) & 4278255360;b.sigBytes = 4 * (n.length + 1);this._process();b = this._hash;n = b.words;for (a = 0; 4 > a; a++) {\n\t        c = n[a], n[a] = (c << 8 | c >>> 24) & 16711935 | (c << 24 | c >>> 8) & 4278255360;\n\t      }return b;\n\t    }, clone: function clone() {\n\t      var b = v.clone.call(this);b._hash = this._hash.clone();return b;\n\t    } });t.MD5 = v._createHelper(r);t.HmacMD5 = v._createHmacHelper(r);\n\t})(Math);\n\t(function () {\n\t  var u = CryptoJS,\n\t      p = u.lib,\n\t      d = p.Base,\n\t      l = p.WordArray,\n\t      p = u.algo,\n\t      s = p.EvpKDF = d.extend({ cfg: d.extend({ keySize: 4, hasher: p.MD5, iterations: 1 }), init: function init(d) {\n\t      this.cfg = this.cfg.extend(d);\n\t    }, compute: function compute(d, r) {\n\t      for (var p = this.cfg, s = p.hasher.create(), b = l.create(), u = b.words, q = p.keySize, p = p.iterations; u.length < q;) {\n\t        n && s.update(n);var n = s.update(d).finalize(r);s.reset();for (var a = 1; a < p; a++) {\n\t          n = s.finalize(n), s.reset();\n\t        }b.concat(n);\n\t      }b.sigBytes = 4 * q;return b;\n\t    } });u.EvpKDF = function (d, l, p) {\n\t    return s.create(p).compute(d, l);\n\t  };\n\t})();\n\n\tCryptoJS.lib.Cipher || function (u) {\n\t  var p = CryptoJS,\n\t      d = p.lib,\n\t      l = d.Base,\n\t      s = d.WordArray,\n\t      t = d.BufferedBlockAlgorithm,\n\t      r = p.enc.Base64,\n\t      w = p.algo.EvpKDF,\n\t      v = d.Cipher = t.extend({ cfg: l.extend(), createEncryptor: function createEncryptor(e, a) {\n\t      return this.create(this._ENC_XFORM_MODE, e, a);\n\t    }, createDecryptor: function createDecryptor(e, a) {\n\t      return this.create(this._DEC_XFORM_MODE, e, a);\n\t    }, init: function init(e, a, b) {\n\t      this.cfg = this.cfg.extend(b);this._xformMode = e;this._key = a;this.reset();\n\t    }, reset: function reset() {\n\t      t.reset.call(this);this._doReset();\n\t    }, process: function process(e) {\n\t      this._append(e);return this._process();\n\t    },\n\t    finalize: function finalize(e) {\n\t      e && this._append(e);return this._doFinalize();\n\t    }, keySize: 4, ivSize: 4, _ENC_XFORM_MODE: 1, _DEC_XFORM_MODE: 2, _createHelper: function _createHelper(e) {\n\t      return { encrypt: function encrypt(b, k, d) {\n\t          return (\"string\" == typeof k ? c : a).encrypt(e, b, k, d);\n\t        }, decrypt: function decrypt(b, k, d) {\n\t          return (\"string\" == typeof k ? c : a).decrypt(e, b, k, d);\n\t        } };\n\t    } });d.StreamCipher = v.extend({ _doFinalize: function _doFinalize() {\n\t      return this._process(!0);\n\t    }, blockSize: 1 });var b = p.mode = {},\n\t      x = function x(e, a, b) {\n\t    var c = this._iv;c ? this._iv = u : c = this._prevBlock;for (var d = 0; d < b; d++) {\n\t      e[a + d] ^= c[d];\n\t    }\n\t  },\n\t      q = (d.BlockCipherMode = l.extend({ createEncryptor: function createEncryptor(e, a) {\n\t      return this.Encryptor.create(e, a);\n\t    }, createDecryptor: function createDecryptor(e, a) {\n\t      return this.Decryptor.create(e, a);\n\t    }, init: function init(e, a) {\n\t      this._cipher = e;this._iv = a;\n\t    } })).extend();q.Encryptor = q.extend({ processBlock: function processBlock(e, a) {\n\t      var b = this._cipher,\n\t          c = b.blockSize;x.call(this, e, a, c);b.encryptBlock(e, a);this._prevBlock = e.slice(a, a + c);\n\t    } });q.Decryptor = q.extend({ processBlock: function processBlock(e, a) {\n\t      var b = this._cipher,\n\t          c = b.blockSize,\n\t          d = e.slice(a, a + c);b.decryptBlock(e, a);x.call(this, e, a, c);this._prevBlock = d;\n\t    } });b = b.CBC = q;q = (p.pad = {}).Pkcs7 = { pad: function pad(a, b) {\n\t      for (var c = 4 * b, c = c - a.sigBytes % c, d = c << 24 | c << 16 | c << 8 | c, l = [], n = 0; n < c; n += 4) {\n\t        l.push(d);\n\t      }c = s.create(l, c);a.concat(c);\n\t    }, unpad: function unpad(a) {\n\t      a.sigBytes -= a.words[a.sigBytes - 1 >>> 2] & 255;\n\t    } };d.BlockCipher = v.extend({ cfg: v.cfg.extend({ mode: b, padding: q }), reset: function reset() {\n\t      v.reset.call(this);var a = this.cfg,\n\t          b = a.iv,\n\t          a = a.mode;if (this._xformMode == this._ENC_XFORM_MODE) var c = a.createEncryptor;else c = a.createDecryptor, this._minBufferSize = 1;this._mode = c.call(a, this, b && b.words);\n\t    }, _doProcessBlock: function _doProcessBlock(a, b) {\n\t      this._mode.processBlock(a, b);\n\t    }, _doFinalize: function _doFinalize() {\n\t      var a = this.cfg.padding;if (this._xformMode == this._ENC_XFORM_MODE) {\n\t        a.pad(this._data, this.blockSize);var b = this._process(!0);\n\t      } else b = this._process(!0), a.unpad(b);return b;\n\t    }, blockSize: 4 });var n = d.CipherParams = l.extend({ init: function init(a) {\n\t      this.mixIn(a);\n\t    }, toString: function toString(a) {\n\t      return (a || this.formatter).stringify(this);\n\t    } }),\n\t      b = (p.format = {}).OpenSSL = { stringify: function stringify(a) {\n\t      var b = a.ciphertext;a = a.salt;return (a ? s.create([1398893684, 1701076831]).concat(a).concat(b) : b).toString(r);\n\t    }, parse: function parse(a) {\n\t      a = r.parse(a);var b = a.words;if (1398893684 == b[0] && 1701076831 == b[1]) {\n\t        var c = s.create(b.slice(2, 4));b.splice(0, 4);a.sigBytes -= 16;\n\t      }return n.create({ ciphertext: a, salt: c });\n\t    } },\n\t      a = d.SerializableCipher = l.extend({ cfg: l.extend({ format: b }), encrypt: function encrypt(a, b, c, d) {\n\t      d = this.cfg.extend(d);var l = a.createEncryptor(c, d);b = l.finalize(b);l = l.cfg;return n.create({ ciphertext: b, key: c, iv: l.iv, algorithm: a, mode: l.mode, padding: l.padding, blockSize: a.blockSize, formatter: d.format });\n\t    },\n\t    decrypt: function decrypt(a, b, c, d) {\n\t      d = this.cfg.extend(d);b = this._parse(b, d.format);return a.createDecryptor(c, d).finalize(b.ciphertext);\n\t    }, _parse: function _parse(a, b) {\n\t      return \"string\" == typeof a ? b.parse(a, this) : a;\n\t    } }),\n\t      p = (p.kdf = {}).OpenSSL = { execute: function execute(a, b, c, d) {\n\t      d || (d = s.random(8));a = w.create({ keySize: b + c }).compute(a, d);c = s.create(a.words.slice(b), 4 * c);a.sigBytes = 4 * b;return n.create({ key: a, iv: c, salt: d });\n\t    } },\n\t      c = d.PasswordBasedCipher = a.extend({ cfg: a.cfg.extend({ kdf: p }), encrypt: function encrypt(b, c, d, l) {\n\t      l = this.cfg.extend(l);d = l.kdf.execute(d, b.keySize, b.ivSize);l.iv = d.iv;b = a.encrypt.call(this, b, c, d.key, l);b.mixIn(d);return b;\n\t    }, decrypt: function decrypt(b, c, d, l) {\n\t      l = this.cfg.extend(l);c = this._parse(c, l.format);d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);l.iv = d.iv;return a.decrypt.call(this, b, c, d.key, l);\n\t    } });\n\t}();\n\n\t(function () {\n\t  for (var u = CryptoJS, p = u.lib.BlockCipher, d = u.algo, l = [], s = [], t = [], r = [], w = [], v = [], b = [], x = [], q = [], n = [], a = [], c = 0; 256 > c; c++) {\n\t    a[c] = 128 > c ? c << 1 : c << 1 ^ 283;\n\t  }for (var e = 0, j = 0, c = 0; 256 > c; c++) {\n\t    var k = j ^ j << 1 ^ j << 2 ^ j << 3 ^ j << 4,\n\t        k = k >>> 8 ^ k & 255 ^ 99;l[e] = k;s[k] = e;var z = a[e],\n\t        F = a[z],\n\t        G = a[F],\n\t        y = 257 * a[k] ^ 16843008 * k;t[e] = y << 24 | y >>> 8;r[e] = y << 16 | y >>> 16;w[e] = y << 8 | y >>> 24;v[e] = y;y = 16843009 * G ^ 65537 * F ^ 257 * z ^ 16843008 * e;b[k] = y << 24 | y >>> 8;x[k] = y << 16 | y >>> 16;q[k] = y << 8 | y >>> 24;n[k] = y;e ? (e = z ^ a[a[a[G ^ z]]], j ^= a[a[j]]) : e = j = 1;\n\t  }var H = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],\n\t      d = d.AES = p.extend({ _doReset: function _doReset() {\n\t      for (var a = this._key, c = a.words, d = a.sigBytes / 4, a = 4 * ((this._nRounds = d + 6) + 1), e = this._keySchedule = [], j = 0; j < a; j++) {\n\t        if (j < d) e[j] = c[j];else {\n\t          var k = e[j - 1];j % d ? 6 < d && 4 == j % d && (k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255]) : (k = k << 8 | k >>> 24, k = l[k >>> 24] << 24 | l[k >>> 16 & 255] << 16 | l[k >>> 8 & 255] << 8 | l[k & 255], k ^= H[j / d | 0] << 24);e[j] = e[j - d] ^ k;\n\t        }\n\t      }c = this._invKeySchedule = [];for (d = 0; d < a; d++) {\n\t        j = a - d, k = d % 4 ? e[j] : e[j - 4], c[d] = 4 > d || 4 >= j ? k : b[l[k >>> 24]] ^ x[l[k >>> 16 & 255]] ^ q[l[k >>> 8 & 255]] ^ n[l[k & 255]];\n\t      }\n\t    }, encryptBlock: function encryptBlock(a, b) {\n\t      this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l);\n\t    }, decryptBlock: function decryptBlock(a, c) {\n\t      var d = a[c + 1];a[c + 1] = a[c + 3];a[c + 3] = d;this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);d = a[c + 1];a[c + 1] = a[c + 3];a[c + 3] = d;\n\t    }, _doCryptBlock: function _doCryptBlock(a, b, c, d, e, j, l, f) {\n\t      for (var m = this._nRounds, g = a[b] ^ c[0], h = a[b + 1] ^ c[1], k = a[b + 2] ^ c[2], n = a[b + 3] ^ c[3], p = 4, r = 1; r < m; r++) {\n\t        var q = d[g >>> 24] ^ e[h >>> 16 & 255] ^ j[k >>> 8 & 255] ^ l[n & 255] ^ c[p++],\n\t            s = d[h >>> 24] ^ e[k >>> 16 & 255] ^ j[n >>> 8 & 255] ^ l[g & 255] ^ c[p++],\n\t            t = d[k >>> 24] ^ e[n >>> 16 & 255] ^ j[g >>> 8 & 255] ^ l[h & 255] ^ c[p++],\n\t            n = d[n >>> 24] ^ e[g >>> 16 & 255] ^ j[h >>> 8 & 255] ^ l[k & 255] ^ c[p++],\n\t            g = q,\n\t            h = s,\n\t            k = t;\n\t      }q = (f[g >>> 24] << 24 | f[h >>> 16 & 255] << 16 | f[k >>> 8 & 255] << 8 | f[n & 255]) ^ c[p++];s = (f[h >>> 24] << 24 | f[k >>> 16 & 255] << 16 | f[n >>> 8 & 255] << 8 | f[g & 255]) ^ c[p++];t = (f[k >>> 24] << 24 | f[n >>> 16 & 255] << 16 | f[g >>> 8 & 255] << 8 | f[h & 255]) ^ c[p++];n = (f[n >>> 24] << 24 | f[g >>> 16 & 255] << 16 | f[h >>> 8 & 255] << 8 | f[k & 255]) ^ c[p++];a[b] = q;a[b + 1] = s;a[b + 2] = t;a[b + 3] = n;\n\t    }, keySize: 8 });u.AES = p._createHelper(d);\n\t})();\n\n\tCryptoJS.mode.ECB = function () {\n\t  var ECB = CryptoJS.lib.BlockCipherMode.extend();\n\n\t  ECB.Encryptor = ECB.extend({\n\t    processBlock: function processBlock(words, offset) {\n\t      this._cipher.encryptBlock(words, offset);\n\t    }\n\t  });\n\n\t  ECB.Decryptor = ECB.extend({\n\t    processBlock: function processBlock(words, offset) {\n\t      this._cipher.decryptBlock(words, offset);\n\t    }\n\t  });\n\n\t  return ECB;\n\t}();\n\n\tmodule.exports = CryptoJS;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _cryptography = __webpack_require__(6);\n\n\tvar _cryptography2 = _interopRequireDefault(_cryptography);\n\n\tvar _config2 = __webpack_require__(2);\n\n\tvar _config3 = _interopRequireDefault(_config2);\n\n\tvar _listener_manager = __webpack_require__(9);\n\n\tvar _listener_manager2 = _interopRequireDefault(_listener_manager);\n\n\tvar _reconnection_manager = __webpack_require__(11);\n\n\tvar _reconnection_manager2 = _interopRequireDefault(_reconnection_manager);\n\n\tvar _deduping_manager = __webpack_require__(14);\n\n\tvar _deduping_manager2 = _interopRequireDefault(_deduping_manager);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _categories = __webpack_require__(10);\n\n\tvar _categories2 = _interopRequireDefault(_categories);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar _class = function () {\n\t  function _class(_ref) {\n\t    var subscribeEndpoint = _ref.subscribeEndpoint,\n\t        leaveEndpoint = _ref.leaveEndpoint,\n\t        heartbeatEndpoint = _ref.heartbeatEndpoint,\n\t        setStateEndpoint = _ref.setStateEndpoint,\n\t        timeEndpoint = _ref.timeEndpoint,\n\t        config = _ref.config,\n\t        crypto = _ref.crypto,\n\t        listenerManager = _ref.listenerManager;\n\n\t    _classCallCheck(this, _class);\n\n\t    this._listenerManager = listenerManager;\n\t    this._config = config;\n\n\t    this._leaveEndpoint = leaveEndpoint;\n\t    this._heartbeatEndpoint = heartbeatEndpoint;\n\t    this._setStateEndpoint = setStateEndpoint;\n\t    this._subscribeEndpoint = subscribeEndpoint;\n\n\t    this._crypto = crypto;\n\n\t    this._channels = {};\n\t    this._presenceChannels = {};\n\n\t    this._heartbeatChannels = {};\n\t    this._heartbeatChannelGroups = {};\n\n\t    this._channelGroups = {};\n\t    this._presenceChannelGroups = {};\n\n\t    this._pendingChannelSubscriptions = [];\n\t    this._pendingChannelGroupSubscriptions = [];\n\n\t    this._currentTimetoken = 0;\n\t    this._lastTimetoken = 0;\n\t    this._storedTimetoken = null;\n\n\t    this._subscriptionStatusAnnounced = false;\n\n\t    this._isOnline = true;\n\n\t    this._reconnectionManager = new _reconnection_manager2.default({ timeEndpoint: timeEndpoint });\n\t    this._dedupingManager = new _deduping_manager2.default({ config: config });\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'adaptStateChange',\n\t    value: function adaptStateChange(args, callback) {\n\t      var _this = this;\n\n\t      var state = args.state,\n\t          _args$channels = args.channels,\n\t          channels = _args$channels === undefined ? [] : _args$channels,\n\t          _args$channelGroups = args.channelGroups,\n\t          channelGroups = _args$channelGroups === undefined ? [] : _args$channelGroups;\n\n\n\t      channels.forEach(function (channel) {\n\t        if (channel in _this._channels) _this._channels[channel].state = state;\n\t      });\n\n\t      channelGroups.forEach(function (channelGroup) {\n\t        if (channelGroup in _this._channelGroups) _this._channelGroups[channelGroup].state = state;\n\t      });\n\n\t      return this._setStateEndpoint({ state: state, channels: channels, channelGroups: channelGroups }, callback);\n\t    }\n\t  }, {\n\t    key: 'adaptPresenceChange',\n\t    value: function adaptPresenceChange(args) {\n\t      var _this2 = this;\n\n\t      var connected = args.connected,\n\t          _args$channels2 = args.channels,\n\t          channels = _args$channels2 === undefined ? [] : _args$channels2,\n\t          _args$channelGroups2 = args.channelGroups,\n\t          channelGroups = _args$channelGroups2 === undefined ? [] : _args$channelGroups2;\n\n\n\t      if (connected) {\n\t        channels.forEach(function (channel) {\n\t          _this2._heartbeatChannels[channel] = { state: {} };\n\t        });\n\n\t        channelGroups.forEach(function (channelGroup) {\n\t          _this2._heartbeatChannelGroups[channelGroup] = { state: {} };\n\t        });\n\t      } else {\n\t        channels.forEach(function (channel) {\n\t          if (channel in _this2._heartbeatChannels) {\n\t            delete _this2._heartbeatChannels[channel];\n\t          }\n\t        });\n\n\t        channelGroups.forEach(function (channelGroup) {\n\t          if (channelGroup in _this2._heartbeatChannelGroups) {\n\t            delete _this2._heartbeatChannelGroups[channelGroup];\n\t          }\n\t        });\n\n\t        if (this._config.suppressLeaveEvents === false) {\n\t          this._leaveEndpoint({ channels: channels, channelGroups: channelGroups }, function (status) {\n\t            _this2._listenerManager.announceStatus(status);\n\t          });\n\t        }\n\t      }\n\n\t      this.reconnect();\n\t    }\n\t  }, {\n\t    key: 'adaptSubscribeChange',\n\t    value: function adaptSubscribeChange(args) {\n\t      var _this3 = this;\n\n\t      var timetoken = args.timetoken,\n\t          _args$channels3 = args.channels,\n\t          channels = _args$channels3 === undefined ? [] : _args$channels3,\n\t          _args$channelGroups3 = args.channelGroups,\n\t          channelGroups = _args$channelGroups3 === undefined ? [] : _args$channelGroups3,\n\t          _args$withPresence = args.withPresence,\n\t          withPresence = _args$withPresence === undefined ? false : _args$withPresence;\n\n\n\t      if (!this._config.subscribeKey || this._config.subscribeKey === '') {\n\t        if (console && console.log) console.log('subscribe key missing; aborting subscribe');\n\t        return;\n\t      }\n\n\t      if (timetoken) {\n\t        this._lastTimetoken = this._currentTimetoken;\n\t        this._currentTimetoken = timetoken;\n\t      }\n\n\t      if (this._currentTimetoken !== '0') {\n\t        this._storedTimetoken = this._currentTimetoken;\n\t        this._currentTimetoken = 0;\n\t      }\n\n\t      channels.forEach(function (channel) {\n\t        _this3._channels[channel] = { state: {} };\n\t        if (withPresence) _this3._presenceChannels[channel] = {};\n\n\t        _this3._pendingChannelSubscriptions.push(channel);\n\t      });\n\n\t      channelGroups.forEach(function (channelGroup) {\n\t        _this3._channelGroups[channelGroup] = { state: {} };\n\t        if (withPresence) _this3._presenceChannelGroups[channelGroup] = {};\n\n\t        _this3._pendingChannelGroupSubscriptions.push(channelGroup);\n\t      });\n\n\t      this._subscriptionStatusAnnounced = false;\n\t      this.reconnect();\n\t    }\n\t  }, {\n\t    key: 'adaptUnsubscribeChange',\n\t    value: function adaptUnsubscribeChange(args, isOffline) {\n\t      var _this4 = this;\n\n\t      var _args$channels4 = args.channels,\n\t          channels = _args$channels4 === undefined ? [] : _args$channels4,\n\t          _args$channelGroups4 = args.channelGroups,\n\t          channelGroups = _args$channelGroups4 === undefined ? [] : _args$channelGroups4;\n\n\t      var actualChannels = [];\n\t      var actualChannelGroups = [];\n\n\n\t      channels.forEach(function (channel) {\n\t        if (channel in _this4._channels) {\n\t          delete _this4._channels[channel];\n\t          actualChannels.push(channel);\n\t        }\n\t        if (channel in _this4._presenceChannels) {\n\t          delete _this4._presenceChannels[channel];\n\t          actualChannels.push(channel);\n\t        }\n\t      });\n\n\t      channelGroups.forEach(function (channelGroup) {\n\t        if (channelGroup in _this4._channelGroups) {\n\t          delete _this4._channelGroups[channelGroup];\n\t          actualChannelGroups.push(channelGroup);\n\t        }\n\t        if (channelGroup in _this4._presenceChannelGroups) {\n\t          delete _this4._channelGroups[channelGroup];\n\t          actualChannelGroups.push(channelGroup);\n\t        }\n\t      });\n\n\t      if (actualChannels.length === 0 && actualChannelGroups.length === 0) {\n\t        return;\n\t      }\n\n\t      if (this._config.suppressLeaveEvents === false && !isOffline) {\n\t        this._leaveEndpoint({ channels: actualChannels, channelGroups: actualChannelGroups }, function (status) {\n\t          status.affectedChannels = actualChannels;\n\t          status.affectedChannelGroups = actualChannelGroups;\n\t          status.currentTimetoken = _this4._currentTimetoken;\n\t          status.lastTimetoken = _this4._lastTimetoken;\n\t          _this4._listenerManager.announceStatus(status);\n\t        });\n\t      }\n\n\t      if (Object.keys(this._channels).length === 0 && Object.keys(this._presenceChannels).length === 0 && Object.keys(this._channelGroups).length === 0 && Object.keys(this._presenceChannelGroups).length === 0) {\n\t        this._lastTimetoken = 0;\n\t        this._currentTimetoken = 0;\n\t        this._storedTimetoken = null;\n\t        this._region = null;\n\t        this._reconnectionManager.stopPolling();\n\t      }\n\n\t      this.reconnect();\n\t    }\n\t  }, {\n\t    key: 'unsubscribeAll',\n\t    value: function unsubscribeAll(isOffline) {\n\t      this.adaptUnsubscribeChange({ channels: this.getSubscribedChannels(), channelGroups: this.getSubscribedChannelGroups() }, isOffline);\n\t    }\n\t  }, {\n\t    key: 'getHeartbeatChannels',\n\t    value: function getHeartbeatChannels() {\n\t      return Object.keys(this._heartbeatChannels);\n\t    }\n\t  }, {\n\t    key: 'getHeartbeatChannelGroups',\n\t    value: function getHeartbeatChannelGroups() {\n\t      return Object.keys(this._heartbeatChannelGroups);\n\t    }\n\t  }, {\n\t    key: 'getSubscribedChannels',\n\t    value: function getSubscribedChannels() {\n\t      return Object.keys(this._channels);\n\t    }\n\t  }, {\n\t    key: 'getSubscribedChannelGroups',\n\t    value: function getSubscribedChannelGroups() {\n\t      return Object.keys(this._channelGroups);\n\t    }\n\t  }, {\n\t    key: 'reconnect',\n\t    value: function reconnect() {\n\t      this._startSubscribeLoop();\n\t      this._registerHeartbeatTimer();\n\t    }\n\t  }, {\n\t    key: 'disconnect',\n\t    value: function disconnect() {\n\t      this._stopSubscribeLoop();\n\t      this._stopHeartbeatTimer();\n\t      this._reconnectionManager.stopPolling();\n\t    }\n\t  }, {\n\t    key: '_registerHeartbeatTimer',\n\t    value: function _registerHeartbeatTimer() {\n\t      this._stopHeartbeatTimer();\n\n\t      if (this._config.getHeartbeatInterval() === 0) {\n\t        return;\n\t      }\n\n\t      this._performHeartbeatLoop();\n\t      this._heartbeatTimer = setInterval(this._performHeartbeatLoop.bind(this), this._config.getHeartbeatInterval() * 1000);\n\t    }\n\t  }, {\n\t    key: '_stopHeartbeatTimer',\n\t    value: function _stopHeartbeatTimer() {\n\t      if (this._heartbeatTimer) {\n\t        clearInterval(this._heartbeatTimer);\n\t        this._heartbeatTimer = null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_performHeartbeatLoop',\n\t    value: function _performHeartbeatLoop() {\n\t      var _this5 = this;\n\n\t      var heartbeatChannels = [];\n\t      heartbeatChannels = heartbeatChannels.concat(this.getHeartbeatChannels());\n\t      heartbeatChannels = heartbeatChannels.concat(this.getSubscribedChannels());\n\n\t      var heartbeatChannelGroups = [];\n\t      heartbeatChannelGroups = heartbeatChannelGroups.concat(this.getHeartbeatChannelGroups());\n\t      heartbeatChannelGroups = heartbeatChannelGroups.concat(this.getSubscribedChannelGroups());\n\n\t      var presenceState = {};\n\n\t      if (heartbeatChannels.length === 0 && heartbeatChannelGroups.length === 0) {\n\t        return;\n\t      }\n\n\t      this.getSubscribedChannels().forEach(function (channel) {\n\t        var channelState = _this5._channels[channel].state;\n\t        if (Object.keys(channelState).length) presenceState[channel] = channelState;\n\t      });\n\n\t      this.getSubscribedChannelGroups().forEach(function (channelGroup) {\n\t        var channelGroupState = _this5._channelGroups[channelGroup].state;\n\t        if (Object.keys(channelGroupState).length) presenceState[channelGroup] = channelGroupState;\n\t      });\n\n\t      var onHeartbeat = function onHeartbeat(status) {\n\t        if (status.error && _this5._config.announceFailedHeartbeats) {\n\t          _this5._listenerManager.announceStatus(status);\n\t        }\n\n\t        if (status.error && _this5._config.autoNetworkDetection && _this5._isOnline) {\n\t          _this5._isOnline = false;\n\t          _this5.disconnect();\n\t          _this5._listenerManager.announceNetworkDown();\n\t          _this5.reconnect();\n\t        }\n\n\t        if (!status.error && _this5._config.announceSuccessfulHeartbeats) {\n\t          _this5._listenerManager.announceStatus(status);\n\t        }\n\t      };\n\n\t      this._heartbeatEndpoint({\n\t        channels: heartbeatChannels,\n\t        channelGroups: heartbeatChannelGroups,\n\t        state: presenceState }, onHeartbeat.bind(this));\n\t    }\n\t  }, {\n\t    key: '_startSubscribeLoop',\n\t    value: function _startSubscribeLoop() {\n\t      this._stopSubscribeLoop();\n\t      var channels = [];\n\t      var channelGroups = [];\n\n\t      Object.keys(this._channels).forEach(function (channel) {\n\t        return channels.push(channel);\n\t      });\n\t      Object.keys(this._presenceChannels).forEach(function (channel) {\n\t        return channels.push(channel + '-pnpres');\n\t      });\n\n\t      Object.keys(this._channelGroups).forEach(function (channelGroup) {\n\t        return channelGroups.push(channelGroup);\n\t      });\n\t      Object.keys(this._presenceChannelGroups).forEach(function (channelGroup) {\n\t        return channelGroups.push(channelGroup + '-pnpres');\n\t      });\n\n\t      if (channels.length === 0 && channelGroups.length === 0) {\n\t        return;\n\t      }\n\n\t      var subscribeArgs = {\n\t        channels: channels,\n\t        channelGroups: channelGroups,\n\t        timetoken: this._currentTimetoken,\n\t        filterExpression: this._config.filterExpression,\n\t        region: this._region\n\t      };\n\n\t      this._subscribeCall = this._subscribeEndpoint(subscribeArgs, this._processSubscribeResponse.bind(this));\n\t    }\n\t  }, {\n\t    key: '_processSubscribeResponse',\n\t    value: function _processSubscribeResponse(status, payload) {\n\t      var _this6 = this;\n\n\t      if (status.error) {\n\t        if (status.category === _categories2.default.PNTimeoutCategory) {\n\t          this._startSubscribeLoop();\n\t        } else if (status.category === _categories2.default.PNNetworkIssuesCategory) {\n\t          this.disconnect();\n\n\t          if (status.error && this._config.autoNetworkDetection && this._isOnline) {\n\t            this._isOnline = false;\n\t            this._listenerManager.announceNetworkDown();\n\t          }\n\n\t          this._reconnectionManager.onReconnection(function () {\n\t            if (_this6._config.autoNetworkDetection && !_this6._isOnline) {\n\t              _this6._isOnline = true;\n\t              _this6._listenerManager.announceNetworkUp();\n\t            }\n\t            _this6.reconnect();\n\t            _this6._subscriptionStatusAnnounced = true;\n\t            var reconnectedAnnounce = {\n\t              category: _categories2.default.PNReconnectedCategory,\n\t              operation: status.operation,\n\t              lastTimetoken: _this6._lastTimetoken,\n\t              currentTimetoken: _this6._currentTimetoken\n\t            };\n\t            _this6._listenerManager.announceStatus(reconnectedAnnounce);\n\t          });\n\n\t          this._reconnectionManager.startPolling();\n\t          this._listenerManager.announceStatus(status);\n\t        } else if (status.category === _categories2.default.PNBadRequestCategory) {\n\t          this._stopHeartbeatTimer();\n\t          this._listenerManager.announceStatus(status);\n\t        } else {\n\t          this._listenerManager.announceStatus(status);\n\t        }\n\n\t        return;\n\t      }\n\n\t      if (this._storedTimetoken) {\n\t        this._currentTimetoken = this._storedTimetoken;\n\t        this._storedTimetoken = null;\n\t      } else {\n\t        this._lastTimetoken = this._currentTimetoken;\n\t        this._currentTimetoken = payload.metadata.timetoken;\n\t      }\n\n\t      if (!this._subscriptionStatusAnnounced) {\n\t        var connectedAnnounce = {};\n\t        connectedAnnounce.category = _categories2.default.PNConnectedCategory;\n\t        connectedAnnounce.operation = status.operation;\n\t        connectedAnnounce.affectedChannels = this._pendingChannelSubscriptions;\n\t        connectedAnnounce.subscribedChannels = this.getSubscribedChannels();\n\t        connectedAnnounce.affectedChannelGroups = this._pendingChannelGroupSubscriptions;\n\t        connectedAnnounce.lastTimetoken = this._lastTimetoken;\n\t        connectedAnnounce.currentTimetoken = this._currentTimetoken;\n\t        this._subscriptionStatusAnnounced = true;\n\t        this._listenerManager.announceStatus(connectedAnnounce);\n\n\t        this._pendingChannelSubscriptions = [];\n\t        this._pendingChannelGroupSubscriptions = [];\n\t      }\n\n\t      var messages = payload.messages || [];\n\t      var _config = this._config,\n\t          requestMessageCountThreshold = _config.requestMessageCountThreshold,\n\t          dedupeOnSubscribe = _config.dedupeOnSubscribe;\n\n\n\t      if (requestMessageCountThreshold && messages.length >= requestMessageCountThreshold) {\n\t        var countAnnouncement = {};\n\t        countAnnouncement.category = _categories2.default.PNRequestMessageCountExceededCategory;\n\t        countAnnouncement.operation = status.operation;\n\t        this._listenerManager.announceStatus(countAnnouncement);\n\t      }\n\n\t      messages.forEach(function (message) {\n\t        var channel = message.channel;\n\t        var subscriptionMatch = message.subscriptionMatch;\n\t        var publishMetaData = message.publishMetaData;\n\n\t        if (channel === subscriptionMatch) {\n\t          subscriptionMatch = null;\n\t        }\n\n\t        if (dedupeOnSubscribe) {\n\t          if (_this6._dedupingManager.isDuplicate(message)) {\n\t            return;\n\t          } else {\n\t            _this6._dedupingManager.addEntry(message);\n\t          }\n\t        }\n\n\t        if (_utils2.default.endsWith(message.channel, '-pnpres')) {\n\t          var announce = {};\n\t          announce.channel = null;\n\t          announce.subscription = null;\n\n\t          announce.actualChannel = subscriptionMatch != null ? channel : null;\n\t          announce.subscribedChannel = subscriptionMatch != null ? subscriptionMatch : channel;\n\n\n\t          if (channel) {\n\t            announce.channel = channel.substring(0, channel.lastIndexOf('-pnpres'));\n\t          }\n\n\t          if (subscriptionMatch) {\n\t            announce.subscription = subscriptionMatch.substring(0, subscriptionMatch.lastIndexOf('-pnpres'));\n\t          }\n\n\t          announce.action = message.payload.action;\n\t          announce.state = message.payload.data;\n\t          announce.timetoken = publishMetaData.publishTimetoken;\n\t          announce.occupancy = message.payload.occupancy;\n\t          announce.uuid = message.payload.uuid;\n\t          announce.timestamp = message.payload.timestamp;\n\n\t          if (message.payload.join) {\n\t            announce.join = message.payload.join;\n\t          }\n\n\t          if (message.payload.leave) {\n\t            announce.leave = message.payload.leave;\n\t          }\n\n\t          if (message.payload.timeout) {\n\t            announce.timeout = message.payload.timeout;\n\t          }\n\n\t          _this6._listenerManager.announcePresence(announce);\n\t        } else {\n\t          var _announce = {};\n\t          _announce.channel = null;\n\t          _announce.subscription = null;\n\n\t          _announce.actualChannel = subscriptionMatch != null ? channel : null;\n\t          _announce.subscribedChannel = subscriptionMatch != null ? subscriptionMatch : channel;\n\n\n\t          _announce.channel = channel;\n\t          _announce.subscription = subscriptionMatch;\n\t          _announce.timetoken = publishMetaData.publishTimetoken;\n\t          _announce.publisher = message.issuingClientId;\n\n\t          if (message.userMetadata) {\n\t            _announce.userMetadata = message.userMetadata;\n\t          }\n\n\t          if (_this6._config.cipherKey) {\n\t            _announce.message = _this6._crypto.decrypt(message.payload);\n\t          } else {\n\t            _announce.message = message.payload;\n\t          }\n\n\t          _this6._listenerManager.announceMessage(_announce);\n\t        }\n\t      });\n\n\t      this._region = payload.metadata.region;\n\t      this._startSubscribeLoop();\n\t    }\n\t  }, {\n\t    key: '_stopSubscribeLoop',\n\t    value: function _stopSubscribeLoop() {\n\t      if (this._subscribeCall) {\n\t        if (typeof this._subscribeCall.abort === 'function') {\n\t          this._subscribeCall.abort();\n\t        }\n\t        this._subscribeCall = null;\n\t      }\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _categories = __webpack_require__(10);\n\n\tvar _categories2 = _interopRequireDefault(_categories);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar _class = function () {\n\t  function _class() {\n\t    _classCallCheck(this, _class);\n\n\t    this._listeners = [];\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'addListener',\n\t    value: function addListener(newListeners) {\n\t      this._listeners.push(newListeners);\n\t    }\n\t  }, {\n\t    key: 'removeListener',\n\t    value: function removeListener(deprecatedListener) {\n\t      var newListeners = [];\n\n\t      this._listeners.forEach(function (listener) {\n\t        if (listener !== deprecatedListener) newListeners.push(listener);\n\t      });\n\n\t      this._listeners = newListeners;\n\t    }\n\t  }, {\n\t    key: 'removeAllListeners',\n\t    value: function removeAllListeners() {\n\t      this._listeners = [];\n\t    }\n\t  }, {\n\t    key: 'announcePresence',\n\t    value: function announcePresence(announce) {\n\t      this._listeners.forEach(function (listener) {\n\t        if (listener.presence) listener.presence(announce);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'announceStatus',\n\t    value: function announceStatus(announce) {\n\t      this._listeners.forEach(function (listener) {\n\t        if (listener.status) listener.status(announce);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'announceMessage',\n\t    value: function announceMessage(announce) {\n\t      this._listeners.forEach(function (listener) {\n\t        if (listener.message) listener.message(announce);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'announceNetworkUp',\n\t    value: function announceNetworkUp() {\n\t      var networkStatus = {};\n\t      networkStatus.category = _categories2.default.PNNetworkUpCategory;\n\t      this.announceStatus(networkStatus);\n\t    }\n\t  }, {\n\t    key: 'announceNetworkDown',\n\t    value: function announceNetworkDown() {\n\t      var networkStatus = {};\n\t      networkStatus.category = _categories2.default.PNNetworkDownCategory;\n\t      this.announceStatus(networkStatus);\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  PNNetworkUpCategory: 'PNNetworkUpCategory',\n\n\t  PNNetworkDownCategory: 'PNNetworkDownCategory',\n\n\t  PNNetworkIssuesCategory: 'PNNetworkIssuesCategory',\n\n\t  PNTimeoutCategory: 'PNTimeoutCategory',\n\n\t  PNBadRequestCategory: 'PNBadRequestCategory',\n\n\t  PNAccessDeniedCategory: 'PNAccessDeniedCategory',\n\n\t  PNUnknownCategory: 'PNUnknownCategory',\n\n\t  PNReconnectedCategory: 'PNReconnectedCategory',\n\n\t  PNConnectedCategory: 'PNConnectedCategory',\n\n\t  PNRequestMessageCountExceededCategory: 'PNRequestMessageCountExceededCategory'\n\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _time = __webpack_require__(12);\n\n\tvar _time2 = _interopRequireDefault(_time);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar _class = function () {\n\t  function _class(_ref) {\n\t    var timeEndpoint = _ref.timeEndpoint;\n\n\t    _classCallCheck(this, _class);\n\n\t    this._timeEndpoint = timeEndpoint;\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'onReconnection',\n\t    value: function onReconnection(reconnectionCallback) {\n\t      this._reconnectionCallback = reconnectionCallback;\n\t    }\n\t  }, {\n\t    key: 'startPolling',\n\t    value: function startPolling() {\n\t      this._timeTimer = setInterval(this._performTimeLoop.bind(this), 3000);\n\t    }\n\t  }, {\n\t    key: 'stopPolling',\n\t    value: function stopPolling() {\n\t      clearInterval(this._timeTimer);\n\t    }\n\t  }, {\n\t    key: '_performTimeLoop',\n\t    value: function _performTimeLoop() {\n\t      var _this = this;\n\n\t      this._timeEndpoint(function (status) {\n\t        if (!status.error) {\n\t          clearInterval(_this._timeTimer);\n\t          _this._reconnectionCallback();\n\t        }\n\t      });\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.prepareParams = prepareParams;\n\texports.isAuthSupported = isAuthSupported;\n\texports.handleResponse = handleResponse;\n\texports.validateParams = validateParams;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNTimeOperation;\n\t}\n\n\tfunction getURL() {\n\t  return '/time/0';\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction prepareParams() {\n\t  return {};\n\t}\n\n\tfunction isAuthSupported() {\n\t  return false;\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return {\n\t    timetoken: serverResponse[0]\n\t  };\n\t}\n\n\tfunction validateParams() {}\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  PNTimeOperation: 'PNTimeOperation',\n\n\t  PNHistoryOperation: 'PNHistoryOperation',\n\t  PNDeleteMessagesOperation: 'PNDeleteMessagesOperation',\n\t  PNFetchMessagesOperation: 'PNFetchMessagesOperation',\n\n\t  PNSubscribeOperation: 'PNSubscribeOperation',\n\t  PNUnsubscribeOperation: 'PNUnsubscribeOperation',\n\t  PNPublishOperation: 'PNPublishOperation',\n\n\t  PNPushNotificationEnabledChannelsOperation: 'PNPushNotificationEnabledChannelsOperation',\n\t  PNRemoveAllPushNotificationsOperation: 'PNRemoveAllPushNotificationsOperation',\n\n\t  PNWhereNowOperation: 'PNWhereNowOperation',\n\t  PNSetStateOperation: 'PNSetStateOperation',\n\t  PNHereNowOperation: 'PNHereNowOperation',\n\t  PNGetStateOperation: 'PNGetStateOperation',\n\t  PNHeartbeatOperation: 'PNHeartbeatOperation',\n\n\t  PNChannelGroupsOperation: 'PNChannelGroupsOperation',\n\t  PNRemoveGroupOperation: 'PNRemoveGroupOperation',\n\t  PNChannelsForGroupOperation: 'PNChannelsForGroupOperation',\n\t  PNAddChannelsToGroupOperation: 'PNAddChannelsToGroupOperation',\n\t  PNRemoveChannelsFromGroupOperation: 'PNRemoveChannelsFromGroupOperation',\n\n\t  PNAccessManagerGrant: 'PNAccessManagerGrant',\n\t  PNAccessManagerAudit: 'PNAccessManagerAudit'\n\t};\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _config2 = _interopRequireDefault(_config);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar hashCode = function hashCode(payload) {\n\t  var hash = 0;\n\t  if (payload.length === 0) return hash;\n\t  for (var i = 0; i < payload.length; i += 1) {\n\t    var character = payload.charCodeAt(i);\n\t    hash = (hash << 5) - hash + character;\n\t    hash = hash & hash;\n\t  }\n\t  return hash;\n\t};\n\n\tvar _class = function () {\n\t  function _class(_ref) {\n\t    var config = _ref.config;\n\n\t    _classCallCheck(this, _class);\n\n\t    this.hashHistory = [];\n\t    this._config = config;\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'getKey',\n\t    value: function getKey(message) {\n\t      var hashedPayload = hashCode(JSON.stringify(message.payload)).toString();\n\t      var timetoken = message.publishMetaData.publishTimetoken;\n\t      return timetoken + '-' + hashedPayload;\n\t    }\n\t  }, {\n\t    key: 'isDuplicate',\n\t    value: function isDuplicate(message) {\n\t      return this.hashHistory.includes(this.getKey(message));\n\t    }\n\t  }, {\n\t    key: 'addEntry',\n\t    value: function addEntry(message) {\n\t      if (this.hashHistory.length >= this._config.maximumCacheSize) {\n\t        this.hashHistory.shift();\n\t      }\n\n\t      this.hashHistory.push(this.getKey(message));\n\t    }\n\t  }, {\n\t    key: 'clearHistory',\n\t    value: function clearHistory() {\n\t      this.hashHistory = [];\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\tfunction objectToList(o) {\n\t  var l = [];\n\t  Object.keys(o).forEach(function (key) {\n\t    return l.push(key);\n\t  });\n\t  return l;\n\t}\n\n\tfunction encodeString(input) {\n\t  return encodeURIComponent(input).replace(/[!~*'()]/g, function (x) {\n\t    return '%' + x.charCodeAt(0).toString(16).toUpperCase();\n\t  });\n\t}\n\n\tfunction objectToListSorted(o) {\n\t  return objectToList(o).sort();\n\t}\n\n\tfunction signPamFromParams(params) {\n\t  var l = objectToListSorted(params);\n\t  return l.map(function (paramKey) {\n\t    return paramKey + '=' + encodeString(params[paramKey]);\n\t  }).join('&');\n\t}\n\n\tfunction endsWith(searchString, suffix) {\n\t  return searchString.indexOf(suffix, this.length - suffix.length) !== -1;\n\t}\n\n\tfunction createPromise() {\n\t  var successResolve = void 0;\n\t  var failureResolve = void 0;\n\t  var promise = new Promise(function (fulfill, reject) {\n\t    successResolve = fulfill;\n\t    failureResolve = reject;\n\t  });\n\n\t  return { promise: promise, reject: failureResolve, fulfill: successResolve };\n\t}\n\n\tmodule.exports = { signPamFromParams: signPamFromParams, endsWith: endsWith, createPromise: createPromise, encodeString: encodeString };\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\texports.default = function (modules, endpoint) {\n\t  var networking = modules.networking,\n\t      config = modules.config;\n\n\t  var callback = null;\n\t  var promiseComponent = null;\n\t  var incomingParams = {};\n\n\t  if (endpoint.getOperation() === _operations2.default.PNTimeOperation || endpoint.getOperation() === _operations2.default.PNChannelGroupsOperation) {\n\t    callback = arguments.length <= 2 ? undefined : arguments[2];\n\t  } else {\n\t    incomingParams = arguments.length <= 2 ? undefined : arguments[2];\n\t    callback = arguments.length <= 3 ? undefined : arguments[3];\n\t  }\n\n\t  if (typeof Promise !== 'undefined' && !callback) {\n\t    promiseComponent = _utils2.default.createPromise();\n\t  }\n\n\t  var validationResult = endpoint.validateParams(modules, incomingParams);\n\n\t  if (validationResult) {\n\t    if (callback) {\n\t      return callback(createValidationError(validationResult));\n\t    } else if (promiseComponent) {\n\t      promiseComponent.reject(new PubNubError('Validation failed, check status for details', createValidationError(validationResult)));\n\t      return promiseComponent.promise;\n\t    }\n\t    return;\n\t  }\n\n\t  var outgoingParams = endpoint.prepareParams(modules, incomingParams);\n\t  var url = decideURL(endpoint, modules, incomingParams);\n\t  var callInstance = void 0;\n\t  var networkingParams = { url: url,\n\t    operation: endpoint.getOperation(),\n\t    timeout: endpoint.getRequestTimeout(modules)\n\t  };\n\n\t  outgoingParams.uuid = config.UUID;\n\t  outgoingParams.pnsdk = generatePNSDK(config);\n\n\t  if (config.useInstanceId) {\n\t    outgoingParams.instanceid = config.instanceId;\n\t  }\n\n\t  if (config.useRequestId) {\n\t    outgoingParams.requestid = _uuid2.default.createUUID();\n\t  }\n\n\t  if (endpoint.isAuthSupported() && config.getAuthKey()) {\n\t    outgoingParams.auth = config.getAuthKey();\n\t  }\n\n\t  if (config.secretKey) {\n\t    signRequest(modules, url, outgoingParams);\n\t  }\n\n\t  var onResponse = function onResponse(status, payload) {\n\t    if (status.error) {\n\t      if (callback) {\n\t        callback(status);\n\t      } else if (promiseComponent) {\n\t        promiseComponent.reject(new PubNubError('PubNub call failed, check status for details', status));\n\t      }\n\t      return;\n\t    }\n\n\t    var parsedPayload = endpoint.handleResponse(modules, payload, incomingParams);\n\n\t    if (callback) {\n\t      callback(status, parsedPayload);\n\t    } else if (promiseComponent) {\n\t      promiseComponent.fulfill(parsedPayload);\n\t    }\n\t  };\n\n\t  if (endpoint.usePost && endpoint.usePost(modules, incomingParams)) {\n\t    var payload = endpoint.postPayload(modules, incomingParams);\n\t    callInstance = networking.POST(outgoingParams, payload, networkingParams, onResponse);\n\t  } else if (endpoint.useDelete && endpoint.useDelete()) {\n\t    callInstance = networking.DELETE(outgoingParams, networkingParams, onResponse);\n\t  } else {\n\t    callInstance = networking.GET(outgoingParams, networkingParams, onResponse);\n\t  }\n\n\t  if (endpoint.getOperation() === _operations2.default.PNSubscribeOperation) {\n\t    return callInstance;\n\t  }\n\n\t  if (promiseComponent) {\n\t    return promiseComponent.promise;\n\t  }\n\t};\n\n\tvar _uuid = __webpack_require__(3);\n\n\tvar _uuid2 = _interopRequireDefault(_uuid);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _config2 = _interopRequireDefault(_config);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\tvar PubNubError = function (_Error) {\n\t  _inherits(PubNubError, _Error);\n\n\t  function PubNubError(message, status) {\n\t    _classCallCheck(this, PubNubError);\n\n\t    var _this = _possibleConstructorReturn(this, (PubNubError.__proto__ || Object.getPrototypeOf(PubNubError)).call(this, message));\n\n\t    _this.name = _this.constructor.name;\n\t    _this.status = status;\n\t    _this.message = message;\n\t    return _this;\n\t  }\n\n\t  return PubNubError;\n\t}(Error);\n\n\tfunction createError(errorPayload, type) {\n\t  errorPayload.type = type;\n\t  errorPayload.error = true;\n\t  return errorPayload;\n\t}\n\n\tfunction createValidationError(message) {\n\t  return createError({ message: message }, 'validationError');\n\t}\n\n\tfunction decideURL(endpoint, modules, incomingParams) {\n\t  if (endpoint.usePost && endpoint.usePost(modules, incomingParams)) {\n\t    return endpoint.postURL(modules, incomingParams);\n\t  } else {\n\t    return endpoint.getURL(modules, incomingParams);\n\t  }\n\t}\n\n\tfunction generatePNSDK(config) {\n\t  if (config.sdkName) {\n\t    return config.sdkName;\n\t  }\n\n\t  var base = 'PubNub-JS-' + config.sdkFamily;\n\n\t  if (config.partnerId) {\n\t    base += '-' + config.partnerId;\n\t  }\n\n\t  base += '/' + config.getVersion();\n\n\t  return base;\n\t}\n\n\tfunction signRequest(modules, url, outgoingParams) {\n\t  var config = modules.config,\n\t      crypto = modules.crypto;\n\n\n\t  outgoingParams.timestamp = Math.floor(new Date().getTime() / 1000);\n\t  var signInput = config.subscribeKey + '\\n' + config.publishKey + '\\n' + url + '\\n';\n\t  signInput += _utils2.default.signPamFromParams(outgoingParams);\n\n\t  var signature = crypto.HMACSHA256(signInput);\n\t  signature = signature.replace(/\\+/g, '-');\n\t  signature = signature.replace(/\\//g, '_');\n\n\t  outgoingParams.signature = signature;\n\t}\n\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNAddChannelsToGroupOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var channels = incomingParams.channels,\n\t      channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\n\t  if (!channelGroup) return 'Missing Channel Group';\n\t  if (!channels || channels.length === 0) return 'Missing Channels';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\t  return '/v1/channel-registration/sub-key/' + config.subscribeKey + '/channel-group/' + _utils2.default.encodeString(channelGroup);\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\n\t  return {\n\t    add: channels.join(',')\n\t  };\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNRemoveChannelsFromGroupOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var channels = incomingParams.channels,\n\t      channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\n\t  if (!channelGroup) return 'Missing Channel Group';\n\t  if (!channels || channels.length === 0) return 'Missing Channels';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\t  return '/v1/channel-registration/sub-key/' + config.subscribeKey + '/channel-group/' + _utils2.default.encodeString(channelGroup);\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\n\t  return {\n\t    remove: channels.join(',')\n\t  };\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.isAuthSupported = isAuthSupported;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNRemoveGroupOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\n\t  if (!channelGroup) return 'Missing Channel Group';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\t  return '/v1/channel-registration/sub-key/' + config.subscribeKey + '/channel-group/' + _utils2.default.encodeString(channelGroup) + '/remove';\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction prepareParams() {\n\t  return {};\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNChannelGroupsOperation;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules) {\n\t  var config = modules.config;\n\n\t  return '/v1/channel-registration/sub-key/' + config.subscribeKey + '/channel-group';\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams() {\n\t  return {};\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return {\n\t    groups: serverResponse.payload.groups\n\t  };\n\t}\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNChannelsForGroupOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\n\t  if (!channelGroup) return 'Missing Channel Group';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var channelGroup = incomingParams.channelGroup;\n\t  var config = modules.config;\n\n\t  return '/v1/channel-registration/sub-key/' + config.subscribeKey + '/channel-group/' + _utils2.default.encodeString(channelGroup);\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams() {\n\t  return {};\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return {\n\t    channels: serverResponse.payload.channels\n\t  };\n\t}\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNPushNotificationEnabledChannelsOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var device = incomingParams.device,\n\t      pushGateway = incomingParams.pushGateway,\n\t      channels = incomingParams.channels;\n\t  var config = modules.config;\n\n\n\t  if (!device) return 'Missing Device ID (device)';\n\t  if (!pushGateway) return 'Missing GW Type (pushGateway: gcm or apns)';\n\t  if (!channels || channels.length === 0) return 'Missing Channels';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var device = incomingParams.device;\n\t  var config = modules.config;\n\n\t  return '/v1/push/sub-key/' + config.subscribeKey + '/devices/' + device;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var pushGateway = incomingParams.pushGateway,\n\t      _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\t  return { type: pushGateway, add: channels.join(',') };\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNPushNotificationEnabledChannelsOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var device = incomingParams.device,\n\t      pushGateway = incomingParams.pushGateway,\n\t      channels = incomingParams.channels;\n\t  var config = modules.config;\n\n\n\t  if (!device) return 'Missing Device ID (device)';\n\t  if (!pushGateway) return 'Missing GW Type (pushGateway: gcm or apns)';\n\t  if (!channels || channels.length === 0) return 'Missing Channels';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var device = incomingParams.device;\n\t  var config = modules.config;\n\n\t  return '/v1/push/sub-key/' + config.subscribeKey + '/devices/' + device;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var pushGateway = incomingParams.pushGateway,\n\t      _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\t  return { type: pushGateway, remove: channels.join(',') };\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNPushNotificationEnabledChannelsOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var device = incomingParams.device,\n\t      pushGateway = incomingParams.pushGateway;\n\t  var config = modules.config;\n\n\n\t  if (!device) return 'Missing Device ID (device)';\n\t  if (!pushGateway) return 'Missing GW Type (pushGateway: gcm or apns)';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var device = incomingParams.device;\n\t  var config = modules.config;\n\n\t  return '/v1/push/sub-key/' + config.subscribeKey + '/devices/' + device;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var pushGateway = incomingParams.pushGateway;\n\n\t  return { type: pushGateway };\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return { channels: serverResponse };\n\t}\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNRemoveAllPushNotificationsOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var device = incomingParams.device,\n\t      pushGateway = incomingParams.pushGateway;\n\t  var config = modules.config;\n\n\n\t  if (!device) return 'Missing Device ID (device)';\n\t  if (!pushGateway) return 'Missing GW Type (pushGateway: gcm or apns)';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var device = incomingParams.device;\n\t  var config = modules.config;\n\n\t  return '/v1/push/sub-key/' + config.subscribeKey + '/devices/' + device + '/remove';\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var pushGateway = incomingParams.pushGateway;\n\n\t  return { type: pushGateway };\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNUnsubscribeOperation;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\t  var stringifiedChannels = channels.length > 0 ? channels.join(',') : ',';\n\t  return '/v2/presence/sub-key/' + config.subscribeKey + '/channel/' + _utils2.default.encodeString(stringifiedChannels) + '/leave';\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var _incomingParams$chann2 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann2 === undefined ? [] : _incomingParams$chann2;\n\n\t  var params = {};\n\n\t  if (channelGroups.length > 0) {\n\t    params['channel-group'] = channelGroups.join(',');\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNWhereNowOperation;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var _incomingParams$uuid = incomingParams.uuid,\n\t      uuid = _incomingParams$uuid === undefined ? config.UUID : _incomingParams$uuid;\n\n\t  return '/v2/presence/sub-key/' + config.subscribeKey + '/uuid/' + uuid;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams() {\n\t  return {};\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  if (!serverResponse.payload) {\n\t    return { channels: [] };\n\t  }\n\t  return { channels: serverResponse.payload.channels };\n\t}\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.isAuthSupported = isAuthSupported;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNHeartbeatOperation;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\t  var stringifiedChannels = channels.length > 0 ? channels.join(',') : ',';\n\t  return '/v2/presence/sub-key/' + config.subscribeKey + '/channel/' + _utils2.default.encodeString(stringifiedChannels) + '/heartbeat';\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var _incomingParams$chann2 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann2 === undefined ? [] : _incomingParams$chann2,\n\t      _incomingParams$state = incomingParams.state,\n\t      state = _incomingParams$state === undefined ? {} : _incomingParams$state;\n\t  var config = modules.config;\n\n\t  var params = {};\n\n\t  if (channelGroups.length > 0) {\n\t    params['channel-group'] = channelGroups.join(',');\n\t  }\n\n\t  params.state = JSON.stringify(state);\n\t  params.heartbeat = config.getPresenceTimeout();\n\t  return params;\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNGetStateOperation;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var _incomingParams$uuid = incomingParams.uuid,\n\t      uuid = _incomingParams$uuid === undefined ? config.UUID : _incomingParams$uuid,\n\t      _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\t  var stringifiedChannels = channels.length > 0 ? channels.join(',') : ',';\n\t  return '/v2/presence/sub-key/' + config.subscribeKey + '/channel/' + _utils2.default.encodeString(stringifiedChannels) + '/uuid/' + uuid;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var _incomingParams$chann2 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann2 === undefined ? [] : _incomingParams$chann2;\n\n\t  var params = {};\n\n\t  if (channelGroups.length > 0) {\n\t    params['channel-group'] = channelGroups.join(',');\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse(modules, serverResponse, incomingParams) {\n\t  var _incomingParams$chann3 = incomingParams.channels,\n\t      channels = _incomingParams$chann3 === undefined ? [] : _incomingParams$chann3,\n\t      _incomingParams$chann4 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann4 === undefined ? [] : _incomingParams$chann4;\n\n\t  var channelsResponse = {};\n\n\t  if (channels.length === 1 && channelGroups.length === 0) {\n\t    channelsResponse[channels[0]] = serverResponse.payload;\n\t  } else {\n\t    channelsResponse = serverResponse.payload;\n\t  }\n\n\t  return { channels: channelsResponse };\n\t}\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNSetStateOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var state = incomingParams.state,\n\t      _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann,\n\t      _incomingParams$chann2 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann2 === undefined ? [] : _incomingParams$chann2;\n\n\n\t  if (!state) return 'Missing State';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t  if (channels.length === 0 && channelGroups.length === 0) return 'Please provide a list of channels and/or channel-groups';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var _incomingParams$chann3 = incomingParams.channels,\n\t      channels = _incomingParams$chann3 === undefined ? [] : _incomingParams$chann3;\n\n\t  var stringifiedChannels = channels.length > 0 ? channels.join(',') : ',';\n\t  return '/v2/presence/sub-key/' + config.subscribeKey + '/channel/' + _utils2.default.encodeString(stringifiedChannels) + '/uuid/' + config.UUID + '/data';\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var state = incomingParams.state,\n\t      _incomingParams$chann4 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann4 === undefined ? [] : _incomingParams$chann4;\n\n\t  var params = {};\n\n\t  params.state = JSON.stringify(state);\n\n\t  if (channelGroups.length > 0) {\n\t    params['channel-group'] = channelGroups.join(',');\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return { state: serverResponse.payload };\n\t}\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNHereNowOperation;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann,\n\t      _incomingParams$chann2 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann2 === undefined ? [] : _incomingParams$chann2;\n\n\t  var baseURL = '/v2/presence/sub-key/' + config.subscribeKey;\n\n\t  if (channels.length > 0 || channelGroups.length > 0) {\n\t    var stringifiedChannels = channels.length > 0 ? channels.join(',') : ',';\n\t    baseURL += '/channel/' + _utils2.default.encodeString(stringifiedChannels);\n\t  }\n\n\t  return baseURL;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var _incomingParams$chann3 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann3 === undefined ? [] : _incomingParams$chann3,\n\t      _incomingParams$inclu = incomingParams.includeUUIDs,\n\t      includeUUIDs = _incomingParams$inclu === undefined ? true : _incomingParams$inclu,\n\t      _incomingParams$inclu2 = incomingParams.includeState,\n\t      includeState = _incomingParams$inclu2 === undefined ? false : _incomingParams$inclu2;\n\n\t  var params = {};\n\n\t  if (!includeUUIDs) params.disable_uuids = 1;\n\t  if (includeState) params.state = 1;\n\n\t  if (channelGroups.length > 0) {\n\t    params['channel-group'] = channelGroups.join(',');\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse(modules, serverResponse, incomingParams) {\n\t  var _incomingParams$chann4 = incomingParams.channels,\n\t      channels = _incomingParams$chann4 === undefined ? [] : _incomingParams$chann4,\n\t      _incomingParams$chann5 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann5 === undefined ? [] : _incomingParams$chann5,\n\t      _incomingParams$inclu3 = incomingParams.includeUUIDs,\n\t      includeUUIDs = _incomingParams$inclu3 === undefined ? true : _incomingParams$inclu3,\n\t      _incomingParams$inclu4 = incomingParams.includeState,\n\t      includeState = _incomingParams$inclu4 === undefined ? false : _incomingParams$inclu4;\n\n\n\t  var prepareSingularChannel = function prepareSingularChannel() {\n\t    var response = {};\n\t    var occupantsList = [];\n\t    response.totalChannels = 1;\n\t    response.totalOccupancy = serverResponse.occupancy;\n\t    response.channels = {};\n\t    response.channels[channels[0]] = {\n\t      occupants: occupantsList,\n\t      name: channels[0],\n\t      occupancy: serverResponse.occupancy\n\t    };\n\n\t    if (includeUUIDs && serverResponse.uuids) {\n\t      serverResponse.uuids.forEach(function (uuidEntry) {\n\t        if (includeState) {\n\t          occupantsList.push({ state: uuidEntry.state, uuid: uuidEntry.uuid });\n\t        } else {\n\t          occupantsList.push({ state: null, uuid: uuidEntry });\n\t        }\n\t      });\n\t    }\n\n\t    return response;\n\t  };\n\n\t  var prepareMultipleChannel = function prepareMultipleChannel() {\n\t    var response = {};\n\t    response.totalChannels = serverResponse.payload.total_channels;\n\t    response.totalOccupancy = serverResponse.payload.total_occupancy;\n\t    response.channels = {};\n\n\t    Object.keys(serverResponse.payload.channels).forEach(function (channelName) {\n\t      var channelEntry = serverResponse.payload.channels[channelName];\n\t      var occupantsList = [];\n\t      response.channels[channelName] = {\n\t        occupants: occupantsList,\n\t        name: channelName,\n\t        occupancy: channelEntry.occupancy\n\t      };\n\n\t      if (includeUUIDs) {\n\t        channelEntry.uuids.forEach(function (uuidEntry) {\n\t          if (includeState) {\n\t            occupantsList.push({ state: uuidEntry.state, uuid: uuidEntry.uuid });\n\t          } else {\n\t            occupantsList.push({ state: null, uuid: uuidEntry });\n\t          }\n\t        });\n\t      }\n\n\t      return response;\n\t    });\n\n\t    return response;\n\t  };\n\n\t  var response = void 0;\n\t  if (channels.length > 1 || channelGroups.length > 0 || channelGroups.length === 0 && channels.length === 0) {\n\t    response = prepareMultipleChannel();\n\t  } else {\n\t    response = prepareSingularChannel();\n\t  }\n\n\t  return response;\n\t}\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNAccessManagerAudit;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules) {\n\t  var config = modules.config;\n\n\t  return '/v2/auth/audit/sub-key/' + config.subscribeKey;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return false;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var channel = incomingParams.channel,\n\t      channelGroup = incomingParams.channelGroup,\n\t      _incomingParams$authK = incomingParams.authKeys,\n\t      authKeys = _incomingParams$authK === undefined ? [] : _incomingParams$authK;\n\n\t  var params = {};\n\n\t  if (channel) {\n\t    params.channel = channel;\n\t  }\n\n\t  if (channelGroup) {\n\t    params['channel-group'] = channelGroup;\n\t  }\n\n\t  if (authKeys.length > 0) {\n\t    params.auth = authKeys.join(',');\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return serverResponse.payload;\n\t}\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNAccessManagerGrant;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t  if (!config.publishKey) return 'Missing Publish Key';\n\t  if (!config.secretKey) return 'Missing Secret Key';\n\t}\n\n\tfunction getURL(modules) {\n\t  var config = modules.config;\n\n\t  return '/v2/auth/grant/sub-key/' + config.subscribeKey;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return false;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann,\n\t      _incomingParams$chann2 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann2 === undefined ? [] : _incomingParams$chann2,\n\t      ttl = incomingParams.ttl,\n\t      _incomingParams$read = incomingParams.read,\n\t      read = _incomingParams$read === undefined ? false : _incomingParams$read,\n\t      _incomingParams$write = incomingParams.write,\n\t      write = _incomingParams$write === undefined ? false : _incomingParams$write,\n\t      _incomingParams$manag = incomingParams.manage,\n\t      manage = _incomingParams$manag === undefined ? false : _incomingParams$manag,\n\t      _incomingParams$authK = incomingParams.authKeys,\n\t      authKeys = _incomingParams$authK === undefined ? [] : _incomingParams$authK;\n\n\t  var params = {};\n\n\t  params.r = read ? '1' : '0';\n\t  params.w = write ? '1' : '0';\n\t  params.m = manage ? '1' : '0';\n\n\t  if (channels.length > 0) {\n\t    params.channel = channels.join(',');\n\t  }\n\n\t  if (channelGroups.length > 0) {\n\t    params['channel-group'] = channelGroups.join(',');\n\t  }\n\n\t  if (authKeys.length > 0) {\n\t    params.auth = authKeys.join(',');\n\t  }\n\n\t  if (ttl || ttl === 0) {\n\t    params.ttl = ttl;\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse() {\n\t  return {};\n\t}\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.usePost = usePost;\n\texports.getURL = getURL;\n\texports.postURL = postURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.postPayload = postPayload;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction prepareMessagePayload(modules, messagePayload) {\n\t  var crypto = modules.crypto,\n\t      config = modules.config;\n\n\t  var stringifiedPayload = JSON.stringify(messagePayload);\n\n\t  if (config.cipherKey) {\n\t    stringifiedPayload = crypto.encrypt(stringifiedPayload);\n\t    stringifiedPayload = JSON.stringify(stringifiedPayload);\n\t  }\n\n\t  return stringifiedPayload;\n\t}\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNPublishOperation;\n\t}\n\n\tfunction validateParams(_ref, incomingParams) {\n\t  var config = _ref.config;\n\t  var message = incomingParams.message,\n\t      channel = incomingParams.channel;\n\n\n\t  if (!channel) return 'Missing Channel';\n\t  if (!message) return 'Missing Message';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction usePost(modules, incomingParams) {\n\t  var _incomingParams$sendB = incomingParams.sendByPost,\n\t      sendByPost = _incomingParams$sendB === undefined ? false : _incomingParams$sendB;\n\n\t  return sendByPost;\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var channel = incomingParams.channel,\n\t      message = incomingParams.message;\n\n\t  var stringifiedPayload = prepareMessagePayload(modules, message);\n\t  return '/publish/' + config.publishKey + '/' + config.subscribeKey + '/0/' + _utils2.default.encodeString(channel) + '/0/' + _utils2.default.encodeString(stringifiedPayload);\n\t}\n\n\tfunction postURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var channel = incomingParams.channel;\n\n\t  return '/publish/' + config.publishKey + '/' + config.subscribeKey + '/0/' + _utils2.default.encodeString(channel) + '/0';\n\t}\n\n\tfunction getRequestTimeout(_ref2) {\n\t  var config = _ref2.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction postPayload(modules, incomingParams) {\n\t  var message = incomingParams.message;\n\n\t  return prepareMessagePayload(modules, message);\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var meta = incomingParams.meta,\n\t      _incomingParams$repli = incomingParams.replicate,\n\t      replicate = _incomingParams$repli === undefined ? true : _incomingParams$repli,\n\t      storeInHistory = incomingParams.storeInHistory,\n\t      ttl = incomingParams.ttl;\n\n\t  var params = {};\n\n\t  if (storeInHistory != null) {\n\t    if (storeInHistory) {\n\t      params.store = '1';\n\t    } else {\n\t      params.store = '0';\n\t    }\n\t  }\n\n\t  if (ttl) {\n\t    params.ttl = ttl;\n\t  }\n\n\t  if (replicate === false) {\n\t    params.norep = 'true';\n\t  }\n\n\t  if (meta && (typeof meta === 'undefined' ? 'undefined' : _typeof(meta)) === 'object') {\n\t    params.meta = JSON.stringify(meta);\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return { timetoken: serverResponse[2] };\n\t}\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction __processMessage(modules, message) {\n\t  var config = modules.config,\n\t      crypto = modules.crypto;\n\n\t  if (!config.cipherKey) return message;\n\n\t  try {\n\t    return crypto.decrypt(message);\n\t  } catch (e) {\n\t    return message;\n\t  }\n\t}\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNHistoryOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var channel = incomingParams.channel;\n\t  var config = modules.config;\n\n\n\t  if (!channel) return 'Missing channel';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var channel = incomingParams.channel;\n\t  var config = modules.config;\n\n\t  return '/v2/history/sub-key/' + config.subscribeKey + '/channel/' + _utils2.default.encodeString(channel);\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var start = incomingParams.start,\n\t      end = incomingParams.end,\n\t      reverse = incomingParams.reverse,\n\t      _incomingParams$count = incomingParams.count,\n\t      count = _incomingParams$count === undefined ? 100 : _incomingParams$count,\n\t      _incomingParams$strin = incomingParams.stringifiedTimeToken,\n\t      stringifiedTimeToken = _incomingParams$strin === undefined ? false : _incomingParams$strin;\n\n\t  var outgoingParams = {\n\t    include_token: 'true'\n\t  };\n\n\t  outgoingParams.count = count;\n\t  if (start) outgoingParams.start = start;\n\t  if (end) outgoingParams.end = end;\n\t  if (stringifiedTimeToken) outgoingParams.string_message_token = 'true';\n\t  if (reverse != null) outgoingParams.reverse = reverse.toString();\n\n\t  return outgoingParams;\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  var response = {\n\t    messages: [],\n\t    startTimeToken: serverResponse[1],\n\t    endTimeToken: serverResponse[2]\n\t  };\n\n\t  serverResponse[0].forEach(function (serverHistoryItem) {\n\t    var item = {\n\t      timetoken: serverHistoryItem.timetoken,\n\t      entry: __processMessage(modules, serverHistoryItem.message)\n\t    };\n\n\t    response.messages.push(item);\n\t  });\n\n\t  return response;\n\t}\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.useDelete = useDelete;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNDeleteMessagesOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var channel = incomingParams.channel;\n\t  var config = modules.config;\n\n\n\t  if (!channel) return 'Missing channel';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction useDelete() {\n\t  return true;\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var channel = incomingParams.channel,\n\t      start = incomingParams.start,\n\t      end = incomingParams.end;\n\t  var config = modules.config;\n\n\t  var querystring = '';\n\n\t  if (start) {\n\t    querystring = '?start=' + start;\n\t  }\n\n\t  if (end) {\n\t    querystring += (querystring !== '' ? '&' : '?') + 'end=' + end;\n\t  }\n\n\t  return '/v3/history/sub-key/' + config.subscribeKey + '/channel/' + _utils2.default.encodeString(channel) + querystring;\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var start = incomingParams.start,\n\t      end = incomingParams.end;\n\n\n\t  var outgoingParams = {};\n\n\t  if (start) outgoingParams.start = start;\n\t  if (end) outgoingParams.end = end;\n\n\t  return {};\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  return serverResponse.payload;\n\t}\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction __processMessage(modules, message) {\n\t  var config = modules.config,\n\t      crypto = modules.crypto;\n\n\t  if (!config.cipherKey) return message;\n\n\t  try {\n\t    return crypto.decrypt(message);\n\t  } catch (e) {\n\t    return message;\n\t  }\n\t}\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNFetchMessagesOperation;\n\t}\n\n\tfunction validateParams(modules, incomingParams) {\n\t  var channels = incomingParams.channels;\n\t  var config = modules.config;\n\n\n\t  if (!channels || channels.length === 0) return 'Missing channels';\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\t  var config = modules.config;\n\n\n\t  var stringifiedChannels = channels.length > 0 ? channels.join(',') : ',';\n\t  return '/v3/history/sub-key/' + config.subscribeKey + '/channel/' + _utils2.default.encodeString(stringifiedChannels);\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getTransactionTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(modules, incomingParams) {\n\t  var start = incomingParams.start,\n\t      end = incomingParams.end,\n\t      count = incomingParams.count;\n\n\t  var outgoingParams = {};\n\n\t  if (count) outgoingParams.max = count;\n\t  if (start) outgoingParams.start = start;\n\t  if (end) outgoingParams.end = end;\n\n\t  return outgoingParams;\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  var response = {\n\t    channels: {}\n\t  };\n\n\t  Object.keys(serverResponse.channels || {}).forEach(function (channelName) {\n\t    response.channels[channelName] = [];\n\n\t    (serverResponse.channels[channelName] || []).forEach(function (messageEnvelope) {\n\t      var announce = {};\n\t      announce.channel = channelName;\n\t      announce.subscription = null;\n\t      announce.timetoken = messageEnvelope.timetoken;\n\t      announce.message = __processMessage(modules, messageEnvelope.message);\n\t      response.channels[channelName].push(announce);\n\t    });\n\t  });\n\n\t  return response;\n\t}\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.getOperation = getOperation;\n\texports.validateParams = validateParams;\n\texports.getURL = getURL;\n\texports.getRequestTimeout = getRequestTimeout;\n\texports.isAuthSupported = isAuthSupported;\n\texports.prepareParams = prepareParams;\n\texports.handleResponse = handleResponse;\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tvar _operations = __webpack_require__(13);\n\n\tvar _operations2 = _interopRequireDefault(_operations);\n\n\tvar _utils = __webpack_require__(15);\n\n\tvar _utils2 = _interopRequireDefault(_utils);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction getOperation() {\n\t  return _operations2.default.PNSubscribeOperation;\n\t}\n\n\tfunction validateParams(modules) {\n\t  var config = modules.config;\n\n\n\t  if (!config.subscribeKey) return 'Missing Subscribe Key';\n\t}\n\n\tfunction getURL(modules, incomingParams) {\n\t  var config = modules.config;\n\t  var _incomingParams$chann = incomingParams.channels,\n\t      channels = _incomingParams$chann === undefined ? [] : _incomingParams$chann;\n\n\t  var stringifiedChannels = channels.length > 0 ? channels.join(',') : ',';\n\t  return '/v2/subscribe/' + config.subscribeKey + '/' + _utils2.default.encodeString(stringifiedChannels) + '/0';\n\t}\n\n\tfunction getRequestTimeout(_ref) {\n\t  var config = _ref.config;\n\n\t  return config.getSubscribeTimeout();\n\t}\n\n\tfunction isAuthSupported() {\n\t  return true;\n\t}\n\n\tfunction prepareParams(_ref2, incomingParams) {\n\t  var config = _ref2.config;\n\t  var _incomingParams$chann2 = incomingParams.channelGroups,\n\t      channelGroups = _incomingParams$chann2 === undefined ? [] : _incomingParams$chann2,\n\t      timetoken = incomingParams.timetoken,\n\t      filterExpression = incomingParams.filterExpression,\n\t      region = incomingParams.region;\n\n\t  var params = {\n\t    heartbeat: config.getPresenceTimeout()\n\t  };\n\n\t  if (channelGroups.length > 0) {\n\t    params['channel-group'] = channelGroups.join(',');\n\t  }\n\n\t  if (filterExpression && filterExpression.length > 0) {\n\t    params['filter-expr'] = filterExpression;\n\t  }\n\n\t  if (timetoken) {\n\t    params.tt = timetoken;\n\t  }\n\n\t  if (region) {\n\t    params.tr = region;\n\t  }\n\n\t  return params;\n\t}\n\n\tfunction handleResponse(modules, serverResponse) {\n\t  var messages = [];\n\n\t  serverResponse.m.forEach(function (rawMessage) {\n\t    var publishMetaData = {\n\t      publishTimetoken: rawMessage.p.t,\n\t      region: rawMessage.p.r\n\t    };\n\t    var parsedMessage = {\n\t      shard: parseInt(rawMessage.a, 10),\n\t      subscriptionMatch: rawMessage.b,\n\t      channel: rawMessage.c,\n\t      payload: rawMessage.d,\n\t      flags: rawMessage.f,\n\t      issuingClientId: rawMessage.i,\n\t      subscribeKey: rawMessage.k,\n\t      originationTimetoken: rawMessage.o,\n\t      userMetadata: rawMessage.u,\n\t      publishMetaData: publishMetaData\n\t    };\n\t    messages.push(parsedMessage);\n\t  });\n\n\t  var metadata = {\n\t    timetoken: serverResponse.t.t,\n\t    region: serverResponse.t.r\n\t  };\n\n\t  return { messages: messages, metadata: metadata };\n\t}\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n\tvar _config = __webpack_require__(2);\n\n\tvar _config2 = _interopRequireDefault(_config);\n\n\tvar _categories = __webpack_require__(10);\n\n\tvar _categories2 = _interopRequireDefault(_categories);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\tvar _class = function () {\n\t  function _class(modules) {\n\t    var _this = this;\n\n\t    _classCallCheck(this, _class);\n\n\t    this._modules = {};\n\n\t    Object.keys(modules).forEach(function (key) {\n\t      _this._modules[key] = modules[key].bind(_this);\n\t    });\n\t  }\n\n\t  _createClass(_class, [{\n\t    key: 'init',\n\t    value: function init(config) {\n\t      this._config = config;\n\n\t      this._maxSubDomain = 20;\n\t      this._currentSubDomain = Math.floor(Math.random() * this._maxSubDomain);\n\t      this._providedFQDN = (this._config.secure ? 'https://' : 'http://') + this._config.origin;\n\t      this._coreParams = {};\n\n\t      this.shiftStandardOrigin();\n\t    }\n\t  }, {\n\t    key: 'nextOrigin',\n\t    value: function nextOrigin() {\n\t      if (this._providedFQDN.indexOf('pubsub.') === -1) {\n\t        return this._providedFQDN;\n\t      }\n\n\t      var newSubDomain = void 0;\n\n\t      this._currentSubDomain = this._currentSubDomain + 1;\n\n\t      if (this._currentSubDomain >= this._maxSubDomain) {\n\t        this._currentSubDomain = 1;\n\t      }\n\n\t      newSubDomain = this._currentSubDomain.toString();\n\n\t      return this._providedFQDN.replace('pubsub', 'ps' + newSubDomain);\n\t    }\n\t  }, {\n\t    key: 'hasModule',\n\t    value: function hasModule(name) {\n\t      return name in this._modules;\n\t    }\n\t  }, {\n\t    key: 'shiftStandardOrigin',\n\t    value: function shiftStandardOrigin() {\n\t      var failover = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n\t      this._standardOrigin = this.nextOrigin(failover);\n\n\t      return this._standardOrigin;\n\t    }\n\t  }, {\n\t    key: 'getStandardOrigin',\n\t    value: function getStandardOrigin() {\n\t      return this._standardOrigin;\n\t    }\n\t  }, {\n\t    key: 'POST',\n\t    value: function POST(params, body, endpoint, callback) {\n\t      return this._modules.post(params, body, endpoint, callback);\n\t    }\n\t  }, {\n\t    key: 'GET',\n\t    value: function GET(params, endpoint, callback) {\n\t      return this._modules.get(params, endpoint, callback);\n\t    }\n\t  }, {\n\t    key: 'DELETE',\n\t    value: function DELETE(params, endpoint, callback) {\n\t      return this._modules.del(params, endpoint, callback);\n\t    }\n\t  }, {\n\t    key: '_detectErrorCategory',\n\t    value: function _detectErrorCategory(err) {\n\t      if (err.code === 'ENOTFOUND') return _categories2.default.PNNetworkIssuesCategory;\n\t      if (err.code === 'ECONNREFUSED') return _categories2.default.PNNetworkIssuesCategory;\n\t      if (err.code === 'ECONNRESET') return _categories2.default.PNNetworkIssuesCategory;\n\t      if (err.code === 'EAI_AGAIN') return _categories2.default.PNNetworkIssuesCategory;\n\n\t      if (err.status === 0 || err.hasOwnProperty('status') && typeof err.status === 'undefined') return _categories2.default.PNNetworkIssuesCategory;\n\t      if (err.timeout) return _categories2.default.PNTimeoutCategory;\n\n\t      if (err.response) {\n\t        if (err.response.badRequest) return _categories2.default.PNBadRequestCategory;\n\t        if (err.response.forbidden) return _categories2.default.PNAccessDeniedCategory;\n\t      }\n\n\t      return _categories2.default.PNUnknownCategory;\n\t    }\n\t  }]);\n\n\t  return _class;\n\t}();\n\n\texports.default = _class;\n\tmodule.exports = exports['default'];\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = {\n\t  get: function get(key) {\n\t    try {\n\t      return localStorage.getItem(key);\n\t    } catch (e) {\n\t      return null;\n\t    }\n\t  },\n\t  set: function set(key, data) {\n\t    try {\n\t      return localStorage.setItem(key, data);\n\t    } catch (e) {\n\t      return null;\n\t    }\n\t  }\n\t};\n\tmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.get = get;\n\texports.post = post;\n\texports.del = del;\n\n\tvar _superagent = __webpack_require__(42);\n\n\tvar _superagent2 = _interopRequireDefault(_superagent);\n\n\tvar _flow_interfaces = __webpack_require__(5);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n\tfunction log(req) {\n\t  var _pickLogger = function _pickLogger() {\n\t    if (console && console.log) return console;\n\t    if (window && window.console && window.console.log) return window.console;\n\t    return console;\n\t  };\n\n\t  var start = new Date().getTime();\n\t  var timestamp = new Date().toISOString();\n\t  var logger = _pickLogger();\n\t  logger.log('<<<<<');\n\t  logger.log('[' + timestamp + ']', '\\n', req.url, '\\n', req.qs);\n\t  logger.log('-----');\n\n\t  req.on('response', function (res) {\n\t    var now = new Date().getTime();\n\t    var elapsed = now - start;\n\t    var timestampDone = new Date().toISOString();\n\n\t    logger.log('>>>>>>');\n\t    logger.log('[' + timestampDone + ' / ' + elapsed + ']', '\\n', req.url, '\\n', req.qs, '\\n', res.text);\n\t    logger.log('-----');\n\t  });\n\t}\n\n\tfunction xdr(superagentConstruct, endpoint, callback) {\n\t  var _this = this;\n\n\t  if (this._config.logVerbosity) {\n\t    superagentConstruct = superagentConstruct.use(log);\n\t  }\n\n\t  if (this._config.proxy && this._modules.proxy) {\n\t    superagentConstruct = this._modules.proxy.call(this, superagentConstruct);\n\t  }\n\n\t  if (this._config.keepAlive && this._modules.keepAlive) {\n\t    superagentConstruct = this._modules.keepAlive(superagentConstruct);\n\t  }\n\n\t  return superagentConstruct.timeout(endpoint.timeout).end(function (err, resp) {\n\t    var status = {};\n\t    status.error = err !== null;\n\t    status.operation = endpoint.operation;\n\n\t    if (resp && resp.status) {\n\t      status.statusCode = resp.status;\n\t    }\n\n\t    if (err) {\n\t      status.errorData = err;\n\t      status.category = _this._detectErrorCategory(err);\n\t      return callback(status, null);\n\t    }\n\n\t    var parsedResponse = JSON.parse(resp.text);\n\n\t    if (parsedResponse.error && parsedResponse.error === 1 && parsedResponse.status && parsedResponse.message && parsedResponse.service) {\n\t      status.errorData = parsedResponse;\n\t      status.statusCode = parsedResponse.status;\n\t      status.error = true;\n\t      status.category = _this._detectErrorCategory(status);\n\t      return callback(status, null);\n\t    }\n\n\t    return callback(status, parsedResponse);\n\t  });\n\t}\n\n\tfunction get(params, endpoint, callback) {\n\t  var superagentConstruct = _superagent2.default.get(this.getStandardOrigin() + endpoint.url).query(params);\n\t  return xdr.call(this, superagentConstruct, endpoint, callback);\n\t}\n\n\tfunction post(params, body, endpoint, callback) {\n\t  var superagentConstruct = _superagent2.default.post(this.getStandardOrigin() + endpoint.url).query(params).send(body);\n\t  return xdr.call(this, superagentConstruct, endpoint, callback);\n\t}\n\n\tfunction del(params, endpoint, callback) {\n\t  var superagentConstruct = _superagent2.default.delete(this.getStandardOrigin() + endpoint.url).query(params);\n\t  return xdr.call(this, superagentConstruct, endpoint, callback);\n\t}\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Root reference for iframes.\n\t */\n\n\tvar root;\n\tif (typeof window !== 'undefined') { // Browser window\n\t  root = window;\n\t} else if (typeof self !== 'undefined') { // Web Worker\n\t  root = self;\n\t} else { // Other environments\n\t  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n\t  root = this;\n\t}\n\n\tvar Emitter = __webpack_require__(43);\n\tvar RequestBase = __webpack_require__(44);\n\tvar isObject = __webpack_require__(45);\n\tvar ResponseBase = __webpack_require__(46);\n\tvar Agent = __webpack_require__(48);\n\n\t/**\n\t * Noop.\n\t */\n\n\tfunction noop(){};\n\n\t/**\n\t * Expose `request`.\n\t */\n\n\tvar request = exports = module.exports = function(method, url) {\n\t  // callback\n\t  if ('function' == typeof url) {\n\t    return new exports.Request('GET', method).end(url);\n\t  }\n\n\t  // url first\n\t  if (1 == arguments.length) {\n\t    return new exports.Request('GET', method);\n\t  }\n\n\t  return new exports.Request(method, url);\n\t}\n\n\texports.Request = Request;\n\n\t/**\n\t * Determine XHR.\n\t */\n\n\trequest.getXHR = function () {\n\t  if (root.XMLHttpRequest\n\t      && (!root.location || 'file:' != root.location.protocol\n\t          || !root.ActiveXObject)) {\n\t    return new XMLHttpRequest;\n\t  } else {\n\t    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n\t    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n\t  }\n\t  throw Error(\"Browser-only version of superagent could not find XHR\");\n\t};\n\n\t/**\n\t * Removes leading and trailing whitespace, added to support IE.\n\t *\n\t * @param {String} s\n\t * @return {String}\n\t * @api private\n\t */\n\n\tvar trim = ''.trim\n\t  ? function(s) { return s.trim(); }\n\t  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n\t/**\n\t * Serialize the given `obj`.\n\t *\n\t * @param {Object} obj\n\t * @return {String}\n\t * @api private\n\t */\n\n\tfunction serialize(obj) {\n\t  if (!isObject(obj)) return obj;\n\t  var pairs = [];\n\t  for (var key in obj) {\n\t    pushEncodedKeyValuePair(pairs, key, obj[key]);\n\t  }\n\t  return pairs.join('&');\n\t}\n\n\t/**\n\t * Helps 'serialize' with serializing arrays.\n\t * Mutates the pairs array.\n\t *\n\t * @param {Array} pairs\n\t * @param {String} key\n\t * @param {Mixed} val\n\t */\n\n\tfunction pushEncodedKeyValuePair(pairs, key, val) {\n\t  if (val != null) {\n\t    if (Array.isArray(val)) {\n\t      val.forEach(function(v) {\n\t        pushEncodedKeyValuePair(pairs, key, v);\n\t      });\n\t    } else if (isObject(val)) {\n\t      for(var subkey in val) {\n\t        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n\t      }\n\t    } else {\n\t      pairs.push(encodeURIComponent(key)\n\t        + '=' + encodeURIComponent(val));\n\t    }\n\t  } else if (val === null) {\n\t    pairs.push(encodeURIComponent(key));\n\t  }\n\t}\n\n\t/**\n\t * Expose serialization method.\n\t */\n\n\trequest.serializeObject = serialize;\n\n\t/**\n\t  * Parse the given x-www-form-urlencoded `str`.\n\t  *\n\t  * @param {String} str\n\t  * @return {Object}\n\t  * @api private\n\t  */\n\n\tfunction parseString(str) {\n\t  var obj = {};\n\t  var pairs = str.split('&');\n\t  var pair;\n\t  var pos;\n\n\t  for (var i = 0, len = pairs.length; i < len; ++i) {\n\t    pair = pairs[i];\n\t    pos = pair.indexOf('=');\n\t    if (pos == -1) {\n\t      obj[decodeURIComponent(pair)] = '';\n\t    } else {\n\t      obj[decodeURIComponent(pair.slice(0, pos))] =\n\t        decodeURIComponent(pair.slice(pos + 1));\n\t    }\n\t  }\n\n\t  return obj;\n\t}\n\n\t/**\n\t * Expose parser.\n\t */\n\n\trequest.parseString = parseString;\n\n\t/**\n\t * Default MIME type map.\n\t *\n\t *     superagent.types.xml = 'application/xml';\n\t *\n\t */\n\n\trequest.types = {\n\t  html: 'text/html',\n\t  json: 'application/json',\n\t  xml: 'text/xml',\n\t  urlencoded: 'application/x-www-form-urlencoded',\n\t  'form': 'application/x-www-form-urlencoded',\n\t  'form-data': 'application/x-www-form-urlencoded'\n\t};\n\n\t/**\n\t * Default serialization map.\n\t *\n\t *     superagent.serialize['application/xml'] = function(obj){\n\t *       return 'generated xml here';\n\t *     };\n\t *\n\t */\n\n\trequest.serialize = {\n\t  'application/x-www-form-urlencoded': serialize,\n\t  'application/json': JSON.stringify,\n\t};\n\n\t/**\n\t  * Default parsers.\n\t  *\n\t  *     superagent.parse['application/xml'] = function(str){\n\t  *       return { object parsed from str };\n\t  *     };\n\t  *\n\t  */\n\n\trequest.parse = {\n\t  'application/x-www-form-urlencoded': parseString,\n\t  'application/json': JSON.parse,\n\t};\n\n\t/**\n\t * Parse the given header `str` into\n\t * an object containing the mapped fields.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\n\tfunction parseHeader(str) {\n\t  var lines = str.split(/\\r?\\n/);\n\t  var fields = {};\n\t  var index;\n\t  var line;\n\t  var field;\n\t  var val;\n\n\t  for (var i = 0, len = lines.length; i < len; ++i) {\n\t    line = lines[i];\n\t    index = line.indexOf(':');\n\t    if (index === -1) { // could be empty line, just skip it\n\t      continue;\n\t    }\n\t    field = line.slice(0, index).toLowerCase();\n\t    val = trim(line.slice(index + 1));\n\t    fields[field] = val;\n\t  }\n\n\t  return fields;\n\t}\n\n\t/**\n\t * Check if `mime` is json or has +json structured syntax suffix.\n\t *\n\t * @param {String} mime\n\t * @return {Boolean}\n\t * @api private\n\t */\n\n\tfunction isJSON(mime) {\n\t  // should match /json or +json\n\t  // but not /json-seq\n\t  return /[\\/+]json($|[^-\\w])/.test(mime);\n\t}\n\n\t/**\n\t * Initialize a new `Response` with the given `xhr`.\n\t *\n\t *  - set flags (.ok, .error, etc)\n\t *  - parse header\n\t *\n\t * Examples:\n\t *\n\t *  Aliasing `superagent` as `request` is nice:\n\t *\n\t *      request = superagent;\n\t *\n\t *  We can use the promise-like API, or pass callbacks:\n\t *\n\t *      request.get('/').end(function(res){});\n\t *      request.get('/', function(res){});\n\t *\n\t *  Sending data can be chained:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t *  Or passed to `.send()`:\n\t *\n\t *      request\n\t *        .post('/user')\n\t *        .send({ name: 'tj' }, function(res){});\n\t *\n\t *  Or passed to `.post()`:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' })\n\t *        .end(function(res){});\n\t *\n\t * Or further reduced to a single call for simple cases:\n\t *\n\t *      request\n\t *        .post('/user', { name: 'tj' }, function(res){});\n\t *\n\t * @param {XMLHTTPRequest} xhr\n\t * @param {Object} options\n\t * @api private\n\t */\n\n\tfunction Response(req) {\n\t  this.req = req;\n\t  this.xhr = this.req.xhr;\n\t  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n\t  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n\t     ? this.xhr.responseText\n\t     : null;\n\t  this.statusText = this.req.xhr.statusText;\n\t  var status = this.xhr.status;\n\t  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n\t  if (status === 1223) {\n\t    status = 204;\n\t  }\n\t  this._setStatusProperties(status);\n\t  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n\t  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n\t  // getResponseHeader still works. so we get content-type even if getting\n\t  // other headers fails.\n\t  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n\t  this._setHeaderProperties(this.header);\n\n\t  if (null === this.text && req._responseType) {\n\t    this.body = this.xhr.response;\n\t  } else {\n\t    this.body = this.req.method != 'HEAD'\n\t      ? this._parseBody(this.text ? this.text : this.xhr.response)\n\t      : null;\n\t  }\n\t}\n\n\tResponseBase(Response.prototype);\n\n\t/**\n\t * Parse the given body `str`.\n\t *\n\t * Used for auto-parsing of bodies. Parsers\n\t * are defined on the `superagent.parse` object.\n\t *\n\t * @param {String} str\n\t * @return {Mixed}\n\t * @api private\n\t */\n\n\tResponse.prototype._parseBody = function(str) {\n\t  var parse = request.parse[this.type];\n\t  if (this.req._parser) {\n\t    return this.req._parser(this, str);\n\t  }\n\t  if (!parse && isJSON(this.type)) {\n\t    parse = request.parse['application/json'];\n\t  }\n\t  return parse && str && (str.length || str instanceof Object)\n\t    ? parse(str)\n\t    : null;\n\t};\n\n\t/**\n\t * Return an `Error` representative of this response.\n\t *\n\t * @return {Error}\n\t * @api public\n\t */\n\n\tResponse.prototype.toError = function(){\n\t  var req = this.req;\n\t  var method = req.method;\n\t  var url = req.url;\n\n\t  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n\t  var err = new Error(msg);\n\t  err.status = this.status;\n\t  err.method = method;\n\t  err.url = url;\n\n\t  return err;\n\t};\n\n\t/**\n\t * Expose `Response`.\n\t */\n\n\trequest.Response = Response;\n\n\t/**\n\t * Initialize a new `Request` with the given `method` and `url`.\n\t *\n\t * @param {String} method\n\t * @param {String} url\n\t * @api public\n\t */\n\n\tfunction Request(method, url) {\n\t  var self = this;\n\t  this._query = this._query || [];\n\t  this.method = method;\n\t  this.url = url;\n\t  this.header = {}; // preserves header name case\n\t  this._header = {}; // coerces header names to lowercase\n\t  this.on('end', function(){\n\t    var err = null;\n\t    var res = null;\n\n\t    try {\n\t      res = new Response(self);\n\t    } catch(e) {\n\t      err = new Error('Parser is unable to parse the response');\n\t      err.parse = true;\n\t      err.original = e;\n\t      // issue #675: return the raw response if the response parsing fails\n\t      if (self.xhr) {\n\t        // ie9 doesn't have 'response' property\n\t        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;\n\t        // issue #876: return the http status code if the response parsing fails\n\t        err.status = self.xhr.status ? self.xhr.status : null;\n\t        err.statusCode = err.status; // backwards-compat only\n\t      } else {\n\t        err.rawResponse = null;\n\t        err.status = null;\n\t      }\n\n\t      return self.callback(err);\n\t    }\n\n\t    self.emit('response', res);\n\n\t    var new_err;\n\t    try {\n\t      if (!self._isResponseOK(res)) {\n\t        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n\t      }\n\t    } catch(custom_err) {\n\t      new_err = custom_err; // ok() callback can throw\n\t    }\n\n\t    // #1000 don't catch errors from the callback to avoid double calling it\n\t    if (new_err) {\n\t      new_err.original = err;\n\t      new_err.response = res;\n\t      new_err.status = res.status;\n\t      self.callback(new_err, res);\n\t    } else {\n\t      self.callback(null, res);\n\t    }\n\t  });\n\t}\n\n\t/**\n\t * Mixin `Emitter` and `RequestBase`.\n\t */\n\n\tEmitter(Request.prototype);\n\tRequestBase(Request.prototype);\n\n\t/**\n\t * Set Content-Type to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.xml = 'application/xml';\n\t *\n\t *      request.post('/')\n\t *        .type('xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t *      request.post('/')\n\t *        .type('application/xml')\n\t *        .send(xmlstring)\n\t *        .end(callback);\n\t *\n\t * @param {String} type\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequest.prototype.type = function(type){\n\t  this.set('Content-Type', request.types[type] || type);\n\t  return this;\n\t};\n\n\t/**\n\t * Set Accept to `type`, mapping values from `request.types`.\n\t *\n\t * Examples:\n\t *\n\t *      superagent.types.json = 'application/json';\n\t *\n\t *      request.get('/agent')\n\t *        .accept('json')\n\t *        .end(callback);\n\t *\n\t *      request.get('/agent')\n\t *        .accept('application/json')\n\t *        .end(callback);\n\t *\n\t * @param {String} accept\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequest.prototype.accept = function(type){\n\t  this.set('Accept', request.types[type] || type);\n\t  return this;\n\t};\n\n\t/**\n\t * Set Authorization field value with `user` and `pass`.\n\t *\n\t * @param {String} user\n\t * @param {String} [pass] optional in case of using 'bearer' as type\n\t * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequest.prototype.auth = function(user, pass, options){\n\t  if (1 === arguments.length) pass = '';\n\t  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options\n\t    options = pass;\n\t    pass = '';\n\t  }\n\t  if (!options) {\n\t    options = {\n\t      type: 'function' === typeof btoa ? 'basic' : 'auto',\n\t    };\n\t  }\n\n\t  var encoder = function(string) {\n\t    if ('function' === typeof btoa) {\n\t      return btoa(string);\n\t    }\n\t    throw new Error('Cannot use basic auth, btoa is not a function');\n\t  };\n\n\t  return this._auth(user, pass, options, encoder);\n\t};\n\n\t/**\n\t * Add query-string `val`.\n\t *\n\t * Examples:\n\t *\n\t *   request.get('/shoes')\n\t *     .query('size=10')\n\t *     .query({ color: 'blue' })\n\t *\n\t * @param {Object|String} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequest.prototype.query = function(val){\n\t  if ('string' != typeof val) val = serialize(val);\n\t  if (val) this._query.push(val);\n\t  return this;\n\t};\n\n\t/**\n\t * Queue the given `file` as an attachment to the specified `field`,\n\t * with optional `options` (or filename).\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String} field\n\t * @param {Blob|File} file\n\t * @param {String|Object} options\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequest.prototype.attach = function(field, file, options){\n\t  if (file) {\n\t    if (this._data) {\n\t      throw Error(\"superagent can't mix .send() and .attach()\");\n\t    }\n\n\t    this._getFormData().append(field, file, options || file.name);\n\t  }\n\t  return this;\n\t};\n\n\tRequest.prototype._getFormData = function(){\n\t  if (!this._formData) {\n\t    this._formData = new root.FormData();\n\t  }\n\t  return this._formData;\n\t};\n\n\t/**\n\t * Invoke the callback with `err` and `res`\n\t * and handle arity check.\n\t *\n\t * @param {Error} err\n\t * @param {Response} res\n\t * @api private\n\t */\n\n\tRequest.prototype.callback = function(err, res){\n\t  if (this._shouldRetry(err, res)) {\n\t    return this._retry();\n\t  }\n\n\t  var fn = this._callback;\n\t  this.clearTimeout();\n\n\t  if (err) {\n\t    if (this._maxRetries) err.retries = this._retries - 1;\n\t    this.emit('error', err);\n\t  }\n\n\t  fn(err, res);\n\t};\n\n\t/**\n\t * Invoke callback with x-domain error.\n\t *\n\t * @api private\n\t */\n\n\tRequest.prototype.crossDomainError = function(){\n\t  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n\t  err.crossDomain = true;\n\n\t  err.status = this.status;\n\t  err.method = this.method;\n\t  err.url = this.url;\n\n\t  this.callback(err);\n\t};\n\n\t// This only warns, because the request is still likely to work\n\tRequest.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){\n\t  console.warn(\"This is not supported in browser version of superagent\");\n\t  return this;\n\t};\n\n\t// This throws, because it can't send/receive data as expected\n\tRequest.prototype.pipe = Request.prototype.write = function(){\n\t  throw Error(\"Streaming is not supported in browser version of superagent\");\n\t};\n\n\t/**\n\t * Check if `obj` is a host object,\n\t * we don't want to serialize these :)\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\tRequest.prototype._isHost = function _isHost(obj) {\n\t  // Native objects stringify to [object File], [object Blob], [object FormData], etc.\n\t  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';\n\t}\n\n\t/**\n\t * Initiate request, invoking callback `fn(res)`\n\t * with an instanceof `Response`.\n\t *\n\t * @param {Function} fn\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequest.prototype.end = function(fn){\n\t  if (this._endCalled) {\n\t    console.warn(\"Warning: .end() was called twice. This is not supported in superagent\");\n\t  }\n\t  this._endCalled = true;\n\n\t  // store callback\n\t  this._callback = fn || noop;\n\n\t  // querystring\n\t  this._finalizeQueryString();\n\n\t  return this._end();\n\t};\n\n\tRequest.prototype._end = function() {\n\t  var self = this;\n\t  var xhr = (this.xhr = request.getXHR());\n\t  var data = this._formData || this._data;\n\n\t  this._setTimeouts();\n\n\t  // state change\n\t  xhr.onreadystatechange = function(){\n\t    var readyState = xhr.readyState;\n\t    if (readyState >= 2 && self._responseTimeoutTimer) {\n\t      clearTimeout(self._responseTimeoutTimer);\n\t    }\n\t    if (4 != readyState) {\n\t      return;\n\t    }\n\n\t    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n\t    // result in the error \"Could not complete the operation due to error c00c023f\"\n\t    var status;\n\t    try { status = xhr.status } catch(e) { status = 0; }\n\n\t    if (!status) {\n\t      if (self.timedout || self._aborted) return;\n\t      return self.crossDomainError();\n\t    }\n\t    self.emit('end');\n\t  };\n\n\t  // progress\n\t  var handleProgress = function(direction, e) {\n\t    if (e.total > 0) {\n\t      e.percent = e.loaded / e.total * 100;\n\t    }\n\t    e.direction = direction;\n\t    self.emit('progress', e);\n\t  };\n\t  if (this.hasListeners('progress')) {\n\t    try {\n\t      xhr.onprogress = handleProgress.bind(null, 'download');\n\t      if (xhr.upload) {\n\t        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n\t      }\n\t    } catch(e) {\n\t      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n\t      // Reported here:\n\t      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n\t    }\n\t  }\n\n\t  // initiate request\n\t  try {\n\t    if (this.username && this.password) {\n\t      xhr.open(this.method, this.url, true, this.username, this.password);\n\t    } else {\n\t      xhr.open(this.method, this.url, true);\n\t    }\n\t  } catch (err) {\n\t    // see #1149\n\t    return this.callback(err);\n\t  }\n\n\t  // CORS\n\t  if (this._withCredentials) xhr.withCredentials = true;\n\n\t  // body\n\t  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n\t    // serialize stuff\n\t    var contentType = this._header['content-type'];\n\t    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n\t    if (!serialize && isJSON(contentType)) {\n\t      serialize = request.serialize['application/json'];\n\t    }\n\t    if (serialize) data = serialize(data);\n\t  }\n\n\t  // set header fields\n\t  for (var field in this.header) {\n\t    if (null == this.header[field]) continue;\n\n\t    if (this.header.hasOwnProperty(field))\n\t      xhr.setRequestHeader(field, this.header[field]);\n\t  }\n\n\t  if (this._responseType) {\n\t    xhr.responseType = this._responseType;\n\t  }\n\n\t  // send stuff\n\t  this.emit('request', this);\n\n\t  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n\t  // We need null here if data is undefined\n\t  xhr.send(typeof data !== 'undefined' ? data : null);\n\t  return this;\n\t};\n\n\trequest.agent = function() {\n\t  return new Agent();\n\t};\n\n\t[\"GET\", \"POST\", \"OPTIONS\", \"PATCH\", \"PUT\", \"DELETE\"].forEach(function(method) {\n\t  Agent.prototype[method.toLowerCase()] = function(url, fn) {\n\t    var req = new request.Request(method, url);\n\t    this._setDefaults(req);\n\t    if (fn) {\n\t      req.end(fn);\n\t    }\n\t    return req;\n\t  };\n\t});\n\n\tAgent.prototype.del = Agent.prototype['delete'];\n\n\t/**\n\t * GET `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\n\trequest.get = function(url, data, fn) {\n\t  var req = request('GET', url);\n\t  if ('function' == typeof data) (fn = data), (data = null);\n\t  if (data) req.query(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\n\t/**\n\t * HEAD `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\n\trequest.head = function(url, data, fn) {\n\t  var req = request('HEAD', url);\n\t  if ('function' == typeof data) (fn = data), (data = null);\n\t  if (data) req.query(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\n\t/**\n\t * OPTIONS query to `url` with optional callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\n\trequest.options = function(url, data, fn) {\n\t  var req = request('OPTIONS', url);\n\t  if ('function' == typeof data) (fn = data), (data = null);\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\n\t/**\n\t * DELETE `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} [data]\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\n\tfunction del(url, data, fn) {\n\t  var req = request('DELETE', url);\n\t  if ('function' == typeof data) (fn = data), (data = null);\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t}\n\n\trequest['del'] = del;\n\trequest['delete'] = del;\n\n\t/**\n\t * PATCH `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} [data]\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\n\trequest.patch = function(url, data, fn) {\n\t  var req = request('PATCH', url);\n\t  if ('function' == typeof data) (fn = data), (data = null);\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\n\t/**\n\t * POST `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed} [data]\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\n\trequest.post = function(url, data, fn) {\n\t  var req = request('POST', url);\n\t  if ('function' == typeof data) (fn = data), (data = null);\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\n\t/**\n\t * PUT `url` with optional `data` and callback `fn(res)`.\n\t *\n\t * @param {String} url\n\t * @param {Mixed|Function} [data] or fn\n\t * @param {Function} [fn]\n\t * @return {Request}\n\t * @api public\n\t */\n\n\trequest.put = function(url, data, fn) {\n\t  var req = request('PUT', url);\n\t  if ('function' == typeof data) (fn = data), (data = null);\n\t  if (data) req.send(data);\n\t  if (fn) req.end(fn);\n\t  return req;\n\t};\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t\r\n\t/**\r\n\t * Expose `Emitter`.\r\n\t */\r\n\r\n\tif (true) {\r\n\t  module.exports = Emitter;\r\n\t}\r\n\r\n\t/**\r\n\t * Initialize a new `Emitter`.\r\n\t *\r\n\t * @api public\r\n\t */\r\n\r\n\tfunction Emitter(obj) {\r\n\t  if (obj) return mixin(obj);\r\n\t};\r\n\r\n\t/**\r\n\t * Mixin the emitter properties.\r\n\t *\r\n\t * @param {Object} obj\r\n\t * @return {Object}\r\n\t * @api private\r\n\t */\r\n\r\n\tfunction mixin(obj) {\r\n\t  for (var key in Emitter.prototype) {\r\n\t    obj[key] = Emitter.prototype[key];\r\n\t  }\r\n\t  return obj;\r\n\t}\r\n\r\n\t/**\r\n\t * Listen on the given `event` with `fn`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.on =\r\n\tEmitter.prototype.addEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n\t    .push(fn);\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Adds an `event` listener that will be invoked a single\r\n\t * time then automatically removed.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.once = function(event, fn){\r\n\t  function on() {\r\n\t    this.off(event, on);\r\n\t    fn.apply(this, arguments);\r\n\t  }\r\n\r\n\t  on.fn = fn;\r\n\t  this.on(event, on);\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Remove the given callback for `event` or all\r\n\t * registered callbacks.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Function} fn\r\n\t * @return {Emitter}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.off =\r\n\tEmitter.prototype.removeListener =\r\n\tEmitter.prototype.removeAllListeners =\r\n\tEmitter.prototype.removeEventListener = function(event, fn){\r\n\t  this._callbacks = this._callbacks || {};\r\n\r\n\t  // all\r\n\t  if (0 == arguments.length) {\r\n\t    this._callbacks = {};\r\n\t    return this;\r\n\t  }\r\n\r\n\t  // specific event\r\n\t  var callbacks = this._callbacks['$' + event];\r\n\t  if (!callbacks) return this;\r\n\r\n\t  // remove all handlers\r\n\t  if (1 == arguments.length) {\r\n\t    delete this._callbacks['$' + event];\r\n\t    return this;\r\n\t  }\r\n\r\n\t  // remove specific handler\r\n\t  var cb;\r\n\t  for (var i = 0; i < callbacks.length; i++) {\r\n\t    cb = callbacks[i];\r\n\t    if (cb === fn || cb.fn === fn) {\r\n\t      callbacks.splice(i, 1);\r\n\t      break;\r\n\t    }\r\n\t  }\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Emit `event` with the given args.\r\n\t *\r\n\t * @param {String} event\r\n\t * @param {Mixed} ...\r\n\t * @return {Emitter}\r\n\t */\r\n\r\n\tEmitter.prototype.emit = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  var args = [].slice.call(arguments, 1)\r\n\t    , callbacks = this._callbacks['$' + event];\r\n\r\n\t  if (callbacks) {\r\n\t    callbacks = callbacks.slice(0);\r\n\t    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n\t      callbacks[i].apply(this, args);\r\n\t    }\r\n\t  }\r\n\r\n\t  return this;\r\n\t};\r\n\r\n\t/**\r\n\t * Return array of callbacks for `event`.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Array}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.listeners = function(event){\r\n\t  this._callbacks = this._callbacks || {};\r\n\t  return this._callbacks['$' + event] || [];\r\n\t};\r\n\r\n\t/**\r\n\t * Check if this emitter has `event` handlers.\r\n\t *\r\n\t * @param {String} event\r\n\t * @return {Boolean}\r\n\t * @api public\r\n\t */\r\n\r\n\tEmitter.prototype.hasListeners = function(event){\r\n\t  return !! this.listeners(event).length;\r\n\t};\r\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\t/**\n\t * Module of mixed-in functions shared between node and client code\n\t */\n\tvar isObject = __webpack_require__(45);\n\n\t/**\n\t * Expose `RequestBase`.\n\t */\n\n\tmodule.exports = RequestBase;\n\n\t/**\n\t * Initialize a new `RequestBase`.\n\t *\n\t * @api public\n\t */\n\n\tfunction RequestBase(obj) {\n\t  if (obj) return mixin(obj);\n\t}\n\n\t/**\n\t * Mixin the prototype properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\n\tfunction mixin(obj) {\n\t  for (var key in RequestBase.prototype) {\n\t    obj[key] = RequestBase.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\n\t/**\n\t * Clear previous timeout.\n\t *\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.clearTimeout = function _clearTimeout(){\n\t  clearTimeout(this._timer);\n\t  clearTimeout(this._responseTimeoutTimer);\n\t  delete this._timer;\n\t  delete this._responseTimeoutTimer;\n\t  return this;\n\t};\n\n\t/**\n\t * Override default response body parser\n\t *\n\t * This function will be called to convert incoming data into request.body\n\t *\n\t * @param {Function}\n\t * @api public\n\t */\n\n\tRequestBase.prototype.parse = function parse(fn){\n\t  this._parser = fn;\n\t  return this;\n\t};\n\n\t/**\n\t * Set format of binary response body.\n\t * In browser valid formats are 'blob' and 'arraybuffer',\n\t * which return Blob and ArrayBuffer, respectively.\n\t *\n\t * In Node all values result in Buffer.\n\t *\n\t * Examples:\n\t *\n\t *      req.get('/')\n\t *        .responseType('blob')\n\t *        .end(callback);\n\t *\n\t * @param {String} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.responseType = function(val){\n\t  this._responseType = val;\n\t  return this;\n\t};\n\n\t/**\n\t * Override default request body serializer\n\t *\n\t * This function will be called to convert data set via .send or .attach into payload to send\n\t *\n\t * @param {Function}\n\t * @api public\n\t */\n\n\tRequestBase.prototype.serialize = function serialize(fn){\n\t  this._serializer = fn;\n\t  return this;\n\t};\n\n\t/**\n\t * Set timeouts.\n\t *\n\t * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.\n\t * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.\n\t *\n\t * Value of 0 or false means no timeout.\n\t *\n\t * @param {Number|Object} ms or {response, deadline}\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.timeout = function timeout(options){\n\t  if (!options || 'object' !== typeof options) {\n\t    this._timeout = options;\n\t    this._responseTimeout = 0;\n\t    return this;\n\t  }\n\n\t  for(var option in options) {\n\t    switch(option) {\n\t      case 'deadline':\n\t        this._timeout = options.deadline;\n\t        break;\n\t      case 'response':\n\t        this._responseTimeout = options.response;\n\t        break;\n\t      default:\n\t        console.warn(\"Unknown timeout option\", option);\n\t    }\n\t  }\n\t  return this;\n\t};\n\n\t/**\n\t * Set number of retry attempts on error.\n\t *\n\t * Failed requests will be retried 'count' times if timeout or err.code >= 500.\n\t *\n\t * @param {Number} count\n\t * @param {Function} [fn]\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.retry = function retry(count, fn){\n\t  // Default to 1 if no count passed or true\n\t  if (arguments.length === 0 || count === true) count = 1;\n\t  if (count <= 0) count = 0;\n\t  this._maxRetries = count;\n\t  this._retries = 0;\n\t  this._retryCallback = fn;\n\t  return this;\n\t};\n\n\tvar ERROR_CODES = [\n\t  'ECONNRESET',\n\t  'ETIMEDOUT',\n\t  'EADDRINFO',\n\t  'ESOCKETTIMEDOUT'\n\t];\n\n\t/**\n\t * Determine if a request should be retried.\n\t * (Borrowed from segmentio/superagent-retry)\n\t *\n\t * @param {Error} err\n\t * @param {Response} [res]\n\t * @returns {Boolean}\n\t */\n\tRequestBase.prototype._shouldRetry = function(err, res) {\n\t  if (!this._maxRetries || this._retries++ >= this._maxRetries) {\n\t    return false;\n\t  }\n\t  if (this._retryCallback) {\n\t    try {\n\t      var override = this._retryCallback(err, res);\n\t      if (override === true) return true;\n\t      if (override === false) return false;\n\t      // undefined falls back to defaults\n\t    } catch(e) {\n\t      console.error(e);\n\t    }\n\t  }\n\t  if (res && res.status && res.status >= 500 && res.status != 501) return true;\n\t  if (err) {\n\t    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;\n\t    // Superagent timeout\n\t    if (err.timeout && err.code == 'ECONNABORTED') return true;\n\t    if (err.crossDomain) return true;\n\t  }\n\t  return false;\n\t};\n\n\t/**\n\t * Retry request\n\t *\n\t * @return {Request} for chaining\n\t * @api private\n\t */\n\n\tRequestBase.prototype._retry = function() {\n\n\t  this.clearTimeout();\n\n\t  // node\n\t  if (this.req) {\n\t    this.req = null;\n\t    this.req = this.request();\n\t  }\n\n\t  this._aborted = false;\n\t  this.timedout = false;\n\n\t  return this._end();\n\t};\n\n\t/**\n\t * Promise support\n\t *\n\t * @param {Function} resolve\n\t * @param {Function} [reject]\n\t * @return {Request}\n\t */\n\n\tRequestBase.prototype.then = function then(resolve, reject) {\n\t  if (!this._fullfilledPromise) {\n\t    var self = this;\n\t    if (this._endCalled) {\n\t      console.warn(\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\");\n\t    }\n\t    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {\n\t      self.end(function(err, res) {\n\t        if (err) innerReject(err);\n\t        else innerResolve(res);\n\t      });\n\t    });\n\t  }\n\t  return this._fullfilledPromise.then(resolve, reject);\n\t};\n\n\tRequestBase.prototype.catch = function(cb) {\n\t  return this.then(undefined, cb);\n\t};\n\n\t/**\n\t * Allow for extension\n\t */\n\n\tRequestBase.prototype.use = function use(fn) {\n\t  fn(this);\n\t  return this;\n\t};\n\n\tRequestBase.prototype.ok = function(cb) {\n\t  if ('function' !== typeof cb) throw Error(\"Callback required\");\n\t  this._okCallback = cb;\n\t  return this;\n\t};\n\n\tRequestBase.prototype._isResponseOK = function(res) {\n\t  if (!res) {\n\t    return false;\n\t  }\n\n\t  if (this._okCallback) {\n\t    return this._okCallback(res);\n\t  }\n\n\t  return res.status >= 200 && res.status < 300;\n\t};\n\n\t/**\n\t * Get request header `field`.\n\t * Case-insensitive.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api public\n\t */\n\n\tRequestBase.prototype.get = function(field){\n\t  return this._header[field.toLowerCase()];\n\t};\n\n\t/**\n\t * Get case-insensitive header `field` value.\n\t * This is a deprecated internal API. Use `.get(field)` instead.\n\t *\n\t * (getHeader is no longer used internally by the superagent code base)\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api private\n\t * @deprecated\n\t */\n\n\tRequestBase.prototype.getHeader = RequestBase.prototype.get;\n\n\t/**\n\t * Set header `field` to `val`, or multiple fields with one object.\n\t * Case-insensitive.\n\t *\n\t * Examples:\n\t *\n\t *      req.get('/')\n\t *        .set('Accept', 'application/json')\n\t *        .set('X-API-Key', 'foobar')\n\t *        .end(callback);\n\t *\n\t *      req.get('/')\n\t *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n\t *        .end(callback);\n\t *\n\t * @param {String|Object} field\n\t * @param {String} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.set = function(field, val){\n\t  if (isObject(field)) {\n\t    for (var key in field) {\n\t      this.set(key, field[key]);\n\t    }\n\t    return this;\n\t  }\n\t  this._header[field.toLowerCase()] = val;\n\t  this.header[field] = val;\n\t  return this;\n\t};\n\n\t/**\n\t * Remove header `field`.\n\t * Case-insensitive.\n\t *\n\t * Example:\n\t *\n\t *      req.get('/')\n\t *        .unset('User-Agent')\n\t *        .end(callback);\n\t *\n\t * @param {String} field\n\t */\n\tRequestBase.prototype.unset = function(field){\n\t  delete this._header[field.toLowerCase()];\n\t  delete this.header[field];\n\t  return this;\n\t};\n\n\t/**\n\t * Write the field `name` and `val`, or multiple fields with one object\n\t * for \"multipart/form-data\" request bodies.\n\t *\n\t * ``` js\n\t * request.post('/upload')\n\t *   .field('foo', 'bar')\n\t *   .end(callback);\n\t *\n\t * request.post('/upload')\n\t *   .field({ foo: 'bar', baz: 'qux' })\n\t *   .end(callback);\n\t * ```\n\t *\n\t * @param {String|Object} name\n\t * @param {String|Blob|File|Buffer|fs.ReadStream} val\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\tRequestBase.prototype.field = function(name, val) {\n\t  // name should be either a string or an object.\n\t  if (null === name || undefined === name) {\n\t    throw new Error('.field(name, val) name can not be empty');\n\t  }\n\n\t  if (this._data) {\n\t    console.error(\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\");\n\t  }\n\n\t  if (isObject(name)) {\n\t    for (var key in name) {\n\t      this.field(key, name[key]);\n\t    }\n\t    return this;\n\t  }\n\n\t  if (Array.isArray(val)) {\n\t    for (var i in val) {\n\t      this.field(name, val[i]);\n\t    }\n\t    return this;\n\t  }\n\n\t  // val should be defined now\n\t  if (null === val || undefined === val) {\n\t    throw new Error('.field(name, val) val can not be empty');\n\t  }\n\t  if ('boolean' === typeof val) {\n\t    val = '' + val;\n\t  }\n\t  this._getFormData().append(name, val);\n\t  return this;\n\t};\n\n\t/**\n\t * Abort the request, and clear potential timeout.\n\t *\n\t * @return {Request}\n\t * @api public\n\t */\n\tRequestBase.prototype.abort = function(){\n\t  if (this._aborted) {\n\t    return this;\n\t  }\n\t  this._aborted = true;\n\t  this.xhr && this.xhr.abort(); // browser\n\t  this.req && this.req.abort(); // node\n\t  this.clearTimeout();\n\t  this.emit('abort');\n\t  return this;\n\t};\n\n\tRequestBase.prototype._auth = function(user, pass, options, base64Encoder) {\n\t  switch (options.type) {\n\t    case 'basic':\n\t      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));\n\t      break;\n\n\t    case 'auto':\n\t      this.username = user;\n\t      this.password = pass;\n\t      break;\n\n\t    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })\n\t      this.set('Authorization', 'Bearer ' + user);\n\t      break;\n\t  }\n\t  return this;\n\t};\n\n\t/**\n\t * Enable transmission of cookies with x-domain requests.\n\t *\n\t * Note that for this to work the origin must not be\n\t * using \"Access-Control-Allow-Origin\" with a wildcard,\n\t * and also must set \"Access-Control-Allow-Credentials\"\n\t * to \"true\".\n\t *\n\t * @api public\n\t */\n\n\tRequestBase.prototype.withCredentials = function(on) {\n\t  // This is browser-only functionality. Node side is no-op.\n\t  if (on == undefined) on = true;\n\t  this._withCredentials = on;\n\t  return this;\n\t};\n\n\t/**\n\t * Set the max redirects to `n`. Does noting in browser XHR implementation.\n\t *\n\t * @param {Number} n\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.redirects = function(n){\n\t  this._maxRedirects = n;\n\t  return this;\n\t};\n\n\t/**\n\t * Maximum size of buffered response body, in bytes. Counts uncompressed size.\n\t * Default 200MB.\n\t *\n\t * @param {Number} n\n\t * @return {Request} for chaining\n\t */\n\tRequestBase.prototype.maxResponseSize = function(n){\n\t  if ('number' !== typeof n) {\n\t    throw TypeError(\"Invalid argument\");\n\t  }\n\t  this._maxResponseSize = n;\n\t  return this;\n\t};\n\n\t/**\n\t * Convert to a plain javascript object (not JSON string) of scalar properties.\n\t * Note as this method is designed to return a useful non-this value,\n\t * it cannot be chained.\n\t *\n\t * @return {Object} describing method, url, and data of this request\n\t * @api public\n\t */\n\n\tRequestBase.prototype.toJSON = function() {\n\t  return {\n\t    method: this.method,\n\t    url: this.url,\n\t    data: this._data,\n\t    headers: this._header,\n\t  };\n\t};\n\n\t/**\n\t * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n\t * an object is given.\n\t *\n\t * Examples:\n\t *\n\t *       // manual json\n\t *       request.post('/user')\n\t *         .type('json')\n\t *         .send('{\"name\":\"tj\"}')\n\t *         .end(callback)\n\t *\n\t *       // auto json\n\t *       request.post('/user')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // manual x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send('name=tj')\n\t *         .end(callback)\n\t *\n\t *       // auto x-www-form-urlencoded\n\t *       request.post('/user')\n\t *         .type('form')\n\t *         .send({ name: 'tj' })\n\t *         .end(callback)\n\t *\n\t *       // defaults to x-www-form-urlencoded\n\t *      request.post('/user')\n\t *        .send('name=tobi')\n\t *        .send('species=ferret')\n\t *        .end(callback)\n\t *\n\t * @param {String|Object} data\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.send = function(data){\n\t  var isObj = isObject(data);\n\t  var type = this._header['content-type'];\n\n\t  if (this._formData) {\n\t    console.error(\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\");\n\t  }\n\n\t  if (isObj && !this._data) {\n\t    if (Array.isArray(data)) {\n\t      this._data = [];\n\t    } else if (!this._isHost(data)) {\n\t      this._data = {};\n\t    }\n\t  } else if (data && this._data && this._isHost(this._data)) {\n\t    throw Error(\"Can't merge these send calls\");\n\t  }\n\n\t  // merge\n\t  if (isObj && isObject(this._data)) {\n\t    for (var key in data) {\n\t      this._data[key] = data[key];\n\t    }\n\t  } else if ('string' == typeof data) {\n\t    // default to x-www-form-urlencoded\n\t    if (!type) this.type('form');\n\t    type = this._header['content-type'];\n\t    if ('application/x-www-form-urlencoded' == type) {\n\t      this._data = this._data\n\t        ? this._data + '&' + data\n\t        : data;\n\t    } else {\n\t      this._data = (this._data || '') + data;\n\t    }\n\t  } else {\n\t    this._data = data;\n\t  }\n\n\t  if (!isObj || this._isHost(data)) {\n\t    return this;\n\t  }\n\n\t  // default to json\n\t  if (!type) this.type('json');\n\t  return this;\n\t};\n\n\t/**\n\t * Sort `querystring` by the sort function\n\t *\n\t *\n\t * Examples:\n\t *\n\t *       // default order\n\t *       request.get('/user')\n\t *         .query('name=Nick')\n\t *         .query('search=Manny')\n\t *         .sortQuery()\n\t *         .end(callback)\n\t *\n\t *       // customized sort function\n\t *       request.get('/user')\n\t *         .query('name=Nick')\n\t *         .query('search=Manny')\n\t *         .sortQuery(function(a, b){\n\t *           return a.length - b.length;\n\t *         })\n\t *         .end(callback)\n\t *\n\t *\n\t * @param {Function} sort\n\t * @return {Request} for chaining\n\t * @api public\n\t */\n\n\tRequestBase.prototype.sortQuery = function(sort) {\n\t  // _sort default to true but otherwise can be a function or boolean\n\t  this._sort = typeof sort === 'undefined' ? true : sort;\n\t  return this;\n\t};\n\n\t/**\n\t * Compose querystring to append to req.url\n\t *\n\t * @api private\n\t */\n\tRequestBase.prototype._finalizeQueryString = function(){\n\t  var query = this._query.join('&');\n\t  if (query) {\n\t    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;\n\t  }\n\t  this._query.length = 0; // Makes the call idempotent\n\n\t  if (this._sort) {\n\t    var index = this.url.indexOf('?');\n\t    if (index >= 0) {\n\t      var queryArr = this.url.substring(index + 1).split('&');\n\t      if ('function' === typeof this._sort) {\n\t        queryArr.sort(this._sort);\n\t      } else {\n\t        queryArr.sort();\n\t      }\n\t      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');\n\t    }\n\t  }\n\t};\n\n\t// For backwards compat only\n\tRequestBase.prototype._appendQueryString = function() {console.trace(\"Unsupported\");}\n\n\t/**\n\t * Invoke callback with timeout error.\n\t *\n\t * @api private\n\t */\n\n\tRequestBase.prototype._timeoutError = function(reason, timeout, errno){\n\t  if (this._aborted) {\n\t    return;\n\t  }\n\t  var err = new Error(reason + timeout + 'ms exceeded');\n\t  err.timeout = timeout;\n\t  err.code = 'ECONNABORTED';\n\t  err.errno = errno;\n\t  this.timedout = true;\n\t  this.abort();\n\t  this.callback(err);\n\t};\n\n\tRequestBase.prototype._setTimeouts = function() {\n\t  var self = this;\n\n\t  // deadline\n\t  if (this._timeout && !this._timer) {\n\t    this._timer = setTimeout(function(){\n\t      self._timeoutError('Timeout of ', self._timeout, 'ETIME');\n\t    }, this._timeout);\n\t  }\n\t  // response timeout\n\t  if (this._responseTimeout && !this._responseTimeoutTimer) {\n\t    this._responseTimeoutTimer = setTimeout(function(){\n\t      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');\n\t    }, this._responseTimeout);\n\t  }\n\t};\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\t/**\n\t * Check if `obj` is an object.\n\t *\n\t * @param {Object} obj\n\t * @return {Boolean}\n\t * @api private\n\t */\n\n\tfunction isObject(obj) {\n\t  return null !== obj && 'object' === typeof obj;\n\t}\n\n\tmodule.exports = isObject;\n\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\n\t/**\n\t * Module dependencies.\n\t */\n\n\tvar utils = __webpack_require__(47);\n\n\t/**\n\t * Expose `ResponseBase`.\n\t */\n\n\tmodule.exports = ResponseBase;\n\n\t/**\n\t * Initialize a new `ResponseBase`.\n\t *\n\t * @api public\n\t */\n\n\tfunction ResponseBase(obj) {\n\t  if (obj) return mixin(obj);\n\t}\n\n\t/**\n\t * Mixin the prototype properties.\n\t *\n\t * @param {Object} obj\n\t * @return {Object}\n\t * @api private\n\t */\n\n\tfunction mixin(obj) {\n\t  for (var key in ResponseBase.prototype) {\n\t    obj[key] = ResponseBase.prototype[key];\n\t  }\n\t  return obj;\n\t}\n\n\t/**\n\t * Get case-insensitive `field` value.\n\t *\n\t * @param {String} field\n\t * @return {String}\n\t * @api public\n\t */\n\n\tResponseBase.prototype.get = function(field) {\n\t  return this.header[field.toLowerCase()];\n\t};\n\n\t/**\n\t * Set header related properties:\n\t *\n\t *   - `.type` the content type without params\n\t *\n\t * A response of \"Content-Type: text/plain; charset=utf-8\"\n\t * will provide you with a `.type` of \"text/plain\".\n\t *\n\t * @param {Object} header\n\t * @api private\n\t */\n\n\tResponseBase.prototype._setHeaderProperties = function(header){\n\t    // TODO: moar!\n\t    // TODO: make this a util\n\n\t    // content-type\n\t    var ct = header['content-type'] || '';\n\t    this.type = utils.type(ct);\n\n\t    // params\n\t    var params = utils.params(ct);\n\t    for (var key in params) this[key] = params[key];\n\n\t    this.links = {};\n\n\t    // links\n\t    try {\n\t        if (header.link) {\n\t            this.links = utils.parseLinks(header.link);\n\t        }\n\t    } catch (err) {\n\t        // ignore\n\t    }\n\t};\n\n\t/**\n\t * Set flags such as `.ok` based on `status`.\n\t *\n\t * For example a 2xx response will give you a `.ok` of __true__\n\t * whereas 5xx will be __false__ and `.error` will be __true__. The\n\t * `.clientError` and `.serverError` are also available to be more\n\t * specific, and `.statusType` is the class of error ranging from 1..5\n\t * sometimes useful for mapping respond colors etc.\n\t *\n\t * \"sugar\" properties are also defined for common cases. Currently providing:\n\t *\n\t *   - .noContent\n\t *   - .badRequest\n\t *   - .unauthorized\n\t *   - .notAcceptable\n\t *   - .notFound\n\t *\n\t * @param {Number} status\n\t * @api private\n\t */\n\n\tResponseBase.prototype._setStatusProperties = function(status){\n\t    var type = status / 100 | 0;\n\n\t    // status / class\n\t    this.status = this.statusCode = status;\n\t    this.statusType = type;\n\n\t    // basics\n\t    this.info = 1 == type;\n\t    this.ok = 2 == type;\n\t    this.redirect = 3 == type;\n\t    this.clientError = 4 == type;\n\t    this.serverError = 5 == type;\n\t    this.error = (4 == type || 5 == type)\n\t        ? this.toError()\n\t        : false;\n\n\t    // sugar\n\t    this.accepted = 202 == status;\n\t    this.noContent = 204 == status;\n\t    this.badRequest = 400 == status;\n\t    this.unauthorized = 401 == status;\n\t    this.notAcceptable = 406 == status;\n\t    this.forbidden = 403 == status;\n\t    this.notFound = 404 == status;\n\t};\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\n\t/**\n\t * Return the mime type for the given `str`.\n\t *\n\t * @param {String} str\n\t * @return {String}\n\t * @api private\n\t */\n\n\texports.type = function(str){\n\t  return str.split(/ *; */).shift();\n\t};\n\n\t/**\n\t * Return header field parameters.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\n\texports.params = function(str){\n\t  return str.split(/ *; */).reduce(function(obj, str){\n\t    var parts = str.split(/ *= */);\n\t    var key = parts.shift();\n\t    var val = parts.shift();\n\n\t    if (key && val) obj[key] = val;\n\t    return obj;\n\t  }, {});\n\t};\n\n\t/**\n\t * Parse Link header fields.\n\t *\n\t * @param {String} str\n\t * @return {Object}\n\t * @api private\n\t */\n\n\texports.parseLinks = function(str){\n\t  return str.split(/ *, */).reduce(function(obj, str){\n\t    var parts = str.split(/ *; */);\n\t    var url = parts[0].slice(1, -1);\n\t    var rel = parts[1].split(/ *= */)[1].slice(1, -1);\n\t    obj[rel] = url;\n\t    return obj;\n\t  }, {});\n\t};\n\n\t/**\n\t * Strip content related fields from `header`.\n\t *\n\t * @param {Object} header\n\t * @return {Object} header\n\t * @api private\n\t */\n\n\texports.cleanHeader = function(header, changesOrigin){\n\t  delete header['content-type'];\n\t  delete header['content-length'];\n\t  delete header['transfer-encoding'];\n\t  delete header['host'];\n\t  // secuirty\n\t  if (changesOrigin) {\n\t    delete header['authorization'];\n\t    delete header['cookie'];\n\t  }\n\t  return header;\n\t};\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\n\tfunction Agent() {\n\t  this._defaults = [];\n\t}\n\n\t[\"use\", \"on\", \"once\", \"set\", \"query\", \"type\", \"accept\", \"auth\", \"withCredentials\", \"sortQuery\", \"retry\", \"ok\", \"redirects\",\n\t \"timeout\", \"buffer\", \"serialize\", \"parse\", \"ca\", \"key\", \"pfx\", \"cert\"].forEach(function(fn) {\n\t  /** Default setting for all requests from this agent */\n\t  Agent.prototype[fn] = function(/*varargs*/) {\n\t    this._defaults.push({fn:fn, arguments:arguments});\n\t    return this;\n\t  }\n\t});\n\n\tAgent.prototype._setDefaults = function(req) {\n\t    this._defaults.forEach(function(def) {\n\t      req[def.fn].apply(req, def.arguments);\n\t    });\n\t};\n\n\tmodule.exports = Agent;\n\n\n/***/ })\n/******/ ])\n});\n;"},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/ringcentral-web-phone.js":function(n,e){n.exports="(function(root, factory) {\n    /* istanbul ignore next */\n        root.RingCentral = root.RingCentral || {};\n        root.RingCentral.WebPhone = factory(root.SIP, root.getStats);\n})(this, function(SIP, getStats) {\n    var messages = {\n        park: {reqid: 1, command: 'callpark'},\n        startRecord: {reqid: 2, command: 'startcallrecord'},\n        stopRecord: {reqid: 3, command: 'stopcallrecord'},\n        flip: {reqid: 3, command: 'callflip', target: ''},\n        monitor: {reqid: 4, command: 'monitor'},\n        barge: {reqid: 5, command: 'barge'},\n        whisper: {reqid: 6, command: 'whisper'},\n        takeover: {reqid: 7, command: 'takeover'},\n        toVoicemail: {reqid: 11, command: 'toVoicemail'},\n        ignore: {reqid: 12, command: 'ignore'},\n        receiveConfirm: {reqid: 17, command: 'receiveConfirm'},\n        replyWithMessage: {reqid: 14, command: 'replyWithMessage'}\n    };\n\n    var uuidKey = 'rc-webPhone-uuid';\n\n    var responseTimeout = 60000;\n\n    var defaultMediaConstraints = {\n        audio: true,\n        video: false\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * TODO: include 'WebPhone' for all apps other than Chrome and Glip\n     * TODO: parse wsservers from new api spec\n     * @param {object} regData\n     * @param {object} [options]\n     * @param {string} [options.uuid]\n     * @param {string} [options.appKey]\n     * @param {string} [options.appName]\n     * @param {string} [options.appVersion]\n     * @param {string} [options.audioHelper]\n     * @param {string} [options.onSession] fired each time UserAgent starts working with session\n     * @param {boolean} [options.enableMidLinesInSDP]\n     * @param {array} [options.modifiers]\n     * @param {boolean} [options.enableUnifiedSDP]\n     * @param {object} [options.mediaConstraints]\n     * @param {boolean} [options.enableQos]\n     * @param {string} [options.uuidKey]\n     * @param {object} [options.sessionDescriptionHandlerFactoryOptions]\n     * @param {function} [options.sessionDescriptionHandlerFactory]\n     * @property {SIP.UA} userAgent\n     * @constructor\n     */\n    function WebPhone(regData, options) {\n        regData = regData || {};\n        options = options || {};\n\n        this.sipInfo = regData.sipInfo[0] || regData.sipInfo;\n        this.sipFlags = regData.sipFlags;\n\n        this.uuidKey = options.uuidKey || uuidKey;\n\n        var id = options.uuid || localStorage.getItem(this.uuidKey) || uuid(); //TODO Make configurable\n        localStorage.setItem(this.uuidKey, id);\n\n        this.appKey = options.appKey;\n        this.appName = options.appName;\n        this.appVersion = options.appVersion;\n\n        var ua_match = navigator.userAgent.match(/\\((.*?)\\)/);\n        var app_client_os = (ua_match && ua_match.length && ua_match[1]).replace(/[^a-zA-Z0-9.:_]+/g, '-') || '';\n\n        var userAgentString =\n            (options.appName ? options.appName + (options.appVersion ? '/' + options.appVersion : '') + ' ' : '') +\n            (app_client_os ? app_client_os : '') +\n            ' RCWEBPHONE/' +\n            WebPhone.version;\n\n        var modifiers = options.modifiers || [];\n        modifiers.push(SIP.Web.Modifiers.stripG722);\n        modifiers.push(SIP.Web.Modifiers.stripTcpCandidates);\n\n        var sdpSemantics = 'plan-b';\n\n        if (options.enableUnifiedSDP) {\n            sdpSemantics = 'unified-plan';\n        }\n\n        if (options.enableMidLinesInSDP) {\n            modifiers.push(SIP.Web.Modifiers.addMidLines);\n        }\n\n        var sessionDescriptionHandlerFactoryOptions = options.sessionDescriptionHandlerFactoryOptions || {\n            peerConnectionOptions: {\n                iceCheckingTimeout: this.sipInfo.iceCheckingTimeout || this.sipInfo.iceGatheringTimeout || 500,\n                rtcConfiguration: {\n                    rtcpMuxPolicy: 'negotiate',\n                    sdpSemantics: sdpSemantics\n                }\n            },\n            constraints: options.mediaConstraints || defaultMediaConstraints,\n            modifiers: modifiers\n        };\n\n        var browserUa = navigator.userAgent.toLowerCase();\n        var isSafari = false;\n        var isFirefox = false;\n\n        if (browserUa.indexOf('safari') > -1 && browserUa.indexOf('chrome') < 0) {\n            isSafari = true;\n        } else if (browserUa.indexOf('firefox') > -1 && browserUa.indexOf('chrome') < 0) {\n            isFirefox = true;\n        }\n\n        if (isFirefox) {\n            sessionDescriptionHandlerFactoryOptions.alwaysAcquireMediaFirst = true;\n        }\n\n        var sessionDescriptionHandlerFactory = options.sessionDescriptionHandlerFactory || [];\n\n        var configuration = {\n            uri: 'sip:' + this.sipInfo.username + '@' + this.sipInfo.domain,\n\n            transportOptions: {\n                wsServers:\n                    this.sipInfo.outboundProxy && this.sipInfo.transport\n                        ? this.sipInfo.transport.toLowerCase() + '://' + this.sipInfo.outboundProxy\n                        : this.sipInfo.wsServers,\n                traceSip: true,\n                maxReconnectionAttempts: options.maxReconnectionAttempts || 10,\n                reconnectionTimeout: options.reconnectionTimeout || 15,\n                connectionTimeout: options.connectionTimeout || 10,\n                keepAliveDebounce: options.keepAliveDebounce || 10\n            },\n            authorizationUser: this.sipInfo.authorizationId,\n            password: this.sipInfo.password,\n            stunServers: this.sipInfo.stunServers || ['stun:74.125.194.127:19302'], //FIXME Hardcoded?\n            turnServers: [],\n            log: {\n                level: options.logLevel || 1, //FIXME LOG LEVEL 3\n                builtinEnabled: options.builtinEnabled || true,\n                connector: options.connector || null\n            },\n            domain: this.sipInfo.domain,\n            autostart: false,\n            register: false,\n            userAgentString: userAgentString,\n            sessionDescriptionHandlerFactoryOptions: sessionDescriptionHandlerFactoryOptions,\n            sessionDescriptionHandlerFactory: sessionDescriptionHandlerFactory\n        };\n        this.userAgent = new SIP.UA(configuration);\n\n        this.userAgent.defaultHeaders = ['P-rc-endpoint-id: ' + id, 'Client-id:' + options.appKey];\n\n        this.userAgent.media = {};\n\n        this.userAgent.enableQos = options.enableQos;\n\n        this.userAgent.qosCollectInterval = options.qosCollectInterval || 5000;\n\n        if (options.media && (options.media.remote && options.media.local)) {\n            this.userAgent.media.remote = options.media.remote;\n            this.userAgent.media.local = options.media.local;\n        } else this.userAgent.media = null;\n\n        this.userAgent.sipInfo = this.sipInfo;\n\n        this.userAgent.__invite = this.userAgent.invite;\n        this.userAgent.invite = invite;\n\n        this.userAgent.__register = this.userAgent.register;\n        this.userAgent.register = register;\n\n        this.userAgent.__unregister = this.userAgent.unregister;\n        this.userAgent.unregister = unregister;\n\n        this.userAgent.on(\n            'invite',\n            function(session) {\n                this.userAgent.audioHelper.playIncoming(true);\n                patchSession(session);\n                patchIncomingSession(session);\n                session._sendReceiveConfirmPromise = session\n                    .sendReceiveConfirm()\n                    .then(function() {\n                        session.logger.log('sendReceiveConfirm success');\n                    })\n                    .catch(function(error) {\n                        session.logger.error('failed to send receive confirmation via SIP MESSAGE due to ' + error);\n                        throw error;\n                    });\n            }.bind(this)\n        );\n\n        this.userAgent.audioHelper = new AudioHelper(options.audioHelper);\n\n        this.userAgent.onSession = options.onSession || null;\n        this.userAgent.createRcMessage = createRcMessage;\n        this.userAgent.sendMessage = sendMessage;\n        this.userAgent._onMessage = this.userAgent.onTransportReceiveMsg;\n        this.userAgent.onTransportReceiveMsg = onMessage.bind(this.userAgent);\n        this.userAgent.start();\n        this.userAgent.register();\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    WebPhone.version = '0.6.3';\n    WebPhone.uuid = uuid;\n    WebPhone.delay = delay;\n    WebPhone.extend = extend;\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @param {object} options\n     * @return {String}\n     */\n    function createRcMessage(options) {\n        options.body = options.body || '';\n        return (\n            '<Msg>' +\n            '<Hdr SID=\"' +\n            options.sid +\n            '\" Req=\"' +\n            options.request +\n            '\" From=\"' +\n            options.from +\n            '\" To=\"' +\n            options.to +\n            '\" Cmd=\"' +\n            options.reqid +\n            '\"/> ' +\n            '<Bdy Cln=\"' +\n            this.sipInfo.authorizationId +\n            '\" ' +\n            options.body +\n            '/>' +\n            '</Msg>'\n        );\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.UA}\n     * @param {object} to\n     * @param {object} messageData\n     * @return {Promise}\n     */\n    function sendMessage(to, messageData) {\n        var userAgent = this;\n        var sipOptions = {};\n        sipOptions.contentType = 'x-rc/agent';\n        sipOptions.extraHeaders = [];\n        sipOptions.extraHeaders.push('P-rc-ws: ' + this.contact);\n\n        return new Promise(function(resolve, reject) {\n            var message = userAgent.message(to, messageData, sipOptions);\n\n            message.once('accepted', function(response, cause) {\n                resolve();\n            });\n            message.once('failed', function(response, cause) {\n                reject(new Error(cause));\n            });\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function onMessage(e) {\n        // This is a temporary solution to avoid timeout errors for MESSAGE responses.\n        // Timeout is caused by port specification in host field within Via header.\n        // sip.js requires received viaHost in a response to be the same as ours via host therefore\n        // messages with the same host but with port are ignored.\n        // This is the exact case for WSX: it send host:port inn via header in MESSAGE responses.\n        // To overcome this, we will preprocess MESSAGE messages and remove port from viaHost field.\n        var data = e.data;\n\n        // WebSocket binary message.\n        if (typeof data !== 'string') {\n            try {\n                data = String.fromCharCode.apply(null, new Uint8Array(data));\n            } catch (error) {\n                return this._onMessage.apply(this, [e]);\n            }\n        }\n\n        if (data.match(/CSeq:\\s*\\d+\\s+MESSAGE/i)) {\n            var re = new RegExp(this.ua.configuration.viaHost + ':\\\\d+', 'g');\n            var newData = e.data.replace(re, this.ua.configuration.viaHost);\n            Object.defineProperty(e, 'data', {\n                value: newData,\n                writable: false\n            });\n        }\n\n        return this._onMessage.apply(this, [e]);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function patchSession(session) {\n        if (session.__patched) return session;\n\n        session.__patched = true;\n\n        session.__sendRequest = session.sendRequest;\n        session.__receiveRequest = session.receiveRequest;\n        session.__accept = session.accept;\n        session.__hold = session.hold;\n        session.__unhold = session.unhold;\n        session.__dtmf = session.dtmf;\n        session.__reinvite = session.reinvite;\n\n        session.sendRequest = sendRequest;\n        session.receiveRequest = receiveRequest;\n        session.accept = accept;\n        session.hold = hold;\n        session.unhold = unhold;\n        session.dtmf = dtmf;\n        session.reinvite = reinvite;\n\n        session.warmTransfer = warmTransfer;\n        session.blindTransfer = blindTransfer;\n        session.transfer = transfer;\n        session.park = park;\n        session.forward = forward;\n        session.startRecord = startRecord;\n        session.stopRecord = stopRecord;\n        session.flip = flip;\n\n        session.mute = mute;\n        session.unmute = unmute;\n        session.onLocalHold = onLocalHold;\n\n        session.media = session.ua.media;\n        session.addTrack = addTrack;\n\n        session.on('replaced', patchSession);\n\n        // Audio\n        session.on('progress', function(incomingResponse) {\n            stopPlaying();\n            if (incomingResponse.status_code === 183) {\n                session.createDialog(incomingResponse, 'UAC');\n                session.hasAnswer = true;\n                session.status = 11;\n                session.sessionDescriptionHandler.setDescription(incomingResponse.body).catch(function(exception) {\n                    session.logger.warn(exception);\n                    session.failed(incomingResponse, C.causes.BAD_MEDIA_DESCRIPTION);\n                    session.terminate({\n                        status_code: 488,\n                        reason_phrase: 'Bad Media Description'\n                    });\n                });\n            }\n        });\n\n        if (session.media) session.on('trackAdded', addTrack);\n\n        session.on('accepted', stopPlaying);\n        session.on('rejected', stopPlaying);\n        session.on('bye', stopPlaying);\n        session.on('terminated', stopPlaying);\n        session.on('cancel', stopPlaying);\n        session.on('failed', stopPlaying);\n        session.on('replaced', stopPlaying);\n\n        if (session.ua.enableQos) {\n            session.on('SessionDescriptionHandler-created', function() {\n                session.logger.log('SessionDescriptionHandler Created');\n                startQosStatsCollection(session);\n            });\n        }\n\n        function stopPlaying() {\n            session.ua.audioHelper.playOutgoing(false);\n            session.ua.audioHelper.playIncoming(false);\n            session.removeListener('accepted', stopPlaying);\n            session.removeListener('rejected', stopPlaying);\n            session.removeListener('bye', stopPlaying);\n            session.removeListener('terminated', stopPlaying);\n            session.removeListener('cancel', stopPlaying);\n            session.removeListener('failed', stopPlaying);\n            session.removeListener('replaced', stopPlaying);\n        }\n\n        if (session.ua.onSession) session.ua.onSession(session);\n\n        return session;\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function patchIncomingSession(session) {\n        try {\n            parseRcHeader(session);\n        } catch (e) {\n            session.logger.error(\"Can't parse RC headers from invite request due to \" + e);\n        }\n        session.canUseRCMCallControl = canUseRCMCallControl;\n        session.createSessionMessage = createSessionMessage;\n        session.sendSessionMessage = sendSessionMessage;\n        session.sendReceiveConfirm = sendReceiveConfirm;\n        session.ignore = ignore;\n        session.toVoicemail = toVoicemail;\n        session.replyWithMessage = replyWithMessage;\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function parseRcHeader(session) {\n        var prc = session.request.headers['P-Rc'];\n        if (prc && prc.length) {\n            var rawInviteMsg = prc[0].raw;\n            var parser = new DOMParser();\n            var xmlDoc = parser.parseFromString(rawInviteMsg, 'text/xml');\n            var hdrNode = xmlDoc.getElementsByTagName('Hdr')[0];\n            var bdyNode = xmlDoc.getElementsByTagName('Bdy')[0];\n\n            if (hdrNode) {\n                session.rcHeaders = {\n                    sid: hdrNode.getAttribute('SID'),\n                    request: hdrNode.getAttribute('Req'),\n                    from: hdrNode.getAttribute('From'),\n                    to: hdrNode.getAttribute('To')\n                };\n            }\n            if (bdyNode) {\n                extend(session.rcHeaders, {\n                    srvLvl: bdyNode.getAttribute('SrvLvl'),\n                    srvLvlExt: bdyNode.getAttribute('SrvLvlExt'),\n                    toNm: bdyNode.getAttribute('ToNm')\n                });\n            }\n        }\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return {boolean}\n     */\n    function canUseRCMCallControl() {\n        return !!this.rcHeaders;\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param {object} options\n     * @return {String}\n     */\n    function createSessionMessage(options) {\n        if (!this.rcHeaders) {\n            return undefined;\n        }\n        extend(options, {\n            sid: this.rcHeaders.sid,\n            request: this.rcHeaders.request,\n            from: this.rcHeaders.to,\n            to: this.rcHeaders.from\n        });\n        return this.ua.createRcMessage(options);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return {Promise}\n     */\n    function ignore() {\n        var session = this;\n        return session._sendReceiveConfirmPromise.then(function() {\n            return session.sendSessionMessage(messages.ignore);\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param {object} options\n     * @return {Promise}\n     */\n    function sendSessionMessage(options) {\n        if (!this.rcHeaders) {\n            return Promise.reject(new Error(\"Can't send SIP MESSAGE related to session: no RC headers available\"));\n        }\n\n        var to = this.rcHeaders.from;\n\n        return this.ua.sendMessage(to, this.createSessionMessage(options));\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return {Promise}\n     */\n    function sendReceiveConfirm() {\n        return this.sendSessionMessage(messages.receiveConfirm);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return {Promise}\n     */\n    function toVoicemail() {\n        var session = this;\n        return session._sendReceiveConfirmPromise.then(function() {\n            return session.sendSessionMessage(messages.toVoicemail);\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param {object} replyOptions\n     * @return {Promise}\n     */\n    function replyWithMessage(replyOptions) {\n        var body = 'RepTp=\"' + replyOptions.replyType + '\"';\n\n        if (replyOptions.replyType === 0) {\n            body += ' Bdy=\"' + replyOptions.replyText + '\"';\n        } else if (replyOptions.replyType === 1) {\n            body += ' Vl=\"' + replyOptions.timeValue + '\"';\n            body += ' Units=\"' + replyOptions.timeUnits + '\"';\n            body += ' Dir=\"' + replyOptions.callbackDirection + '\"';\n        }\n        var session = this;\n        return session._sendReceiveConfirmPromise.then(function() {\n            return session.sendSessionMessage({\n                reqid: messages.replyWithMessage.reqid,\n                body: body\n            });\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @private\n     * @param {SIP.Session} session\n     * @param {object} command\n     * @param {object} [options]\n     * @return {Promise}\n     */\n    function sendReceive(session, command, options) {\n        options = options || {};\n\n        extend(command, options);\n\n        var cseq = null;\n\n        return new Promise(function(resolve, reject) {\n            var extraHeaders = (options.extraHeaders || [])\n                .concat(session.ua.defaultHeaders)\n                .concat(['Content-Type: application/json;charset=utf-8']);\n\n            session.sendRequest(SIP.C.INFO, {\n                body: JSON.stringify({\n                    request: command\n                }),\n                extraHeaders: extraHeaders,\n                receiveResponse: function(response) {\n                    var timeout = null;\n                    if (response.status_code === 200) {\n                        cseq = response.cseq;\n                        function onInfo(request) {\n                            if (response.cseq === cseq) {\n                                var body = (request && request.body) || '{}';\n                                var obj;\n\n                                try {\n                                    obj = JSON.parse(body);\n                                } catch (e) {\n                                    obj = {};\n                                }\n\n                                if (obj.response && obj.response.command === command.command) {\n                                    if (obj.response.result) {\n                                        if (obj.response.result.code.toString() === '0') {\n                                            return resolve(obj.response.result);\n                                        } else {\n                                            return reject(obj.response.result);\n                                        }\n                                    }\n                                }\n                                timeout && clearTimeout(timeout);\n                                session.removeListener('RC_SIP_INFO', onInfo);\n                                resolve(null); //FIXME What to resolve\n                            }\n                        }\n                        timeout = setTimeout(function() {\n                            reject(new Error('Timeout: no reply'));\n                            session.removeListener('RC_SIP_INFO', onInfo);\n                        }, responseTimeout);\n                        session.on('RC_SIP_INFO', onInfo);\n                    } else {\n                        reject(\n                            new Error(\n                                'The INFO response status code is: ' + response.status_code + ' (waiting for 200)'\n                            )\n                        );\n                    }\n                }\n            });\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function register(options) {\n        options = options || {};\n        options.extraHeaders = (options.extraHeaders || []).concat(this.defaultHeaders);\n        return this.__register.call(this, options);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function unregister(options) {\n        options = options || {};\n        options.extraHeaders = (options.extraHeaders || []).concat(this.defaultHeaders);\n        return this.__unregister.call(this, options);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function sendRequest(type, config) {\n        if (type === SIP.C.PRACK) {\n            // type = SIP.C.ACK;\n            return this;\n        }\n        return this.__sendRequest(type, config);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @private\n     * @param {SIP.Session} session\n     * @param {boolean} flag\n     * @return {Promise}\n     */\n    function setRecord(session, flag) {\n        var message = !!flag ? messages.startRecord : messages.stopRecord;\n\n        if ((session.__onRecord && !flag) || (!session.__onRecord && flag)) {\n            return sendReceive(session, message).then(function(data) {\n                session.__onRecord = !!flag;\n                return data;\n            });\n        }\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @private\n     * @param {SIP.Session} session\n     * @param {boolean} flag\n     * @return {Promise}\n     */\n    function setLocalHold(session, flag) {\n        return new Promise(function(resolve, reject) {\n            var options = {\n                eventHandlers: {\n                    succeeded: resolve,\n                    failed: reject\n                }\n            };\n\n            if (flag) {\n                resolve(session.__hold(options));\n            } else {\n                resolve(session.__unhold(options));\n            }\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.UA}\n     * @param number\n     * @param options\n     * @return {SIP.Session}\n     */\n    function invite(number, options) {\n        var ua = this;\n\n        options = options || {};\n        options.extraHeaders = (options.extraHeaders || []).concat(ua.defaultHeaders);\n\n        options.extraHeaders.push(\n            'P-Asserted-Identity: sip:' + (options.fromNumber || ua.sipInfo.username) + '@' + ua.sipInfo.domain\n        ); //FIXME Phone Number\n\n        //FIXME Backend should know it already\n        if (options.homeCountryId) {\n            options.extraHeaders.push('P-rc-country-id: ' + options.homeCountryId);\n        }\n\n        options.RTCConstraints = options.RTCConstraints || {\n            optional: [{DtlsSrtpKeyAgreement: 'true'}]\n        };\n\n        ua.audioHelper.playOutgoing(true);\n        return patchSession(ua.__invite(number, options));\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param request\n     * @return {*}\n     */\n    function receiveRequest(request) {\n        var session = this;\n        switch (request.method) {\n            case SIP.C.INFO:\n                session.emit('RC_SIP_INFO', request);\n                //SIP.js does not support application/json content type, so we monkey override its behaviour in this case\n                if (\n                    session.status === SIP.Session.C.STATUS_CONFIRMED ||\n                    session.status === SIP.Session.C.STATUS_WAITING_FOR_ACK\n                ) {\n                    var contentType = request.getHeader('content-type');\n                    if (contentType.match(/^application\\/json/i)) {\n                        request.reply(200);\n                        return session;\n                    }\n                }\n                break;\n        }\n        return session.__receiveRequest.apply(session, arguments);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param {object} options\n     * @return {Promise}\n     */\n    function accept(options) {\n        var session = this;\n\n        options = options || {};\n        options.extraHeaders = (options.extraHeaders || []).concat(session.ua.defaultHeaders);\n        options.RTCConstraints = options.RTCConstraints || {\n            optional: [{DtlsSrtpKeyAgreement: 'true'}]\n        };\n\n        return new Promise(function(resolve, reject) {\n            function onAnswered() {\n                resolve(session);\n                session.removeListener('failed', onFail);\n            }\n\n            function onFail(e) {\n                reject(e);\n                session.removeListener('accepted', onAnswered);\n            }\n\n            //TODO More events?\n            session.once('accepted', onAnswered);\n            session.once('failed', onFail);\n            session.__accept(options);\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session} session\n     * @param {string} dtmf\n     * @param {number} duration\n     * @return {Promise}\n     */\n    function dtmf(dtmf, duration) {\n        var session = this;\n        duration = parseInt(duration) || 1000;\n        var pc = session.sessionDescriptionHandler.peerConnection;\n        var senders = pc.getSenders();\n        var audioSender = senders.find(function(sender) {\n            return sender.track && sender.track.kind === 'audio';\n        });\n        var dtmfSender = audioSender.dtmf;\n        if (dtmfSender !== undefined && dtmfSender) {\n            return dtmfSender.insertDTMF(dtmf, duration);\n        }\n        var sender = dtmfSender && !dtmfSender.canInsertDTMF ? \"can't insert DTMF\" : 'Unknown';\n        throw new Error('Send DTMF failed: ' + (!dtmfSender ? 'no sender' : sender));\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session} session\n     * @return {Promise}\n     */\n    function hold() {\n        return setLocalHold(this, true);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session} session\n     * @return {Promise}\n     */\n    function unhold() {\n        return setLocalHold(this, false);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session} session\n     * @param {string} target\n     * @param {object} options\n     * @return {Promise}\n     */\n    function blindTransfer(target, options) {\n        options = options || {};\n\n        var session = this;\n        var extraHeaders = options.extraHeaders || [];\n        var originalTarget = target;\n\n        return new Promise(function(resolve, reject) {\n            //Blind Transfer is taken from SIP.js source\n            return session.refer(target, options);\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session} session\n     * @param {SIP.Session} target\n     * @param {object} transferOptions\n     * @return {Promise}\n     */\n    function warmTransfer(target, transferOptions) {\n        var session = this;\n\n        return (session.local_hold ? Promise.resolve(null) : session.hold())\n            .then(function() {\n                return delay(300);\n            })\n            .then(function() {\n                var referTo =\n                    '<' +\n                    target.dialog.remote_target.toString() +\n                    '?Replaces=' +\n                    target.dialog.id.call_id +\n                    '%3Bto-tag%3D' +\n                    target.dialog.id.remote_tag +\n                    '%3Bfrom-tag%3D' +\n                    target.dialog.id.local_tag +\n                    '>';\n\n                transferOptions = transferOptions || {};\n                transferOptions.extraHeaders = (transferOptions.extraHeaders || [])\n                    .concat(session.ua.defaultHeaders)\n                    .concat(['Referred-By: ' + session.dialog.remote_target.toString()]);\n\n                //TODO return session.refer(newSession);\n                return session.blindTransfer(referTo, transferOptions);\n            });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param {string} target\n     * @param {object} options\n     * @return {Promise}\n     */\n    function transfer(target, options) {\n        var session = this;\n\n        return (session.local_hold ? Promise.resolve(null) : session.hold())\n            .then(function() {\n                return delay(300);\n            })\n            .then(function() {\n                return session.blindTransfer(target, options);\n            });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param {string} target\n     * @param {object} acceptOptions\n     * @param {object} [transferOptions]\n     * @return {Promise}\n     */\n    function forward(target, acceptOptions, transferOptions) {\n        var interval = null;\n\n        var session = this;\n\n        return session.accept(acceptOptions).then(function() {\n            return new Promise(function(resolve, reject) {\n                interval = setInterval(function() {\n                    if (session.status === 12) {\n                        clearInterval(interval);\n                        session.mute();\n                        setTimeout(function() {\n                            resolve(session.transfer(target, transferOptions));\n                        }, 700);\n                    }\n                }, 50);\n            });\n        });\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return {Promise}\n     */\n    function startRecord() {\n        return setRecord(this, true);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return {Promise}\n     */\n    function stopRecord() {\n        return setRecord(this, false);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @param target\n     * @return {Promise}\n     */\n    function flip(target) {\n        return sendReceive(this, messages.flip, {target: target});\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return {Promise}\n     */\n    function park() {\n        return sendReceive(this, messages.park);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n    /**\n     * @this {SIP.Session}\n     * @return {Promise}\n     */\n\n    function reinvite(options, modifier) {\n        var session = this;\n        options = options || {};\n        options.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions || {};\n        return session.__reinvite(options, modifier);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function toggleMute(session, mute) {\n        var pc = session.sessionDescriptionHandler.peerConnection;\n        if (pc.getSenders) {\n            pc.getSenders().forEach(function(sender) {\n                if (sender.track) {\n                    sender.track.enabled = !mute;\n                }\n            });\n        }\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n    function mute(silent) {\n        if (this.state !== this.STATUS_CONNECTED) {\n            this.logger.warn('An acitve call is required to mute audio');\n            return;\n        }\n        this.logger.log('Muting Audio');\n        if (!silent) {\n            this.emit('muted', this.session);\n        }\n        return toggleMute(this, true);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function unmute(silent) {\n        if (this.state !== this.STATUS_CONNECTED) {\n            this.logger.warn('An active call is required to unmute audio');\n            return;\n        }\n        this.logger.log('Unmuting Audio');\n        if (!silent) {\n            this.emit('unmuted', this.session);\n        }\n        return toggleMute(this, false);\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @this {SIP.Session}\n     * @return boolean\n     */\n    function onLocalHold() {\n        var session = this;\n        return session.local_hold;\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    function addTrack(remoteAudioEle, localAudioEle) {\n        var session = this;\n        var pc = session.sessionDescriptionHandler.peerConnection;\n\n        var remoteAudio;\n        var localAudio;\n\n        if (remoteAudioEle && localAudioEle) {\n            remoteAudio = remoteAudioEle;\n            localAudio = localAudioEle;\n        } else if (session.media) {\n            remoteAudio = session.media.remote;\n            localAudio = session.media.local;\n        } else {\n            throw new Error('HTML Media Element not Defined');\n        }\n\n        var remoteStream = new MediaStream();\n        if (pc.getReceivers) {\n            pc.getReceivers().forEach(function(receiver) {\n                var rtrack = receiver.track;\n                if (rtrack) {\n                    remoteStream.addTrack(rtrack);\n                }\n            });\n        } else {\n            remoteStream = pc.getRemoteStreams()[0];\n        }\n        remoteAudio.srcObject = remoteStream;\n        remoteAudio.play().catch(function() {\n            session.logger.log('local play was rejected');\n        });\n\n        var localStream = new MediaStream();\n        if (pc.getSenders) {\n            pc.getSenders().forEach(function(sender) {\n                var strack = sender.track;\n                if (strack && strack.kind === 'audio') {\n                    localStream.addTrack(strack);\n                }\n            });\n        } else {\n            localStream = pc.getLocalStreams()[0];\n        }\n        localAudio.srcObject = localStream;\n        localAudio.play().catch(function() {\n            session.logger.log('local play was rejected');\n        });\n    }\n\n    /*----------------------------------------------------------------QOS-------------------------------------------------*/\n\n    /**\n     * @param {SIP.Session} session\n     */\n    function startQosStatsCollection(session) {\n        var qosStatsObj = getQoSStatsTemplate();\n\n        qosStatsObj.callID = session.request.call_id || '';\n        qosStatsObj.fromTag = session.from_tag || '';\n        qosStatsObj.toTag = session.to_tag || '';\n        qosStatsObj.localID = session.request.headers.From[0].raw || session.request.headers.From[0];\n        qosStatsObj.remoteID = session.request.headers.To[0].raw || session.request.headers.To[0];\n        qosStatsObj.origID = session.request.headers.From[0].raw || session.request.headers.From[0];\n        var previousGetStatsResult;\n\n        if (!getStats) throw new Error('getStats module was not provided!');\n\n        getStats(\n            session.sessionDescriptionHandler.peerConnection,\n            function(getStatsResult) {\n                previousGetStatsResult = getStatsResult;\n                qosStatsObj.status = true;\n                var network = getNetworkType(previousGetStatsResult.connectionType);\n                qosStatsObj.localAddr = previousGetStatsResult.connectionType.local.ipAddress[0];\n                qosStatsObj.remoteAddr = previousGetStatsResult.connectionType.remote.ipAddress[0];\n                previousGetStatsResult.results.forEach(function(item) {\n                    if (item.type === 'ssrc' && item.transportId === 'Channel-audio-1' && item.id.includes('recv')) {\n                        qosStatsObj.jitterBufferDiscardRate = item.googSecondaryDiscardedRate || 0;\n                        qosStatsObj.packetLost = item.packetsLost;\n                        qosStatsObj.packetsReceived = item.packetsReceived;\n                        qosStatsObj.totalSumJitter += parseFloat(item.googJitterBufferMs);\n                        qosStatsObj.totalIntervalCount += 1;\n                        qosStatsObj.JBM = Math.max(qosStatsObj.JBM, parseFloat(item.googJitterBufferMs));\n                        qosStatsObj.netType = addToMap(qosStatsObj.netType, network);\n                    }\n                });\n            },\n            session.ua.qosCollectInterval\n        );\n\n        session.on('terminated', function() {\n            previousGetStatsResult && previousGetStatsResult.nomore();\n            publishQosStats(session, qosStatsObj);\n        });\n    }\n\n    /**\n     * @param {SIP.Session} session\n     * @param {Object} qosStatsObj\n     * @param {Object} options\n     */\n    function publishQosStats(session, qosStatsObj, options) {\n        options = options || {};\n\n        var effectiveType = navigator.connection.effectiveType || '';\n        var networkType = calculateNetworkUsage(qosStatsObj) || '';\n        var targetUrl = options.targetUrl || 'rtcpxr@rtcpxr.ringcentral.com:5060';\n        var event = options.event || 'vq-rtcpxr';\n        options.expires = 60;\n        options.contentType = 'application/vq-rtcpxr';\n        options.extraHeaders = options.extraHeaders || [];\n        options.extraHeaders.push(\n            'p-rc-client-info:' +\n                'cpuRC=0:0;cpuOS=0:0;netType=' +\n                networkType +\n                ';ram=0:0;effectiveType=' +\n                effectiveType\n        );\n\n        var calculatedStatsObj = calculateStats(qosStatsObj);\n        var body = createPublishBody(calculatedStatsObj);\n        var pub = session.ua.publish(targetUrl, event, body, options);\n        qosStatsObj.status = false;\n        pub.close();\n        session.emit('qos-published', body);\n    }\n\n    function calculateNetworkUsage(qosStatsObj) {\n        var networkType = [];\n        var entries = Object.entries(qosStatsObj.netType);\n\n        for (var i=0; i<entries.length; i++){\n          var key = entries[i][0];\n          var value = entries[i][1];\n          networkType.push(key + ':' + parseFloat((value * 100) / qosStatsObj.totalIntervalCount).toFixed(2));\n        }\n\n        // for (var [key, value] of Object.entries(qosStatsObj.netType)) {\n        //     networkType.push(key + ':' + parseFloat((value * 100) / qosStatsObj.totalIntervalCount).toFixed(2));\n        // }\n        return networkType.join();\n    }\n\n    function calculateStats(qosStatsObj) {\n        var rawNLR = (qosStatsObj.packetLost * 100) / (qosStatsObj.packetsReceived + qosStatsObj.packetLost) || 0;\n        var rawJBN =\n            qosStatsObj.totalIntervalCount > 0 ? qosStatsObj.totalSumJitter / qosStatsObj.totalIntervalCount : 0;\n\n        return Object.assign({}, qosStatsObj, {\n            NLR: parseFloat(rawNLR).toFixed(2),\n            //JitterBufferNominal\n            JBN: parseFloat(rawJBN).toFixed(2),\n            //JitterBufferDiscardRate\n            JDR: parseFloat(qosStatsObj.jitterBufferDiscardRate).toFixed(2),\n            //MOS Score\n            MOSLQ: 0\n        });\n    }\n\n    function createPublishBody(calculatedStatsObj) {\n        var NLR = calculatedStatsObj.NLR || 0;\n        var JBM = calculatedStatsObj.JBM || 0;\n        var JBN = calculatedStatsObj.JBN || 0;\n        var JDR = calculatedStatsObj.JDR || 0;\n        var MOSLQ = calculatedStatsObj.MOSLQ || 0;\n\n        var callID = calculatedStatsObj.callID || '';\n        var fromTag = calculatedStatsObj.fromTag || '';\n        var toTag = calculatedStatsObj.toTag || '';\n        var localId = calculatedStatsObj.localID || '';\n        var remoteId = calculatedStatsObj.remoteID || '';\n\n        var localAddr = calculatedStatsObj.localAddr || '';\n        var remoteAddr = calculatedStatsObj.remoteAddr || '';\n\n        return (\n            'VQSessionReport: CallTerm\\r\\n' +\n            'CallID: ' +\n            callID +\n            '\\r\\n' +\n            'LocalID: ' +\n            localId +\n            '\\r\\n' +\n            'RemoteID: ' +\n            remoteId +\n            '\\r\\n' +\n            'OrigID: ' +\n            localId +\n            '\\r\\n' +\n            'LocalAddr: IP=' +\n            localAddr +\n            ' SSRC=0x00000000\\r\\n' +\n            'RemoteAddr: IP=' +\n            remoteAddr +\n            ' SSRC=0x00000000\\r\\n' +\n            'LocalMetrics:\\r\\n' +\n            'Timestamps: START=0 STOP=0\\r\\n' +\n            'SessionDesc: PT=0 PD=opus SR=0 FD=0 FPP=0 PPS=0 PLC=0 SSUP=on\\r\\n' +\n            'JitterBuffer: JBA=0 JBR=0 JBN=' +\n            JBN +\n            ' JBM=' +\n            JBM +\n            ' JBX=0\\r\\n' +\n            'PacketLoss: NLR=' +\n            NLR +\n            ' JDR=' +\n            JDR +\n            '\\r\\n' +\n            'BurstGapLoss: BLD=0 BD=0 GLD=0 GD=0 GMIN=0\\r\\n' +\n            'Delay: RTD=0 ESD=0 SOWD=0 IAJ=0\\r\\n' +\n            'QualityEst: MOSLQ=' +\n            MOSLQ +\n            ' MOSCQ=0.0\\r\\n' +\n            'DialogID: ' +\n            callID +\n            ';to-tag=' +\n            toTag +\n            ';from-tag=' +\n            fromTag\n        );\n    }\n\n    /**\n     * @this {SIP.Session}\n     */\n    function getQoSStatsTemplate() {\n        return {\n            localAddr: '',\n            remoteAddr: '',\n            callID: '',\n            localID: '',\n            remoteID: '',\n            origID: '',\n            fromTag: '',\n            toTag: '',\n            timestamp: {\n                start: '',\n                stop: ''\n            },\n\n            netType: {},\n\n            packetLost: 0,\n            packetsReceived: 0,\n\n            jitterBufferNominal: 0,\n            jitterBufferMax: 0,\n\n            jitterBufferDiscardRate: 0,\n\n            totalSumJitter: 0,\n            totalIntervalCount: 0,\n\n            NLR: 0,\n            JBM: 0,\n            JBN: 0,\n            JDR: 0,\n            MOSLQ: 0,\n\n            status: false\n        };\n    }\n\n    function addToMap(map, key) {\n        map = map || {};\n        if (key in map) {\n            map[key] = parseInt(map[key]) + 1;\n        } else {\n            map[key] = parseInt(1);\n        }\n        return Object.assign({}, map);\n    }\n\n    var networkTypeMap = {\n        bluetooth: 'Bluetooth',\n        cellular: 'Cellulars',\n        ethernet: 'Ethernet',\n        wifi: 'WiFi',\n        wimax: 'WiMax',\n        '2g': '2G',\n        '3g': '3G',\n        '4g': '4G'\n    };\n\n    //TODO: find relaible way to find network type , use navigator.connection.type?\n    function getNetworkType(connectionType) {\n        var sysNetwork = connectionType.systemNetworkType || 'unknown';\n        var localNetwork = connectionType.local.networkType || ['unknown'];\n        var networkType = !sysNetwork || sysNetwork === 'unknown' ? localNetwork[0] : sysNetwork;\n        return networkType in networkTypeMap ? networkTypeMap[networkType] : networkType;\n    }\n\n    function uuid() {\n        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n            var r = (Math.random() * 16) | 0;\n            var v = c === 'x' ? r : (r & 0x3) | 0x8;\n            return v.toString(16);\n        });\n    }\n\n    function delay(ms) {\n        return new Promise(function(resolve, reject) {\n            setTimeout(resolve, ms);\n        });\n    }\n\n    function extend(dst, src) {\n        return Object.assign(dst || {}, src || {});\n    }\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    /**\n     * @param options\n     * @constructor\n     */\n    function AudioHelper(options) {\n        options = options || {};\n\n        this._enabled = !!options.enabled;\n        this.loadAudio(options);\n    }\n\n    AudioHelper.prototype._playSound = function(url, val, volume) {\n        if (!this._enabled || !url) return this;\n\n        if (!this._audio[url]) {\n            if (val) {\n                this._audio[url] = new Audio();\n                this._audio[url].src = url;\n                this._audio[url].loop = true;\n                this._audio[url].volume = volume;\n                this._audio[url].playPromise = this._audio[url].play();\n            }\n        } else {\n            if (val) {\n                this._audio[url].currentTime = 0;\n                this._audio[url].playPromise = this._audio[url].play();\n            } else {\n                var audio = this._audio[url];\n                if (audio.playPromise !== undefined) {\n                    audio.playPromise.then(function() {\n                        audio.pause();\n                    });\n                }\n            }\n        }\n\n        return this;\n    };\n\n    AudioHelper.prototype.loadAudio = function(options) {\n        this._incoming = options.incoming;\n        this._outgoing = options.outgoing;\n        this._audio = {};\n    };\n\n    AudioHelper.prototype.setVolume = function(volume) {\n        if (volume < 0) {\n            volume = 0;\n        }\n        if (volume > 1) {\n            volume = 1;\n        }\n        this.volume = volume;\n        for (var url in this._audio) {\n            if (this._audio.hasOwnProperty(url)) {\n                this._audio[url].volume = volume;\n            }\n        }\n    };\n\n    AudioHelper.prototype.playIncoming = function(val) {\n        return this._playSound(this._incoming, val, this.volume || 0.5);\n    };\n\n    AudioHelper.prototype.playOutgoing = function(val) {\n        return this._playSound(this._outgoing, val, this.volume || 1);\n    };\n\n    /*--------------------------------------------------------------------------------------------------------------------*/\n\n    return WebPhone;\n});\n"},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/ringcentral.js":function(n,e){n.exports="(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(undefined), require(undefined), require(undefined));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"pubnub\", \"es6-promise\", \"fetch-ponyfill\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SDK\"] = factory(require(undefined), require(undefined), require(undefined));\n\telse\n\t\troot[\"RingCentral\"] = root[\"RingCentral\"] || {}, root[\"RingCentral\"][\"SDK\"] = factory(root[undefined], root[undefined], root[undefined]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_12__, __WEBPACK_EXTERNAL_MODULE_13__, __WEBPACK_EXTERNAL_MODULE_14__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/build/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n/**\n * @namespace RingCentral\n */\nvar objectAssign = __webpack_require__(1);\nvar Cache = __webpack_require__(2);\nvar Client = __webpack_require__(3);\nvar Externals = __webpack_require__(11);\nvar Platform = __webpack_require__(15);\nvar Subscription = __webpack_require__(18);\nvar CachedSubscription = __webpack_require__(19);\nvar Constants = __webpack_require__(17);\n\n/**\n * @constructor\n * @param {string} options.server\n * @param {string} options.appSecret\n * @param {string} options.appKey\n * @param {string} [options.cachePrefix]\n * @param {string} [options.appName]\n * @param {string} [options.appVersion]\n * @param {string} [options.redirectUri]\n * @param {PubNub} [options.PubNub]\n * @param {function(new:Promise)} [options.Promise]\n * @param {Storage} [options.localStorage]\n * @param {fetch} [options.fetch]\n * @param {function(new:Request)} [options.Request]\n * @param {function(new:Response)} [options.Response]\n * @param {function(new:Headers)} [options.Headers]\n * @param {int} [options.refreshDelayMs]\n * @param {int} [options.refreshHandicapMs]\n * @param {boolean} [options.clearCacheOnRefreshError]\n * @property {Externals} _externals\n * @property {Cache} _cache\n * @property {Client} _client\n * @property {Platform} _platform\n */\nfunction SDK(options) {\n\n    /** @private */\n    this._externals = new Externals(options);\n\n    /** @private */\n    this._cache = new Cache({\n        externals: this._externals,\n        prefix: options.cachePrefix\n    });\n\n    /** @private */\n    this._client = new Client(this._externals);\n\n    /** @private */\n    this._platform = new Platform(objectAssign({}, options, {\n        externals: this._externals,\n        client: this._client,\n        cache: this._cache\n    }));\n\n}\n\nSDK.version = Constants.version;\n\nSDK.server = {\n    sandbox: 'https://platform.devtest.ringcentral.com',\n    production: 'https://platform.ringcentral.com'\n};\n\n/**\n * @return {Platform}\n */\nSDK.prototype.platform = function() {\n    return this._platform;\n};\n\n/**\n * @return {Cache}\n */\nSDK.prototype.cache = function() {\n    return this._cache;\n};\n\n/**\n * @param {int} [options.pollInterval]\n * @param {int} [options.renewHandicapMs]\n * @return {Subscription}\n */\nSDK.prototype.createSubscription = function(options) {\n    return new Subscription(objectAssign({}, options, {\n        externals: this._externals,\n        platform: this._platform\n    }));\n};\n\n/**\n * @param {string} options.cacheKey\n * @param {int} [options.pollInterval]\n * @param {int} [options.renewHandicapMs]\n * @return {CachedSubscription}\n */\nSDK.prototype.createCachedSubscription = function(options) {\n\n    if (typeof arguments[0] === 'string') {\n        options = {cacheKey: arguments[0].toString()};\n    } else {\n        options = options || {};\n    }\n\n    return new CachedSubscription(objectAssign({}, options, {\n        externals: this._externals,\n        platform: this._platform,\n        cache: this._cache\n    }));\n\n};\n\nSDK.handleLoginRedirect = function(origin, win) {\n\n    win = win || window;\n\n    var response = win.location.hash ? win.location.hash : win.location.search;\n    var msg = {};\n    msg[Constants.authResponseProperty] = response;\n    win.opener.postMessage(msg, origin || win.location.origin);\n\n};\n\nmodule.exports = SDK;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n/**\n * @param {Externals} options.externals\n * @param {string} [options.prefix]\n * @property {Externals} _externals\n */\nfunction Cache(options) {\n\n    /** @private */\n    this._prefix = options.prefix || Cache.defaultPrefix;\n\n    /** @private */\n    this._externals = options.externals;\n\n}\n\nCache.defaultPrefix = 'rc-';\n\nCache.prototype.setItem = function(key, data) {\n    this._externals.localStorage[this._prefixKey(key)] = JSON.stringify(data);\n    return this;\n};\n\nCache.prototype.removeItem = function(key) {\n    delete this._externals.localStorage[this._prefixKey(key)];\n    return this;\n};\n\nCache.prototype.getItem = function(key) {\n    var item = this._externals.localStorage[this._prefixKey(key)];\n    if (!item) return null;\n    return JSON.parse(item);\n};\n\nCache.prototype.clean = function() {\n\n    for (var key in this._externals.localStorage) {\n\n        /* istanbul ignore next */\n        if (!this._externals.localStorage.hasOwnProperty(key)) continue;\n\n        if (key.indexOf(this._prefix) === 0) {\n            delete this._externals.localStorage[key];\n        }\n\n    }\n\n    return this;\n\n};\n\nCache.prototype._prefixKey = function(key) {\n    return this._prefix + key;\n};\n\nmodule.exports = Cache;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar isPlainObject = __webpack_require__(4);\nvar EventEmitter = __webpack_require__(6).EventEmitter;\nvar ApiResponse = __webpack_require__(7);\nvar qs = __webpack_require__(8);\n\nfunction findHeaderName(name, headers) {\n    name = name.toLowerCase();\n    return Object.keys(headers).reduce(function(res, key) {\n        if (res) return res;\n        if (name == key.toLowerCase()) return key;\n        return res;\n    }, null);\n}\n\n/**\n * @param {Externals} externals\n * @property {Externals} _externals\n */\nfunction Client(externals) {\n\n    EventEmitter.call(this);\n\n    /** @private */\n    this._externals = externals;\n\n    this.events = {\n        beforeRequest: 'beforeRequest',\n        requestSuccess: 'requestSuccess',\n        requestError: 'requestError'\n    };\n\n}\n\nClient._allowedMethods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'];\n\nClient.prototype = Object.create(EventEmitter.prototype);\n\n/**\n * @param {Request} request\n * @return {Promise<ApiResponse>}\n */\nClient.prototype.sendRequest = function(request) {\n\n    var apiResponse = new ApiResponse({\n        externals: this._externals,\n        request: request\n    });\n\n    return (new this._externals.Promise(function(resolve) {\n\n        //TODO Stop request if listeners return false\n        this.emit(this.events.beforeRequest, apiResponse);\n\n        resolve(this._loadResponse(request));\n\n    }.bind(this))).then(function(response) {\n\n        return apiResponse.receiveResponse(response);\n\n    }).then(function() {\n\n        if (!apiResponse.ok()) throw new Error('Response has unsuccessful status');\n\n        this.emit(this.events.requestSuccess, apiResponse);\n\n        return apiResponse;\n\n    }.bind(this)).catch(function(e) {\n\n        if (!e.apiResponse) e = this.makeError(e, apiResponse);\n\n        this.emit(this.events.requestError, e);\n\n        throw e;\n\n    }.bind(this));\n\n};\n\n/**\n * @param {Request} request\n * @return {Promise<Response>}\n * @private\n */\nClient.prototype._loadResponse = function(request) {\n    return this._externals.fetch.call(null, request);\n};\n\n/**\n * Wraps the JS Error object with transaction information\n * @param {Error|IApiError} e\n * @param {ApiResponse} apiResponse\n * @return {IApiError}\n */\nClient.prototype.makeError = function(e, apiResponse) {\n\n    // Wrap only if regular error\n    if (!e.hasOwnProperty('apiResponse') && !e.hasOwnProperty('originalMessage')) {\n\n        e.apiResponse = apiResponse;\n        e.originalMessage = e.message;\n        e.message = (apiResponse && apiResponse.error(true)) || e.originalMessage;\n\n    }\n\n    return e;\n\n};\n\n/**\n *\n * @param {object} init\n * @param {object} [init.url]\n * @param {object} [init.body]\n * @param {string} [init.method]\n * @param {object} [init.query]\n * @param {object} [init.headers]\n * @param {object} [init.credentials]\n * @param {object} [init.mode]\n * @return {Request}\n */\nClient.prototype.createRequest = function(init) {\n\n    init = init || {};\n    init.headers = init.headers || {};\n\n    // Sanity checks\n    if (!init.url) throw new Error('Url is not defined');\n    if (!init.method) init.method = 'GET';\n    init.method = init.method.toUpperCase();\n    if (init.method && Client._allowedMethods.indexOf(init.method) < 0) {\n        throw new Error('Method has wrong value: ' + init.method);\n    }\n\n    // Defaults\n    init.credentials = init.credentials || 'include';\n    init.mode = init.mode || 'cors';\n\n    // Append Query String\n    if (init.query) {\n        init.url = init.url + (init.url.indexOf('?') > -1 ? '&' : '?') + qs.stringify(init.query);\n    }\n\n    if (!(findHeaderName('Accept', init.headers))) {\n        init.headers.Accept = ApiResponse._jsonContentType;\n    }\n\n    // Serialize body\n    if (isPlainObject(init.body) || !init.body) {\n\n        var contentTypeHeaderName = findHeaderName(ApiResponse._contentType, init.headers);\n\n        if (!contentTypeHeaderName) {\n            contentTypeHeaderName = ApiResponse._contentType;\n            init.headers[contentTypeHeaderName] = ApiResponse._jsonContentType;\n        }\n\n        var contentType = init.headers[contentTypeHeaderName];\n\n        // Assign a new encoded body\n        if (contentType.indexOf(ApiResponse._jsonContentType) > -1) {\n            if ((init.method === 'GET' || init.method === 'HEAD') && !!init.body) {\n                // oddly setting body to null still result in TypeError in phantomjs\n                init.body = undefined;\n            } else {\n                init.body = JSON.stringify(init.body);\n            }\n\n        } else if (contentType.indexOf(ApiResponse._urlencodedContentType) > -1) {\n            init.body = qs.stringify(init.body);\n        }\n\n    }\n\n    // Create a request with encoded body\n    var req = new this._externals.Request(init.url, init);\n\n    // Keep the original body accessible directly (for mocks)\n    req.originalBody = init.body;\n\n    return req;\n\n};\n\n/**\n * @typedef {object} IApiError\n * @property {string} stack\n * @property {string} originalMessage\n * @property {ApiResponse} apiResponse\n */\n\nmodule.exports = Client;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = __webpack_require__(5);\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n/**\n * @param {Externals} options.externals\n * @param {Request} [options.request]\n * @param {Response} [options.response]\n * @param {string} [options.responseText]\n * @property {Externals} _externals\n * @property {Request} _request\n * @property {Response} _response\n * @property {string} _text\n * @property {object} _json\n * @property {ApiResponse[]} _multipart\n */\nfunction ApiResponse(options) {\n\n    /** @private */\n    this._externals = options.externals;\n\n    /** @private */\n    this._request = options.request;\n\n    /** @private */\n    this._response = options.response;\n\n    /** @private */\n    this._text = options.responseText || '';\n\n    /** @private */\n    this._json = null;\n\n    /** @private */\n    this._multipart = [];\n\n}\n\nApiResponse._contentType = 'Content-Type';\nApiResponse._jsonContentType = 'application/json';\nApiResponse._multipartContentType = 'multipart/mixed';\nApiResponse._urlencodedContentType = 'application/x-www-form-urlencoded';\nApiResponse._headerSeparator = ':';\nApiResponse._bodySeparator = '\\n\\n';\nApiResponse._boundarySeparator = '--';\nApiResponse._unauthorizedStatus = 401;\nApiResponse._rateLimitStatus = 429;\n\n/**\n * @param {Response} response\n * @return {Promise<ApiResponse>}\n */\nApiResponse.prototype.receiveResponse = function(response) {\n\n    this._response = response;\n\n    return (new this._externals.Promise(function(resolve) {\n\n        // Ignore if not textual type\n        if (!this._isMultipart() && !this._isJson()) return resolve('');\n\n        return resolve(this.response().text());\n\n    }.bind(this))).then(function(text) {\n\n        this._text = text;\n        return text;\n\n    }.bind(this));\n\n};\n\n/**\n * @return {Response}\n */\nApiResponse.prototype.response = function() {\n    return this._response;\n};\n\n/**\n * @return {Request}\n */\nApiResponse.prototype.request = function() {\n    return this._request;\n};\n\n/**\n * @return {boolean}\n */\nApiResponse.prototype.ok = function() {\n    return this._response && this._response.ok;\n};\n\n/**\n * @return {string}\n */\nApiResponse.prototype.text = function() {\n    // Since we read text only in case JSON or Multipart\n    if (!this._isJson() && !this._isMultipart()) throw new Error('Response is not text');\n    return this._text;\n};\n\n/**\n * @return {object}\n */\nApiResponse.prototype.json = function() {\n    if (!this._isJson()) throw new Error('Response is not JSON');\n    if (!this._json) {\n        this._json = this._text ? JSON.parse(this._text) : null;\n    }\n    return this._json;\n};\n\n/**\n * @param [skipOKCheck]\n * @return {string}\n */\nApiResponse.prototype.error = function(skipOKCheck) {\n\n    if (this.ok() && !skipOKCheck) return null;\n\n    var message = (this._response && this._response.status ? this._response.status + ' ' : '') +\n                  (this._response && this._response.statusText ? this._response.statusText : '');\n\n    try {\n\n        if (this.json().message) message = this.json().message;\n        if (this.json().error_description) message = this.json().error_description;\n        if (this.json().description) message = this.json().description;\n\n    } catch (e) {}\n\n    return message;\n\n};\n\n/**\n * If it is not known upfront what would be the response, client code can treat any response as multipart\n * @return {ApiResponse[]}\n */\nApiResponse.prototype.toMultipart = function() {\n    if (!this._isMultipart()) return [this];\n    return this.multipart();\n};\n\n/**\n * @return {ApiResponse[]}\n */\nApiResponse.prototype.multipart = function() {\n\n    if (!this._isMultipart()) throw new Error('Response is not multipart');\n\n    if (!this._multipart.length) {\n\n        // Step 1. Split multipart response\n\n        var text = this.text();\n\n        if (!text) throw new Error('No response body');\n\n        var boundary;\n\n        try {\n            boundary = this._getContentType().match(/boundary=([^;]+)/i)[1];\n        } catch (e) {\n            throw new Error('Cannot find boundary');\n        }\n\n        if (!boundary) throw new Error('Cannot find boundary');\n\n        var parts = text.toString().split(ApiResponse._boundarySeparator + boundary);\n\n        if (parts[0].trim() === '') parts.shift();\n        if (parts[parts.length - 1].trim() == ApiResponse._boundarySeparator) parts.pop();\n\n        if (parts.length < 1) throw new Error('No parts in body');\n\n        // Step 2. Parse status info\n\n        var statusInfo = this._create(parts.shift(), this._response.status, this._response.statusText).json();\n\n        // Step 3. Parse all other parts\n\n        this._multipart = parts.map(function(part, i) {\n\n            var status = statusInfo.response[i].status;\n\n            return this._create(part, status);\n\n        }.bind(this));\n\n    }\n\n    return this._multipart;\n\n};\n\n/**\n * @private\n */\nApiResponse.prototype._isContentType = function(contentType) {\n    return this._getContentType().indexOf(contentType) > -1;\n};\n\n/**\n * @private\n */\nApiResponse.prototype._getContentType = function() {\n    return this._response.headers.get(ApiResponse._contentType) || '';\n};\n\n/**\n * @private\n */\nApiResponse.prototype._isMultipart = function() {\n    return this._isContentType(ApiResponse._multipartContentType);\n};\n\n/**\n * @private\n */\nApiResponse.prototype._isJson = function() {\n    return this._isContentType(ApiResponse._jsonContentType);\n};\n\n/**\n * Method is used to create ApiResponse object from string parts of multipart/mixed response\n * @param {string} [text]\n * @param {number} [status]\n * @param {string} [statusText]\n * @private\n * @return {ApiResponse}\n */\nApiResponse.prototype._create = function(text, status, statusText) {\n\n    text = text || '';\n    status = status || 200;\n    statusText = statusText || 'OK';\n\n    text = text.replace(/\\r/g, '');\n\n    var headers = new this._externals.Headers(),\n        headersAndBody = text.split(ApiResponse._bodySeparator),\n        headersText = (headersAndBody.length > 1) ? headersAndBody.shift() : '';\n\n    text = headersAndBody.length > 0 ? headersAndBody.join(ApiResponse._bodySeparator) : null;\n\n    (headersText || '')\n        .split('\\n')\n        .forEach(function(header) {\n\n            var split = header.trim().split(ApiResponse._headerSeparator),\n                key = split.shift().trim(),\n                value = split.join(ApiResponse._headerSeparator).trim();\n\n            if (key) headers.append(key, value);\n\n        });\n\n    var response = new this._externals.Response(text, {\n        headers: headers,\n        status: status,\n        statusText: statusText\n    });\n\n    return new ApiResponse({\n        externals: this._externals,\n        request: null,\n        response: response,\n        responseText: text\n    });\n\n};\n\nmodule.exports = ApiResponse;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n'use strict';\n\nexports.decode = exports.parse = __webpack_require__(9);\nexports.encode = exports.stringify = __webpack_require__(10);\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (Array.isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return Object.keys(obj).map(function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (Array.isArray(obj[k])) {\n        return obj[k].map(function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {var pubnub = __webpack_require__(12);\nvar es6Promise = __webpack_require__(13);\nvar FetchPonyfill = __webpack_require__(14);\n\nvar root = (typeof window !== \"undefined\" && window) ||\n           (typeof global !== \"undefined\" && global) ||\n           (function(){ return this; })();\n\n/**\n * @constructor\n * @param {PubNub} [options.PubNub]\n * @param {function(new:Promise)} [options.Promise]\n * @param {Storage} [options.localStorage]\n * @param {fetch} [options.fetch]\n * @param {function(new:Request)} [options.Request]\n * @param {function(new:Response)} [options.Response]\n * @param {function(new:Headers)} [options.Headers]\n * @property {PubNub} PubNub\n * @property {Storage} localStorage\n * @property {function(new:Promise)} Promise\n * @property {fetch} fetch\n * @property {function(new:Request)} Request\n * @property {function(new:Response)} Response\n * @property {function(new:Headers)} Headers\n */\nfunction Externals(options) {\n\n    options = options || {};\n\n    this.PubNub = options.PubNub || root.PubNub || pubnub;\n    this.localStorage = options.localStorage || ((typeof root.localStorage !== 'undefined') ? root.localStorage : {});\n    this.Promise = options.Promise || root.Promise || (es6Promise && es6Promise.Promise);\n\n    var fetchPonyfill = FetchPonyfill ? FetchPonyfill({Promise: this.Promise}) : {};\n\n    this.fetch = options.fetch || root.fetch || fetchPonyfill.fetch;\n    this.Request = options.Request || root.Request || fetchPonyfill.Request;\n    this.Response = options.Response || root.Response || fetchPonyfill.Response;\n    this.Headers = options.Headers || root.Headers || fetchPonyfill.Headers;\n\n    /* istanbul ignore next */\n    if (!this.fetch || !this.Response || !this.Request || !this.Headers) {\n        throw new Error('Fetch API is missing');\n    }\n\n    /* istanbul ignore next */\n    if (!this.Promise) {\n        throw new Error('Promise is missing');\n    }\n\n    /* istanbul ignore next */\n    if (!this.localStorage) {\n        throw new Error('LocalStorage is missing');\n    }\n\n    /* istanbul ignore next */\n    if (!this.PubNub) {\n        throw new Error('PubNub is missing');\n    }\n\n}\n\nmodule.exports = Externals;\n\n/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_12__;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_13__;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar EventEmitter = __webpack_require__(6).EventEmitter;\nvar qs = __webpack_require__(8);\nvar objectAssign = __webpack_require__(1);\nvar Auth = __webpack_require__(16);\nvar Constants = __webpack_require__(17);\nvar ApiResponse = __webpack_require__(7);\n\n/**\n * @constructor\n * @param {string} options.server\n * @param {string} options.appSecret\n * @param {string} options.appKey\n * @param {string} [options.appName]\n * @param {string} [options.appVersion]\n * @param {string} [options.redirectUri]\n * @param {int} [options.refreshDelayMs]\n * @param {int} [options.refreshHandicapMs]\n * @param {boolean} [options.clearCacheOnRefreshError]\n * @param {Externals} options.externals\n * @param {Cache} options.cache\n * @param {Client} options.client\n * @property {Externals} _externals\n * @property {Cache} _cache\n * @property {Client} _client\n * @property {Promise<ApiResponse>} _refreshPromise\n * @property {Auth} _auth\n */\nfunction Platform(options) {\n\n    EventEmitter.call(this);\n\n    this.events = {\n        beforeLogin: 'beforeLogin',\n        loginSuccess: 'loginSuccess',\n        loginError: 'loginError',\n        beforeRefresh: 'beforeRefresh',\n        refreshSuccess: 'refreshSuccess',\n        refreshError: 'refreshError',\n        beforeLogout: 'beforeLogout',\n        logoutSuccess: 'logoutSuccess',\n        logoutError: 'logoutError',\n        rateLimitError: 'rateLimitError'\n    };\n\n    options = options || {};\n\n    /** @private */\n    this._server = options.server;\n\n    /** @private */\n    this._appKey = options.appKey;\n\n    /** @private */\n    this._appSecret = options.appSecret;\n\n    /** @private */\n    this._redirectUri = options.redirectUri || '';\n\n    /** @private */\n    this._refreshDelayMs = options.refreshDelayMs || 100;\n\n    /** @private */\n    this._clearCacheOnRefreshError = typeof options.clearCacheOnRefreshError !== 'undefined' ?\n                                     options.clearCacheOnRefreshError :\n                                     true;\n\n    /** @private */\n    this._userAgent = (options.appName ?\n                      (options.appName + (options.appVersion ? '/' + options.appVersion : '')) + ' ' :\n                       '') + 'RCJSSDK/' + Constants.version;\n\n    /** @private */\n    this._externals = options.externals;\n\n    /** @private */\n    this._cache = options.cache;\n\n    /** @private */\n    this._client = options.client;\n\n    /** @private */\n    this._knownPrefixes = options.knownPrefixes || Platform._knownPrefixes;\n\n\n    /** @private */\n    this._refreshPromise = null;\n\n    /** @private */\n    this._auth = new Auth({\n        cache: this._cache,\n        cacheId: Platform._cacheId,\n        refreshHandicapMs: options.refreshHandicapMs\n    });\n\n}\n\nPlatform._urlPrefix = '/restapi';\nPlatform._apiVersion = 'v1.0';\nPlatform._knownPrefixes = ['/rcvideo'];\nPlatform._tokenEndpoint = '/restapi/oauth/token';\nPlatform._revokeEndpoint = '/restapi/oauth/revoke';\nPlatform._authorizeEndpoint = '/restapi/oauth/authorize';\nPlatform._cacheId = 'platform';\n\nPlatform.prototype = Object.create(EventEmitter.prototype);\n\nPlatform.prototype.delay = function(timeout) {\n    return new this._externals.Promise(function(resolve, reject) {\n        setTimeout(function() {\n            resolve(null);\n        }, timeout);\n    });\n};\n\n/**\n * @return {Auth}\n */\nPlatform.prototype.auth = function() {\n    return this._auth;\n};\n\n/**\n * @return {Client}\n */\nPlatform.prototype.client = function() {\n    return this._client;\n};\n\n/**\n * @param {string} path\n * @param {object} [options]\n * @param {boolean} [options.addServer]\n * @param {string} [options.addMethod]\n * @param {boolean} [options.addToken]\n * @return {string}\n */\nPlatform.prototype.createUrl = function(path, options) {\n\n    path = path || '';\n    options = options || {};\n\n    var builtUrl = '',\n        hasHttp = path.indexOf('http://') != -1 || path.indexOf('https://') != -1,\n        alreadyPrefixed = this._knownPrefixes.some(function(prefix) {\n            return path.indexOf(prefix) === 0;\n        });\n\n    if (options.addServer && !hasHttp) builtUrl += this._server;\n\n    if (path.indexOf(Platform._urlPrefix) == -1 && !hasHttp && !alreadyPrefixed) {\n        builtUrl += Platform._urlPrefix + '/' + Platform._apiVersion;\n    }\n\n    builtUrl += path;\n\n    if (options.addMethod || options.addToken) builtUrl += (path.indexOf('?') > -1 ? '&' : '?');\n\n    if (options.addMethod) builtUrl += '_method=' + options.addMethod;\n    if (options.addToken) builtUrl += (options.addMethod ? '&' : '') + 'access_token=' + this._auth.accessToken();\n\n    return builtUrl;\n\n};\n\n/**\n * @param {string} [options.redirectUri] Overrides default RedirectURI\n * @param {string} [options.state]\n * @param {string} [options.brandId]\n * @param {string} [options.display]\n * @param {string} [options.prompt]\n * @param {boolean} [options.implicit] Use Implicit Grant flow\n * @return {string}\n */\nPlatform.prototype.loginUrl = function(options) {\n\n    options = options || {};\n\n    return this.createUrl(Platform._authorizeEndpoint + '?' + qs.stringify({\n            'response_type': options.implicit ? 'token' : 'code',\n            'redirect_uri': options.redirectUri || this._redirectUri,\n            'client_id': this._appKey,\n            'state': options.state || '',\n            'brand_id': options.brandId || '',\n            'display': options.display || '',\n            'prompt': options.prompt || ''\n        }), {addServer: true});\n\n};\n\n/**\n * @param {string} url\n * @return {Object}\n */\nPlatform.prototype.parseLoginRedirect = function(url) {\n\n    function getParts(url, separator) {\n        return url.split(separator).reverse()[0];\n    }\n\n    var response = (url.indexOf('#') === 0 && getParts(url, '#')) ||\n                   (url.indexOf('?') === 0 && getParts(url, '?')) ||\n                   null;\n\n    if (!response) throw new Error('Unable to parse response');\n\n    var queryString = qs.parse(response);\n\n    if (!queryString) throw new Error('Unable to parse response');\n\n    var error = queryString.error_description || queryString.error;\n\n    if (error) {\n        var e = new Error(error);\n        e.error = queryString.error;\n        throw e;\n    }\n\n    return queryString;\n\n};\n\n/**\n * Convenience method to handle 3-legged OAuth\n *\n * Attention! This is an experimental method and it's signature and behavior may change without notice.\n *\n * @experimental\n * @param {string} options.url\n * @param {number} [options.width]\n * @param {number} [options.height]\n * @param {object} [options.login] additional options for login()\n * @param {string} [options.origin]\n * @param {string} [options.property] name of window.postMessage's event data property\n * @param {string} [options.target] target for window.open()\n * @return {Promise}\n */\nPlatform.prototype.loginWindow = function(options) {\n\n    return new this._externals.Promise(function(resolve, reject) {\n\n        if (typeof window === 'undefined') throw new Error('This method can be used only in browser');\n\n        if (!options.url) throw new Error('Missing mandatory URL parameter');\n\n        options = options || {};\n        options.width = options.width || 400;\n        options.height = options.height || 600;\n        options.origin = options.origin || window.location.origin;\n        options.property = options.property || Constants.authResponseProperty;\n        options.target = options.target || '_blank';\n\n        var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;\n        var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;\n\n        var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width;\n        var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\n        var left = ((width / 2) - (options.width / 2)) + dualScreenLeft;\n        var top = ((height / 2) - (options.height / 2)) + dualScreenTop;\n        var win = window.open(options.url, '_blank', (options.target == '_blank') ? 'scrollbars=yes, status=yes, width=' + options.width + ', height=' + options.height + ', left=' + left + ', top=' + top : '');\n\n        if (!win) {\n            throw new Error('Could not open login window. Please allow popups for this site');\n        }\n\n        if (win.focus) win.focus();\n\n        var eventMethod = window.addEventListener ? 'addEventListener' : 'attachEvent';\n        var eventRemoveMethod = eventMethod == 'addEventListener' ? 'removeEventListener' : 'detachEvent';\n        var messageEvent = eventMethod == 'addEventListener' ? 'message' : 'onmessage';\n\n        var eventListener = function(e) {\n\n            try {\n\n                if (e.origin != options.origin) return;\n                if (!e.data || !e.data[options.property]) return; // keep waiting\n\n                win.close();\n                window[eventRemoveMethod](messageEvent, eventListener);\n\n\n                var loginOptions = this.parseLoginRedirect(e.data[options.property]);\n\n                if (!loginOptions.code && !loginOptions.access_token) throw new Error('No authorization code or token');\n\n                resolve(loginOptions);\n\n                /* jshint -W002 */\n            } catch (e) {\n                reject(e);\n            }\n\n        }.bind(this);\n\n        window[eventMethod](messageEvent, eventListener, false);\n\n    }.bind(this));\n\n};\n\n/**\n * @return {Promise<boolean>}\n */\nPlatform.prototype.loggedIn = function() {\n\n    return this.ensureLoggedIn().then(function() {\n        return true;\n    }).catch(function() {\n        return false;\n    });\n\n};\n\n/**\n * @param {string} options.username\n * @param {string} options.password\n * @param {string} [options.extension]\n * @param {string} [options.code]\n * @param {string} [options.redirectUri]\n * @param {string} [options.endpointId]\n * @param {string} [options.accessTokenTtl]\n * @param {string} [options.refreshTokenTtl]\n * @param {string} [options.access_token]\n * @returns {Promise<ApiResponse>}\n */\nPlatform.prototype.login = function(options) {\n\n    return (new this._externals.Promise(function(resolve) {\n\n        options = options || {};\n\n        this.emit(this.events.beforeLogin);\n\n        var body = {};\n\n        if (options.access_token) {\n\n            //TODO Potentially make a request to /oauth/tokeninfo\n            return resolve(options);\n\n        }\n\n        if (!options.code) {\n\n            body.grant_type = 'password';\n            body.username = options.username;\n            body.password = options.password;\n            body.extension = options.extension || '';\n\n        } else if (options.code) {\n\n            body.grant_type = 'authorization_code';\n            body.code = options.code;\n            body.redirect_uri = options.redirectUri || this._redirectUri;\n            //body.client_id = this.getCredentials().key; // not needed\n\n        }\n\n        if (options.endpointId) body.endpoint_id = options.endpointId;\n        if (options.accessTokenTtl) body.accessTokenTtl = options.accessTokenTtl;\n        if (options.refreshTokenTtl) body.refreshTokenTtl = options.refreshTokenTtl;\n\n        resolve(this._tokenRequest(Platform._tokenEndpoint, body));\n\n    }.bind(this))).then(function(res) {\n\n        var apiResponse = res.json ? res : null;\n        var json = apiResponse && apiResponse.json() || res;\n\n        this._auth.setData(json);\n\n        this.emit(this.events.loginSuccess, apiResponse);\n\n        return apiResponse;\n\n    }.bind(this)).catch(function(e) {\n\n        if (this._clearCacheOnRefreshError) {\n            this._cache.clean();\n        }\n\n        this.emit(this.events.loginError, e);\n\n        throw e;\n\n    }.bind(this));\n\n};\n\n/**\n * @returns {Promise<ApiResponse>}\n * @private\n */\nPlatform.prototype._refresh = function() {\n\n    return this.delay(this._refreshDelayMs).then(function() {\n\n        this.emit(this.events.beforeRefresh);\n\n        // Perform sanity checks\n        if (!this._auth.refreshToken()) throw new Error('Refresh token is missing');\n        if (!this._auth.refreshTokenValid()) throw new Error('Refresh token has expired');\n\n        return this._tokenRequest(Platform._tokenEndpoint, {\n            \"grant_type\": \"refresh_token\",\n            \"refresh_token\": this._auth.refreshToken(),\n            \"access_token_ttl\": this._auth.data().expires_in + 1,\n            \"refresh_token_ttl\": this._auth.data().refresh_token_expires_in + 1\n        });\n\n    }.bind(this)).then(function(/** @type {ApiResponse} */ res) {\n\n        var json = res.json();\n\n        if (!json.access_token) {\n            throw this._client.makeError(new Error('Malformed OAuth response'), res);\n        }\n\n        this._auth.setData(json);\n\n        this.emit(this.events.refreshSuccess, res);\n\n        return res;\n\n    }.bind(this)).catch(function(e) {\n\n        e = this._client.makeError(e);\n\n        if (this._clearCacheOnRefreshError) {\n            this._cache.clean();\n        }\n\n        this.emit(this.events.refreshError, e);\n\n        throw e;\n\n    }.bind(this));\n\n};\n\n/**\n * @returns {Promise<ApiResponse>}\n */\nPlatform.prototype.refresh = function() {\n\n    if (!this._refreshPromise) {\n\n        this._refreshPromise = this._refresh()\n            .then(function(res) {\n                this._refreshPromise = null;\n                return res;\n            }.bind(this))\n            .catch(function(e) {\n                this._refreshPromise = null;\n                throw e;\n            }.bind(this));\n\n    }\n\n    return this._refreshPromise;\n\n};\n\n/**\n * @returns {Promise<ApiResponse>}\n */\nPlatform.prototype.logout = function() {\n\n    return (new this._externals.Promise(function(resolve) {\n\n        this.emit(this.events.beforeLogout);\n\n        resolve(this._tokenRequest(Platform._revokeEndpoint, {\n            token: this._auth.accessToken()\n        }));\n\n    }.bind(this))).then(function(res) {\n\n        this._cache.clean();\n\n        this.emit(this.events.logoutSuccess, res);\n\n        return res;\n\n    }.bind(this)).catch(function(e) {\n\n        this.emit(this.events.logoutError, e);\n\n        throw e;\n\n    }.bind(this));\n\n};\n\n/**\n * @param {Request} request\n * @param {object} [options]\n * @param {boolean} [options.skipAuthCheck]\n * @return {Promise<Request>}\n */\nPlatform.prototype.inflateRequest = function(request, options) {\n\n    options = options || {};\n\n    if (options.skipAuthCheck) return this._externals.Promise.resolve(request);\n\n    return this.ensureLoggedIn().then(function() {\n\n        request.headers.set('X-User-Agent', this._userAgent);\n        request.headers.set('Client-Id', this._appKey);\n        request.headers.set('Authorization', this._authHeader());\n        //request.url = this.createUrl(request.url, {addServer: true}); //FIXME Spec prevents this...\n\n        return request;\n\n    }.bind(this));\n\n};\n\n/**\n * @param {Request} request\n * @param {object} [options]\n * @param {boolean} [options.skipAuthCheck]\n * @param {boolean|int} [options.handleRateLimit]\n * @param {boolean} [options.retry] Will be set by this method if SDK makes second request\n * @return {Promise<ApiResponse>}\n */\nPlatform.prototype.sendRequest = function(request, options) {\n\n    return this.inflateRequest(request, options).then(function(request) {\n\n        options = options || {};\n\n        return this._client.sendRequest(request);\n\n    }.bind(this)).catch(function(e) {\n\n        // Guard is for errors that come from polling\n        if (!e.apiResponse || !e.apiResponse.response() || options.retry) throw e;\n\n        var response = e.apiResponse.response();\n        var status = response.status;\n\n        if ((status != ApiResponse._unauthorizedStatus) &&\n            (status != ApiResponse._rateLimitStatus)) throw e;\n\n        options.retry = true;\n\n        var retryAfter = 0;\n\n        if (status == ApiResponse._unauthorizedStatus) {\n            this._auth.cancelAccessToken();\n        }\n\n        if (status == ApiResponse._rateLimitStatus) {\n\n            var defaultRetryAfter = (!options.handleRateLimit || typeof options.handleRateLimit == 'boolean' ? 60 : options.handleRateLimit);\n\n            // FIXME retry-after is custom header, by default, it can't be retrieved. Server should add header: 'Access-Control-Expose-Headers: retry-after'.\n            retryAfter = parseFloat(response.headers.get('retry-after') || defaultRetryAfter) * 1000;\n\n            e.retryAfter = retryAfter;\n\n            this.emit(this.events.rateLimitError, e);\n\n            if (!options.handleRateLimit) throw e;\n\n        }\n\n        return this.delay(retryAfter).then(function() {\n            return this.sendRequest(request, options);\n        }.bind(this));\n\n    }.bind(this));\n\n};\n\n/**\n * General purpose function to send anything to server\n * @param {string} options.url\n * @param {object} [options.body]\n * @param {string} [options.method]\n * @param {object} [options.query]\n * @param {object} [options.headers]\n * @param {boolean} [options.skipAuthCheck]\n * @param {boolean|int} [options.handleRateLimit]\n * @return {Promise<ApiResponse>}\n */\nPlatform.prototype.send = function(options) {\n\n    options = options || {};\n\n    //FIXME https://github.com/bitinn/node-fetch/issues/43\n    options.url = this.createUrl(options.url, {addServer: true});\n\n    return this.sendRequest(this._client.createRequest(options), options);\n\n};\n\n/**\n * @param {string} url\n * @param {object} [query]\n * @param {object} [options]\n * @param {object} [options.headers]\n * @param {boolean} [options.skipAuthCheck]\n * @param {boolean|int} [options.handleRateLimit]\n * @return {Promise<ApiResponse>}\n */\nPlatform.prototype.get = function(url, query, options) {\n    return this.send(objectAssign({}, {method: 'GET', url: url, query: query}, options));\n};\n\n/**\n * @param {string} url\n * @param {object} body\n * @param {object} [query]\n * @param {object} [options]\n * @param {object} [options.headers]\n * @param {boolean} [options.skipAuthCheck]\n * @param {boolean|int} [options.handleRateLimit]\n * @return {Promise<ApiResponse>}\n */\nPlatform.prototype.post = function(url, body, query, options) {\n    return this.send(objectAssign({}, {method: 'POST', url: url, query: query, body: body}, options));\n};\n\n/**\n * @param {string} url\n * @param {object} [body]\n * @param {object} [query]\n * @param {object} [options]\n * @param {object} [options.headers]\n * @param {boolean} [options.skipAuthCheck]\n * @param {boolean|int} [options.handleRateLimit]\n * @return {Promise<ApiResponse>}\n */\nPlatform.prototype.put = function(url, body, query, options) {\n    return this.send(objectAssign({}, {method: 'PUT', url: url, query: query, body: body}, options));\n};\n\n/**\n * @param {string} url\n * @param {string} [query]\n * @param {object} [options]\n * @param {object} [options.headers]\n * @param {boolean} [options.skipAuthCheck]\n * @param {boolean|int} [options.handleRateLimit]\n * @return {Promise<ApiResponse>}\n */\nPlatform.prototype['delete'] = function(url, query, options) {\n    return this.send(objectAssign({}, {method: 'DELETE', url: url, query: query}, options));\n};\n\nPlatform.prototype.ensureLoggedIn = function() {\n    if (this._isAccessTokenValid()) return this._externals.Promise.resolve();\n    return this.refresh();\n};\n\n/**\n * @param path\n * @param body\n * @return {Promise.<ApiResponse>}\n * @private\n */\nPlatform.prototype._tokenRequest = function(path, body) {\n\n    return this.send({\n        url: path,\n        skipAuthCheck: true,\n        body: body,\n        method: 'POST',\n        headers: {\n            'Authorization': 'Basic ' + this._apiKey(),\n            'Content-Type': ApiResponse._urlencodedContentType\n        }\n    });\n\n};\n\n/**\n * @return {boolean}\n * @private\n */\nPlatform.prototype._isAccessTokenValid = function() {\n    return this._auth.accessTokenValid();\n};\n\n/**\n * @return {string}\n * @private\n */\nPlatform.prototype._apiKey = function() {\n    var apiKey = this._appKey + ':' + this._appSecret;\n    return (typeof btoa == 'function') ? btoa(apiKey) : new Buffer(apiKey).toString('base64');\n};\n\n/**\n * @return {string}\n * @private\n */\nPlatform.prototype._authHeader = function() {\n    var token = this._auth.accessToken();\n    return this._auth.tokenType() + (token ? ' ' + token : '');\n};\n\nmodule.exports = Platform;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n/**\n * @param {Cache} options.cache\n * @param {string} options.cacheId\n * @param {int} [options.refreshHandicapMs]\n * @constructor\n * @property {Cache} _cache\n * @property {int} _refreshHandicapMs\n * @property {string} _cacheId\n */\nfunction Auth(options) {\n\n    /** @private */\n    this._cache = options.cache;\n\n    /** @private */\n    this._cacheId = options.cacheId;\n\n    /** @private */\n    this._refreshHandicapMs = options.refreshHandicapMs || 60 * 1000; // 1 minute\n\n}\n\nAuth.prototype.accessToken = function() {\n    return this.data().access_token;\n};\n\nAuth.prototype.refreshToken = function() {\n    return this.data().refresh_token;\n};\n\nAuth.prototype.tokenType = function() {\n    return this.data().token_type;\n};\n\n/**\n * @return {{token_type: string, access_token: string, expires_in: number, refresh_token: string, refresh_token_expires_in: number}}\n */\nAuth.prototype.data = function() {\n\n    return this._cache.getItem(this._cacheId) || {\n            token_type: '',\n            access_token: '',\n            expires_in: 0,\n            refresh_token: '',\n            refresh_token_expires_in: 0\n        };\n\n};\n\n/**\n * @param {object} newData\n * @return {Auth}\n */\nAuth.prototype.setData = function(newData) {\n\n    newData = newData || {};\n\n    var data = this.data();\n\n    Object.keys(newData).forEach(function(key) {\n        data[key] = newData[key];\n    });\n\n    data.expire_time = Date.now() + (data.expires_in * 1000);\n    data.refresh_token_expire_time = Date.now() + (data.refresh_token_expires_in * 1000);\n\n    this._cache.setItem(this._cacheId, data);\n\n    return this;\n\n};\n\n/**\n * Check if there is a valid (not expired) access token\n * @return {boolean}\n */\nAuth.prototype.accessTokenValid = function() {\n\n    var authData = this.data();\n    return (authData.expire_time - this._refreshHandicapMs > Date.now());\n\n};\n\n/**\n * Check if there is a valid (not expired) access token\n * @return {boolean}\n */\nAuth.prototype.refreshTokenValid = function() {\n\n    return (this.data().refresh_token_expire_time > Date.now());\n\n};\n\n/**\n * @return {Auth}\n */\nAuth.prototype.cancelAccessToken = function() {\n\n    return this.setData({\n        access_token: '',\n        expires_in: 0\n    });\n\n};\n\nmodule.exports = Auth;\n\n//export interface IAuthData {\n//    remember?:boolean;\n//    token_type?:string;\n//    access_token?:string;\n//    expires_in?:number; // actually it's string\n//    expire_time?:number;\n//    refresh_token?:string;\n//    refresh_token_expires_in?:number; // actually it's string\n//    refresh_token_expire_time?:number;\n//    scope?:string;\n//}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar version = (\"3.2.0\");\n\n// This will become false during the Webpack build, so no traces of package.json will be there\nif (false) {\n    version = require('../../package.json').version;\n}\n\nmodule.exports = {\n    version: version,\n    authResponseProperty: 'RCAuthorizationResponse'\n};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar EventEmitter = __webpack_require__(6).EventEmitter;\n\n// detect ISO 8601 format string with +00[:00] timezone notations\nvar ISO_REG_EXP = /(\\+[\\d]{2}):?([\\d]{2})?$/;\n\nfunction buildIEFriendlyString(match, $1, $2) {\n    return $1 + ':' + ($2 || '00');\n}\n\n/**\n *\n * @param {string} time\n * @return {number}\n */\nfunction parseISOString(time) {\n    time = time || 0;\n    if (typeof time === 'string') {\n        return Date.parse(time.replace(ISO_REG_EXP, buildIEFriendlyString));\n    }\n    return time;\n}\n\n/**\n * @param {Platform} options.platform\n * @param {Externals} options.externals\n * @param {int} [options.pollInterval]\n * @param {int} [options.renewHandicapMs]\n * @property {Externals} _externals\n * @property {Platform} _platform\n * @property {int} _pollInterval\n * @property {int} _renewHandicapMs\n * @property {PubNub} _pubnub\n * @property {string} _pubnubLastChannel\n * @property {int} _timeout\n * @property {ISubscription} _subscription\n * @constructor\n */\nfunction Subscription(options) {\n\n    EventEmitter.call(this);\n\n    options = options || {};\n\n    this.events = {\n        notification: 'notification',\n        removeSuccess: 'removeSuccess',\n        removeError: 'removeError',\n        renewSuccess: 'renewSuccess',\n        renewError: 'renewError',\n        subscribeSuccess: 'subscribeSuccess',\n        subscribeError: 'subscribeError',\n        automaticRenewSuccess: 'automaticRenewSuccess',\n        automaticRenewError: 'automaticRenewError'\n    };\n\n    /** @private */\n    this._externals = options.externals;\n\n    /** @private */\n    this._platform = options.platform;\n\n    /** @private */\n    this._pollInterval = options.pollInterval || 10 * 1000;\n\n    /** @private */\n    this._renewHandicapMs = options.renewHandicapMs || 2 * 60 * 1000;\n\n    /** @private */\n    this._pubnub = null;\n\n    /** @private */\n    this._pubnubLastChannel = null;\n\n    /** @private */\n    this._pubnubLastSubscribeKey = null;\n\n    /** @private */\n    this._timeout = null;\n\n    /** @private */\n    this._subscription = null;\n\n}\n\nSubscription.prototype = Object.create(EventEmitter.prototype);\n\nSubscription.prototype.subscribed = function() {\n\n    var subscription = this.subscription();\n\n    return !!(subscription.id &&\n              subscription.deliveryMode &&\n              subscription.deliveryMode.subscriberKey &&\n              subscription.deliveryMode.address);\n\n};\n\n/**\n * @return {boolean}\n */\nSubscription.prototype.alive = function() {\n    return this.subscribed() && Date.now() < this.expirationTime();\n};\n\n/**\n * @return {boolean}\n */\nSubscription.prototype.expired = function() {\n    if (!this.subscribed()) return true;\n    return !this.subscribed() || Date.now() > parseISOString(this.subscription().expirationTime);\n};\n\n/**\n * @return {number}\n */\nSubscription.prototype.expirationTime = function() {\n    return parseISOString(this.subscription().expirationTime) - this._renewHandicapMs;\n};\n\n/**\n * @param {ISubscription} subscription\n * @return {Subscription}\n */\nSubscription.prototype.setSubscription = function(subscription) {\n\n    subscription = subscription || {};\n\n    this._clearTimeout();\n    this._setSubscription(subscription);\n    this._subscribeAtPubnub();\n    this._setTimeout();\n\n    return this;\n\n};\n\n/**\n * @return {ISubscription}\n */\nSubscription.prototype.subscription = function() {\n    return this._subscription || {};\n};\n\n/**\n * Creates or updates subscription if there is an active one\n * @returns {Promise<ApiResponse>}\n */\nSubscription.prototype.register = function() {\n\n    if (this.alive()) {\n        return this.renew();\n    } else {\n        return this.subscribe();\n    }\n\n};\n\n/**\n * @return {string[]}\n */\nSubscription.prototype.eventFilters = function() {\n    return this.subscription().eventFilters || [];\n};\n\n/**\n * @param {string[]} events\n * @return {Subscription}\n */\nSubscription.prototype.addEventFilters = function(events) {\n    this.setEventFilters(this.eventFilters().concat(events));\n    return this;\n};\n\n/**\n * @param {string[]} events\n * @return {Subscription}\n */\nSubscription.prototype.setEventFilters = function(events) {\n    var subscription = this.subscription();\n    subscription.eventFilters = events;\n    this._setSubscription(subscription);\n    return this;\n};\n\n/**\n * @returns {Promise<ApiResponse>}\n */\nSubscription.prototype.subscribe = function() {\n\n    return (new this._externals.Promise(function(resolve) {\n\n        this._clearTimeout();\n\n        if (!this.eventFilters().length) throw new Error('Events are undefined');\n\n        resolve(this._platform.post('/subscription', {\n            eventFilters: this._getFullEventFilters(),\n            deliveryMode: {\n                transportType: 'PubNub'\n            }\n        }));\n\n    }.bind(this))).then(function(response) {\n\n        var json = response.json();\n\n        this.setSubscription(json)\n            .emit(this.events.subscribeSuccess, response);\n\n        return response;\n\n    }.bind(this)).catch(function(e) {\n\n        e = this._platform.client().makeError(e);\n        // `reset` will remove pubnub instance.\n        // so if network is broken for a long time, pubnub will be removed. And client can not receive notification anymore.\n        this.reset()\n            .emit(this.events.subscribeError, e);\n\n        throw e;\n\n    }.bind(this));\n\n};\n\n/**\n * @returns {Promise<ApiResponse>}\n */\nSubscription.prototype.renew = function() {\n\n    return (new this._externals.Promise(function(resolve) {\n\n        this._clearTimeout();\n\n        if (!this.subscribed()) throw new Error('No subscription');\n\n        if (!this.eventFilters().length) throw new Error('Events are undefined');\n\n        resolve(this._platform.put('/subscription/' + this.subscription().id, {\n            eventFilters: this._getFullEventFilters()\n        }));\n\n    }.bind(this))).then(function(response) {\n\n        var json = response.json();\n\n        this.setSubscription(json)\n            .emit(this.events.renewSuccess, response);\n\n        return response;\n\n    }.bind(this)).catch(function(e) {\n\n        e = this._platform.client().makeError(e);\n        // `reset` will remove pubnub instance.\n        // so if network is broken for a long time, pubnub will be removed. And client can not receive notification anymore.\n        this.reset()\n            .emit(this.events.renewError, e);\n\n        throw e;\n\n    }.bind(this));\n\n};\n\n/**\n * @returns {Promise<ApiResponse>}\n */\nSubscription.prototype.remove = function() {\n\n    return (new this._externals.Promise(function(resolve) {\n\n        if (!this.subscribed()) throw new Error('No subscription');\n\n        resolve(this._platform.delete('/subscription/' + this.subscription().id));\n\n    }.bind(this))).then(function(response) {\n\n        this.reset()\n            .emit(this.events.removeSuccess, response);\n\n        return response;\n\n    }.bind(this)).catch(function(e) {\n\n        e = this._platform.client().makeError(e);\n\n        this.emit(this.events.removeError, e);\n\n        throw e;\n\n    }.bind(this));\n\n};\n\n/**\n * @returns {Promise<ApiResponse>}\n */\nSubscription.prototype.resubscribe = function() {\n    var filters = this.eventFilters();\n    return this.reset().setEventFilters(filters).subscribe();\n};\n\n/**\n * Remove subscription and disconnect from PubNub\n * This method resets subscription at client side but backend is not notified\n * @return {Subscription}\n */\nSubscription.prototype.reset = function() {\n    this._clearTimeout();\n    this._unsubscribeAtPubnub();\n    this._setSubscription(null);\n    return this;\n};\n\n/**\n * @param subscription\n * @private\n */\nSubscription.prototype._setSubscription = function(subscription) {\n    this._subscription = subscription;\n};\n\n/**\n * @return {string[]}\n * @private\n */\nSubscription.prototype._getFullEventFilters = function() {\n\n    return this.eventFilters().map(function(event) {\n        return this._platform.createUrl(event);\n    }.bind(this));\n\n};\n\n/**\n * @return {Subscription}\n * @private\n */\nSubscription.prototype._setTimeout = function() {\n\n    this._clearTimeout();\n\n    if (!this.alive()) throw new Error('Subscription is not alive');\n\n    this._timeout = setInterval(function() {\n\n        if (this.alive()) {\n            return;\n        }\n\n        this._clearTimeout();\n\n        (new this._externals.Promise(function(resolve) {\n\n            if (this.expired()) {\n                resolve(this.subscribe());\n            } else {\n                resolve(this.renew());\n            }\n\n        }.bind(this))).then(function(res) {\n\n            this.emit(this.events.automaticRenewSuccess, res);\n\n        }.bind(this)).catch(function(e) {\n\n            this.emit(this.events.automaticRenewError, e);\n\n        }.bind(this));\n\n    }.bind(this), this._pollInterval);\n\n    return this;\n\n};\n\n/**\n * @return {Subscription}\n * @private\n */\nSubscription.prototype._clearTimeout = function() {\n    clearInterval(this._timeout);\n    return this;\n};\n\nSubscription.prototype._decrypt = function(message) {\n\n    if (!this.subscribed()) throw new Error('No subscription');\n\n    if (this.subscription().deliveryMode.encryptionKey) {\n\n        message = this._pubnub.decrypt(message, this.subscription().deliveryMode.encryptionKey, {\n            encryptKey: false,\n            keyEncoding: 'base64',\n            keyLength: 128,\n            mode: 'ecb'\n        });\n\n    }\n\n    return message;\n\n};\n\n/**\n * @param message\n * @return {Subscription}\n * @private\n */\nSubscription.prototype._notify = function(message) {\n    this.emit(this.events.notification, this._decrypt(message));\n    return this;\n};\n\n/**\n * @return {Subscription}\n * @private\n */\nSubscription.prototype._subscribeAtPubnub = function() {\n\n    if (!this.alive()) throw new Error('Subscription is not alive');\n\n    var deliveryMode = this.subscription().deliveryMode;\n\n    if (this._pubnub) {\n\n        if (this._pubnubLastChannel === deliveryMode.address) {\n\n            // Nothing to update, keep listening to same channel\n            return this;\n\n        } else if (this._pubnubLastSubscribeKey && this._pubnubLastSubscribeKey !== deliveryMode.subscriberKey) {\n\n            // Subscribe key changed, need to reset everything\n            this._unsubscribeAtPubnub();\n\n        } else if (this._pubnubLastChannel) {\n\n            // Need to subscribe to new channel\n            this._pubnub.unsubscribeAll();\n\n        }\n\n    }\n\n    if (!this._pubnub) {\n\n        this._pubnubLastSubscribeKey = deliveryMode.subscriberKey;\n\n        var PubNub = this._externals.PubNub;\n\n        this._pubnub = new PubNub({\n            ssl: true,\n            restore: true,\n            subscribeKey: deliveryMode.subscriberKey\n        });\n\n        this._pubnub.addListener({\n            status: function(statusEvent) {},\n            message: function(m) {\n                this._notify(m.message); // all other props are ignored\n            }.bind(this)\n        });\n\n    }\n\n    this._pubnubLastChannel = deliveryMode.address;\n    this._pubnub.subscribe({channels: [deliveryMode.address]});\n\n    return this;\n\n};\n\n/**\n * @return {Subscription}\n * @private\n */\nSubscription.prototype._unsubscribeAtPubnub = function() {\n\n    if (!this.subscribed() || !this._pubnub) return this;\n\n    this._pubnub.removeAllListeners();\n    this._pubnub.destroy(); // this will unsubscribe from all\n\n    this._pubnubLastSubscribeKey = null;\n    this._pubnubLastChannel = null;\n    this._pubnub = null;\n\n    return this;\n\n};\n\nmodule.exports = Subscription;\n\n/**\n * The complete Triforce, or one or more components of the Triforce.\n * @typedef {Object} ISubscription\n * @property {string} [id]\n * @property {string} [uri]\n * @property {string[]} [eventFilters]\n * @property {string} [expirationTime] Format: 2014-03-12T19:54:35.613+0000\n * @property {int} [expiresIn]\n * @property {string} [deliveryMode.transportType]\n * @property {boolean} [deliveryMode.encryption]\n * @property {string} [deliveryMode.address]\n * @property {string} [deliveryMode.subscriberKey]\n * @property {string} [deliveryMode.encryptionKey]\n * @property {string} [deliveryMode.secretKey]\n * @property {string} [creationTime]\n * @property {string} [status] Active\n */\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\nvar Subscription = __webpack_require__(18);\n\n/**\n * @param {Platform} options.platform\n * @param {Externals} options.externals\n * @param {Cache} options.cache\n * @param {string} options.cacheKey\n * @param {int} [options.pollInterval]\n * @param {int} [options.renewHandicapMs]\n * @return {CachedSubscription}\n * @constructor\n * @property {Cache} _cache\n * @extends Subscription\n */\nfunction CachedSubscription(options) {\n\n    options = options || {};\n\n    if (!options.cacheKey) throw new Error('Cached Subscription requires cacheKey parameter to be defined');\n\n    /** @private */\n    this._cacheKey = options.cacheKey;\n\n    Subscription.call(this, options);\n\n    /** @private */\n    this._cache = options.cache;\n\n    // This is not used in this class\n    this._subscription = undefined;\n\n}\n\nCachedSubscription.prototype = Object.create(Subscription.prototype);\n\nCachedSubscription.prototype.subscription = function() {\n    return this._cache.getItem(this._cacheKey) || {};\n};\n\nCachedSubscription.prototype._setSubscription = function(subscription) {\n    return this._cache.setItem(this._cacheKey, subscription);\n};\n\n/**\n * This function checks whether there are any pre-defined eventFilters in cache and if not -- uses provided as defaults\n * @param {string[]} events\n * @return {CachedSubscription}\n */\nCachedSubscription.prototype.restore = function(events) {\n\n    if (!this.eventFilters().length) {\n        this.setEventFilters(events);\n    }\n\n    return this;\n\n};\n\nmodule.exports = CachedSubscription;\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=ringcentral.js.map"},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/sip-0.11.6.js":function(n,e){n.exports="/*!\n * \n *  SIP version 0.11.6\n *  Copyright (c) 2014-2018 Junction Networks, Inc <http://www.onsip.com>\n *  Homepage: https://sipjs.com\n *  License: https://sipjs.com/license/\n * \n * \n *  ~~~SIP.js contains substantial portions of JsSIP under the following license~~~\n *  Homepage: http://jssip.net\n *  Copyright (c) 2012-2013 Jos Luis Milln - Versatica <http://www.versatica.com>\n * \n *  Permission is hereby granted, free of charge, to any person obtaining\n *  a copy of this software and associated documentation files (the\n *  \"Software\"), to deal in the Software without restriction, including\n *  without limitation the rights to use, copy, modify, merge, publish,\n *  distribute, sublicense, and/or sell copies of the Software, and to\n *  permit persons to whom the Software is furnished to do so, subject to\n *  the following conditions:\n * \n *  The above copyright notice and this permission notice shall be\n *  included in all copies or substantial portions of the Software.\n * \n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n *  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n *  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n *  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n *  LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n *  OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n *  WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * \n *  ~~~ end JsSIP license ~~~\n * \n * \n * \n * \n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"SIP\"] = factory();\n\telse\n\t\troot[\"SIP\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = __webpack_require__(1)(__webpack_require__(40));\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * @name SIP\n * @namespace\n */\n\nmodule.exports = function (environment) {\n    var pkg = __webpack_require__(2), version = pkg.version, title = pkg.title;\n    var SIP = Object.defineProperties({}, {\n        version: {\n            get: function () { return version; }\n        },\n        name: {\n            get: function () { return title; }\n        }\n    });\n    __webpack_require__(3)(SIP, environment);\n    SIP.LoggerFactory = __webpack_require__(4)(environment.console);\n    SIP.EventEmitter = __webpack_require__(5)();\n    SIP.C = __webpack_require__(7)(SIP.name, SIP.version);\n    SIP.Exceptions = __webpack_require__(8);\n    SIP.Timers = __webpack_require__(9)(environment.timers);\n    SIP.Transport = __webpack_require__(10)(SIP);\n    __webpack_require__(11)(SIP);\n    __webpack_require__(12)(SIP);\n    __webpack_require__(13)(SIP);\n    __webpack_require__(14)(SIP);\n    __webpack_require__(15)(SIP);\n    __webpack_require__(16)(SIP);\n    __webpack_require__(18)(SIP);\n    __webpack_require__(19)(SIP);\n    SIP.SessionDescriptionHandler = __webpack_require__(20)(SIP.EventEmitter);\n    __webpack_require__(21)(SIP);\n    __webpack_require__(22)(SIP);\n    __webpack_require__(23)(SIP);\n    __webpack_require__(25)(SIP);\n    __webpack_require__(26)(SIP);\n    __webpack_require__(27)(SIP, environment);\n    __webpack_require__(32)(SIP);\n    SIP.DigestAuthentication = __webpack_require__(33)(SIP.Utils);\n    SIP.Grammar = __webpack_require__(36)(SIP);\n    SIP.Web = {\n        Modifiers: __webpack_require__(38)(SIP),\n        Simple: __webpack_require__(39)(SIP)\n    };\n    return SIP;\n};\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module) {\n\nmodule.exports = {\"name\":\"sip.js\",\"title\":\"SIP.js\",\"description\":\"A simple, intuitive, and powerful JavaScript signaling library\",\"version\":\"0.11.6\",\"main\":\"dist/sip.js\",\"browser\":{\"./src/environment.js\":\"./src/environment_browser.js\"},\"homepage\":\"https://sipjs.com\",\"author\":\"OnSIP <developer@onsip.com> (https://sipjs.com/aboutus/)\",\"contributors\":[{\"url\":\"https://github.com/onsip/SIP.js/blob/master/THANKS.md\"}],\"repository\":{\"type\":\"git\",\"url\":\"https://github.com/onsip/SIP.js.git\"},\"keywords\":[\"sip\",\"websocket\",\"webrtc\",\"library\",\"javascript\"],\"devDependencies\":{\"awesome-typescript-loader\":\"^5.2.1\",\"eslint\":\"^5.4.0\",\"jasmine-core\":\"^3.2.1\",\"karma\":\"^3.0.0\",\"karma-chrome-launcher\":\"^2.2.0\",\"karma-cli\":\"^1.0.1\",\"karma-jasmine\":\"^1.1.0\",\"karma-jasmine-html-reporter\":\"^1.3.1\",\"karma-mocha-reporter\":\"^2.2.5\",\"karma-webpack\":\"^3.0.0\",\"pegjs\":\"^0.10.0\",\"pegjs-loader\":\"^0.5.4\",\"typescript\":\"^3.0.3\",\"webpack\":\"^4.19.0\",\"webpack-cli\":\"^3.0.8\"},\"engines\":{\"node\":\">=6.0\"},\"license\":\"MIT\",\"scripts\":{\"prebuild\":\"eslint src/*.js src/**/*.js\",\"build-dev\":\"webpack --progress --env.buildType dev\",\"build-prod\":\"webpack --progress --env.buildType prod\",\"copy-dist-files\":\"cp dist/sip.js dist/sip-$npm_package_version.js && cp dist/sip.min.js  dist/sip-$npm_package_version.min.js\",\"build\":\"npm run build-dev && npm run build-prod && npm run copy-dist-files\",\"browserTest\":\"sleep 2 && open http://0.0.0.0:9876/debug.html & karma start --reporters kjhtml --no-single-run\",\"commandLineTest\":\"karma start --reporters mocha --browsers ChromeHeadless --single-run\",\"buildAndTest\":\"npm run build && npm run commandLineTest\",\"buildAndBrowserTest\":\"npm run build && npm run browserTest\"},\"dependencies\":{\"crypto-js\":\"^3.1.9-1\"},\"optionalDependencies\":{\"promiscuous\":\"^0.6.0\"}};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview Utils\n */\nmodule.exports = function (SIP, environment) {\n    var Utils;\n    Utils = {\n        Promise: environment.Promise,\n        defer: function defer() {\n            var deferred = {};\n            deferred.promise = new Utils.Promise(function (resolve, reject) {\n                deferred.resolve = resolve;\n                deferred.reject = reject;\n            });\n            return deferred;\n        },\n        reducePromises: function reducePromises(arr, val) {\n            return arr.reduce(function (acc, fn) {\n                acc = acc.then(fn);\n                return acc;\n            }, SIP.Utils.Promise.resolve(val));\n        },\n        augment: function (object, constructor, args, override) {\n            var idx, proto;\n            // Add public properties from constructor's prototype onto object\n            proto = constructor.prototype;\n            for (idx in proto) {\n                if (override || object[idx] === undefined) {\n                    object[idx] = proto[idx];\n                }\n            }\n            // Construct the object as though it were just created by constructor\n            constructor.apply(object, args);\n        },\n        defaultOptions: function (defaultOptions, overridingOptions) {\n            defaultOptions = defaultOptions || {};\n            overridingOptions = overridingOptions || {};\n            return Object.assign({}, defaultOptions, overridingOptions);\n        },\n        optionsOverride: function (options, winner, loser, isDeprecated, logger, defaultValue) {\n            if (isDeprecated && options[loser]) {\n                logger.warn(loser + ' is deprecated, please use ' + winner + ' instead');\n            }\n            if (options[winner] && options[loser]) {\n                logger.warn(winner + ' overriding ' + loser);\n            }\n            options[winner] = options[winner] || options[loser] || defaultValue;\n        },\n        str_utf8_length: function (string) {\n            return encodeURIComponent(string).replace(/%[A-F\\d]{2}/g, 'U').length;\n        },\n        generateFakeSDP: function (body) {\n            if (!body) {\n                return;\n            }\n            var start = body.indexOf('o=');\n            var end = body.indexOf('\\r\\n', start);\n            return 'v=0\\r\\n' + body.slice(start, end) + '\\r\\ns=-\\r\\nt=0 0\\r\\nc=IN IP4 0.0.0.0';\n        },\n        isFunction: function (fn) {\n            if (fn !== undefined) {\n                return Object.prototype.toString.call(fn) === '[object Function]';\n            }\n            else {\n                return false;\n            }\n        },\n        isDecimal: function (num) {\n            return !isNaN(num) && (parseFloat(num) === parseInt(num, 10));\n        },\n        createRandomToken: function (size, base) {\n            var i, r, token = '';\n            base = base || 32;\n            for (i = 0; i < size; i++) {\n                r = Math.random() * base | 0;\n                token += r.toString(base);\n            }\n            return token;\n        },\n        newTag: function () {\n            return SIP.Utils.createRandomToken(SIP.UA.C.TAG_LENGTH);\n        },\n        // http://stackoverflow.com/users/109538/broofa\n        newUUID: function () {\n            var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);\n                return v.toString(16);\n            });\n            return UUID;\n        },\n        hostType: function (host) {\n            if (!host) {\n                return;\n            }\n            else {\n                host = SIP.Grammar.parse(host, 'host');\n                if (host !== -1) {\n                    return host.host_type;\n                }\n            }\n        },\n        /**\n        * Normalize SIP URI.\n        * NOTE: It does not allow a SIP URI without username.\n        * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.\n        * Detects the domain part (if given) and properly hex-escapes the user portion.\n        * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.\n        * @private\n        * @param {String} target\n        * @param {String} [domain]\n        */\n        normalizeTarget: function (target, domain) {\n            var uri, target_array, target_user, target_domain;\n            // If no target is given then raise an error.\n            if (!target) {\n                return;\n                // If a SIP.URI instance is given then return it.\n            }\n            else if (target instanceof SIP.URI) {\n                return target;\n                // If a string is given split it by '@':\n                // - Last fragment is the desired domain.\n                // - Otherwise append the given domain argument.\n            }\n            else if (typeof target === 'string') {\n                target_array = target.split('@');\n                switch (target_array.length) {\n                    case 1:\n                        if (!domain) {\n                            return;\n                        }\n                        target_user = target;\n                        target_domain = domain;\n                        break;\n                    case 2:\n                        target_user = target_array[0];\n                        target_domain = target_array[1];\n                        break;\n                    default:\n                        target_user = target_array.slice(0, target_array.length - 1).join('@');\n                        target_domain = target_array[target_array.length - 1];\n                }\n                // Remove the URI scheme (if present).\n                target_user = target_user.replace(/^(sips?|tel):/i, '');\n                // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.\n                if (/^[\\-\\.\\(\\)]*\\+?[0-9\\-\\.\\(\\)]+$/.test(target_user)) {\n                    target_user = target_user.replace(/[\\-\\.\\(\\)]/g, '');\n                }\n                // Build the complete SIP URI.\n                target = SIP.C.SIP + ':' + SIP.Utils.escapeUser(target_user) + '@' + target_domain;\n                // Finally parse the resulting URI.\n                uri = SIP.URI.parse(target);\n                return uri;\n            }\n            else {\n                return;\n            }\n        },\n        /**\n        * Hex-escape a SIP URI user.\n        * @private\n        * @param {String} user\n        */\n        escapeUser: function (user) {\n            // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n            return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');\n        },\n        headerize: function (string) {\n            var exceptions = {\n                'Call-Id': 'Call-ID',\n                'Cseq': 'CSeq',\n                'Min-Se': 'Min-SE',\n                'Rack': 'RAck',\n                'Rseq': 'RSeq',\n                'Www-Authenticate': 'WWW-Authenticate'\n            }, name = string.toLowerCase().replace(/_/g, '-').split('-'), hname = '', parts = name.length, part;\n            for (part = 0; part < parts; part++) {\n                if (part !== 0) {\n                    hname += '-';\n                }\n                hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n            }\n            if (exceptions[hname]) {\n                hname = exceptions[hname];\n            }\n            return hname;\n        },\n        sipErrorCause: function (status_code) {\n            var cause;\n            for (cause in SIP.C.SIP_ERROR_CAUSES) {\n                if (SIP.C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {\n                    return SIP.C.causes[cause];\n                }\n            }\n            return SIP.C.causes.SIP_FAILURE_CODE;\n        },\n        getReasonPhrase: function getReasonPhrase(code, specific) {\n            return specific || SIP.C.REASON_PHRASE[code] || '';\n        },\n        getReasonHeaderValue: function getReasonHeaderValue(code, reason) {\n            reason = SIP.Utils.getReasonPhrase(code, reason);\n            return 'SIP;cause=' + code + ';text=\"' + reason + '\"';\n        },\n        getCancelReason: function getCancelReason(code, reason) {\n            if (code && code < 200 || code > 699) {\n                throw new TypeError('Invalid status_code: ' + code);\n            }\n            else if (code) {\n                return SIP.Utils.getReasonHeaderValue(code, reason);\n            }\n        },\n        buildStatusLine: function buildStatusLine(code, reason) {\n            code = code || null;\n            reason = reason || null;\n            // Validate code and reason values\n            if (!code || (code < 100 || code > 699)) {\n                throw new TypeError('Invalid status_code: ' + code);\n            }\n            else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {\n                throw new TypeError('Invalid reason_phrase: ' + reason);\n            }\n            reason = Utils.getReasonPhrase(code, reason);\n            return 'SIP/2.0 ' + code + ' ' + reason + '\\r\\n';\n        },\n        /**\n        * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n        * @private\n        */\n        getRandomTestNetIP: function () {\n            function getOctet(from, to) {\n                return Math.floor(Math.random() * (to - from + 1) + from);\n            }\n            return '192.0.2.' + getOctet(1, 254);\n        }\n    };\n    SIP.Utils = Utils;\n};\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar levels = {\n    'error': 0,\n    'warn': 1,\n    'log': 2,\n    'debug': 3\n};\nmodule.exports = function (console) {\n    var LoggerFactory = function () {\n        var logger, level = 2, builtinEnabled = true, connector = null;\n        this.loggers = {};\n        logger = this.getLogger('sip.loggerfactory');\n        Object.defineProperties(this, {\n            builtinEnabled: {\n                get: function () { return builtinEnabled; },\n                set: function (value) {\n                    if (typeof value === 'boolean') {\n                        builtinEnabled = value;\n                    }\n                    else {\n                        logger.error('invalid \"builtinEnabled\" parameter value: ' + JSON.stringify(value));\n                    }\n                }\n            },\n            level: {\n                get: function () { return level; },\n                set: function (value) {\n                    if (value >= 0 && value <= 3) {\n                        level = value;\n                    }\n                    else if (value > 3) {\n                        level = 3;\n                    }\n                    else if (levels.hasOwnProperty(value)) {\n                        level = levels[value];\n                    }\n                    else {\n                        logger.error('invalid \"level\" parameter value: ' + JSON.stringify(value));\n                    }\n                }\n            },\n            connector: {\n                get: function () { return connector; },\n                set: function (value) {\n                    if (value === null || value === \"\" || value === undefined) {\n                        connector = null;\n                    }\n                    else if (typeof value === 'function') {\n                        connector = value;\n                    }\n                    else {\n                        logger.error('invalid \"connector\" parameter value: ' + JSON.stringify(value));\n                    }\n                }\n            }\n        });\n    };\n    LoggerFactory.prototype.print = function (target, category, label, content) {\n        if (typeof content === 'string') {\n            var prefix = [new Date(), category];\n            if (label) {\n                prefix.push(label);\n            }\n            content = prefix.concat(content).join(' | ');\n        }\n        target.call(console, content);\n    };\n    function Logger(logger, category, label) {\n        this.logger = logger;\n        this.category = category;\n        this.label = label;\n    }\n    Object.keys(levels).forEach(function (targetName) {\n        Logger.prototype[targetName] = function (content) {\n            this.logger[targetName](this.category, this.label, content);\n        };\n        LoggerFactory.prototype[targetName] = function (category, label, content) {\n            if (this.level >= levels[targetName]) {\n                if (this.builtinEnabled) {\n                    this.print(console[targetName], category, label, content);\n                }\n                if (this.connector) {\n                    this.connector(targetName, category, label, content);\n                }\n            }\n        };\n    });\n    LoggerFactory.prototype.getLogger = function (category, label) {\n        var logger;\n        if (label && this.level === 3) {\n            return new Logger(this, category, label);\n        }\n        else if (this.loggers[category]) {\n            return this.loggers[category];\n        }\n        else {\n            logger = new Logger(this, category);\n            this.loggers[category] = logger;\n            return logger;\n        }\n    };\n    return LoggerFactory;\n};\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar NodeEventEmitter = __webpack_require__(6).EventEmitter;\nmodule.exports = function () {\n    // Don't use `new SIP.EventEmitter()` for inheriting.\n    // Use Object.create(SIP.EventEmitter.prototoype);\n    function EventEmitter() {\n        NodeEventEmitter.call(this);\n    }\n    EventEmitter.prototype = Object.create(NodeEventEmitter.prototype, {\n        constructor: {\n            value: EventEmitter,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    return EventEmitter;\n};\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP Constants\n */\n/**\n * SIP Constants.\n * @augments SIP\n */\nmodule.exports = function (name, version) {\n    return {\n        USER_AGENT: name + '/' + version,\n        // SIP scheme\n        SIP: 'sip',\n        SIPS: 'sips',\n        // End and Failure causes\n        causes: {\n            // Generic error causes\n            CONNECTION_ERROR: 'Connection Error',\n            REQUEST_TIMEOUT: 'Request Timeout',\n            SIP_FAILURE_CODE: 'SIP Failure Code',\n            INTERNAL_ERROR: 'Internal Error',\n            // SIP error causes\n            BUSY: 'Busy',\n            REJECTED: 'Rejected',\n            REDIRECTED: 'Redirected',\n            UNAVAILABLE: 'Unavailable',\n            NOT_FOUND: 'Not Found',\n            ADDRESS_INCOMPLETE: 'Address Incomplete',\n            INCOMPATIBLE_SDP: 'Incompatible SDP',\n            AUTHENTICATION_ERROR: 'Authentication Error',\n            DIALOG_ERROR: 'Dialog Error',\n            // Session error causes\n            WEBRTC_NOT_SUPPORTED: 'WebRTC Not Supported',\n            WEBRTC_ERROR: 'WebRTC Error',\n            CANCELED: 'Canceled',\n            NO_ANSWER: 'No Answer',\n            EXPIRES: 'Expires',\n            NO_ACK: 'No ACK',\n            NO_PRACK: 'No PRACK',\n            USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',\n            BAD_MEDIA_DESCRIPTION: 'Bad Media Description',\n            RTP_TIMEOUT: 'RTP Timeout'\n        },\n        supported: {\n            UNSUPPORTED: 'none',\n            SUPPORTED: 'supported',\n            REQUIRED: 'required'\n        },\n        SIP_ERROR_CAUSES: {\n            REDIRECTED: [300, 301, 302, 305, 380],\n            BUSY: [486, 600],\n            REJECTED: [403, 603],\n            NOT_FOUND: [404, 604],\n            UNAVAILABLE: [480, 410, 408, 430],\n            ADDRESS_INCOMPLETE: [484],\n            INCOMPATIBLE_SDP: [488, 606],\n            AUTHENTICATION_ERROR: [401, 407]\n        },\n        // SIP Methods\n        ACK: 'ACK',\n        BYE: 'BYE',\n        CANCEL: 'CANCEL',\n        INFO: 'INFO',\n        INVITE: 'INVITE',\n        MESSAGE: 'MESSAGE',\n        NOTIFY: 'NOTIFY',\n        OPTIONS: 'OPTIONS',\n        REGISTER: 'REGISTER',\n        UPDATE: 'UPDATE',\n        SUBSCRIBE: 'SUBSCRIBE',\n        PUBLISH: 'PUBLISH',\n        REFER: 'REFER',\n        PRACK: 'PRACK',\n        /* SIP Response Reasons\n         * DOC: http://www.iana.org/assignments/sip-parameters\n         * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7\n         */\n        REASON_PHRASE: {\n            100: 'Trying',\n            180: 'Ringing',\n            181: 'Call Is Being Forwarded',\n            182: 'Queued',\n            183: 'Session Progress',\n            199: 'Early Dialog Terminated',\n            200: 'OK',\n            202: 'Accepted',\n            204: 'No Notification',\n            300: 'Multiple Choices',\n            301: 'Moved Permanently',\n            302: 'Moved Temporarily',\n            305: 'Use Proxy',\n            380: 'Alternative Service',\n            400: 'Bad Request',\n            401: 'Unauthorized',\n            402: 'Payment Required',\n            403: 'Forbidden',\n            404: 'Not Found',\n            405: 'Method Not Allowed',\n            406: 'Not Acceptable',\n            407: 'Proxy Authentication Required',\n            408: 'Request Timeout',\n            410: 'Gone',\n            412: 'Conditional Request Failed',\n            413: 'Request Entity Too Large',\n            414: 'Request-URI Too Long',\n            415: 'Unsupported Media Type',\n            416: 'Unsupported URI Scheme',\n            417: 'Unknown Resource-Priority',\n            420: 'Bad Extension',\n            421: 'Extension Required',\n            422: 'Session Interval Too Small',\n            423: 'Interval Too Brief',\n            428: 'Use Identity Header',\n            429: 'Provide Referrer Identity',\n            430: 'Flow Failed',\n            433: 'Anonymity Disallowed',\n            436: 'Bad Identity-Info',\n            437: 'Unsupported Certificate',\n            438: 'Invalid Identity Header',\n            439: 'First Hop Lacks Outbound Support',\n            440: 'Max-Breadth Exceeded',\n            469: 'Bad Info Package',\n            470: 'Consent Needed',\n            478: 'Unresolvable Destination',\n            480: 'Temporarily Unavailable',\n            481: 'Call/Transaction Does Not Exist',\n            482: 'Loop Detected',\n            483: 'Too Many Hops',\n            484: 'Address Incomplete',\n            485: 'Ambiguous',\n            486: 'Busy Here',\n            487: 'Request Terminated',\n            488: 'Not Acceptable Here',\n            489: 'Bad Event',\n            491: 'Request Pending',\n            493: 'Undecipherable',\n            494: 'Security Agreement Required',\n            500: 'Internal Server Error',\n            501: 'Not Implemented',\n            502: 'Bad Gateway',\n            503: 'Service Unavailable',\n            504: 'Server Time-out',\n            505: 'Version Not Supported',\n            513: 'Message Too Large',\n            580: 'Precondition Failure',\n            600: 'Busy Everywhere',\n            603: 'Decline',\n            604: 'Does Not Exist Anywhere',\n            606: 'Not Acceptable'\n        },\n        /* SIP Option Tags\n         * DOC: http://www.iana.org/assignments/sip-parameters/sip-parameters.xhtml#sip-parameters-4\n         */\n        OPTION_TAGS: {\n            '100rel': true,\n            199: true,\n            answermode: true,\n            'early-session': true,\n            eventlist: true,\n            explicitsub: true,\n            'from-change': true,\n            'geolocation-http': true,\n            'geolocation-sip': true,\n            gin: true,\n            gruu: true,\n            histinfo: true,\n            ice: true,\n            join: true,\n            'multiple-refer': true,\n            norefersub: true,\n            nosub: true,\n            outbound: true,\n            path: true,\n            policy: true,\n            precondition: true,\n            pref: true,\n            privacy: true,\n            'recipient-list-invite': true,\n            'recipient-list-message': true,\n            'recipient-list-subscribe': true,\n            replaces: true,\n            'resource-priority': true,\n            'sdp-anat': true,\n            'sec-agree': true,\n            tdialog: true,\n            timer: true,\n            uui: true // RFC 7433\n        },\n        dtmfType: {\n            INFO: 'info',\n            RTP: 'rtp'\n        }\n    };\n};\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview Exceptions\n */\n/**\n * SIP Exceptions.\n * @augments SIP\n */\nmodule.exports = {\n    ConfigurationError: (function () {\n        var exception = function (parameter, value) {\n            this.code = 1;\n            this.name = 'CONFIGURATION_ERROR';\n            this.parameter = parameter;\n            this.value = value;\n            this.message = (!this.value) ? 'Missing parameter: ' + this.parameter : 'Invalid value ' + JSON.stringify(this.value) + ' for parameter \"' + this.parameter + '\"';\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n    InvalidStateError: (function () {\n        var exception = function (status) {\n            this.code = 2;\n            this.name = 'INVALID_STATE_ERROR';\n            this.status = status;\n            this.message = 'Invalid status: ' + status;\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n    NotSupportedError: (function () {\n        var exception = function (message) {\n            this.code = 3;\n            this.name = 'NOT_SUPPORTED_ERROR';\n            this.message = message;\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n    // Deprecated\n    GetDescriptionError: (function () {\n        var exception = function (message) {\n            this.code = 4;\n            this.name = 'GET_DESCRIPTION_ERROR';\n            this.message = message;\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n    RenegotiationError: (function () {\n        var exception = function (message) {\n            this.code = 5;\n            this.name = 'RENEGOTIATION_ERROR';\n            this.message = message;\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n    MethodParameterError: (function () {\n        var exception = function (method, parameter, value) {\n            this.code = 6;\n            this.name = 'METHOD_PARAMETER_ERROR';\n            this.method = method;\n            this.parameter = parameter;\n            this.value = value;\n            this.message = (!this.value) ? 'Missing parameter: ' + this.parameter : 'Invalid value ' + JSON.stringify(this.value) + ' for parameter \"' + this.parameter + '\"';\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n    TransportError: (function () {\n        var exception = function (message) {\n            this.code = 7;\n            this.name = 'TRANSPORT_ERROR';\n            this.message = message;\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n    SessionDescriptionHandlerError: (function () {\n        var exception = function (method, error, message) {\n            this.code = 8;\n            this.name = 'SESSION_DESCRIPTION_HANDLER_ERROR';\n            this.method = method;\n            this.error = error;\n            this.message = message || 'Error with Session Description Handler';\n        };\n        exception.prototype = new Error();\n        return exception;\n    }()),\n};\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP TIMERS\n */\n/**\n * @augments SIP\n */\nvar T1 = 500, T2 = 4000, T4 = 5000;\nmodule.exports = function (timers) {\n    var Timers = {\n        T1: T1,\n        T2: T2,\n        T4: T4,\n        TIMER_B: 64 * T1,\n        TIMER_D: 0 * T1,\n        TIMER_F: 64 * T1,\n        TIMER_H: 64 * T1,\n        TIMER_I: 0 * T1,\n        TIMER_J: 0 * T1,\n        TIMER_K: 0 * T4,\n        TIMER_L: 64 * T1,\n        TIMER_M: 64 * T1,\n        TIMER_N: 64 * T1,\n        PROVISIONAL_RESPONSE_INTERVAL: 60000 // See RFC 3261 Section 13.3.1.1\n    };\n    ['setTimeout', 'clearTimeout', 'setInterval', 'clearInterval']\n        .forEach(function (name) {\n        // can't just use timers[name].bind(timers) since it bypasses jasmine's\n        // clock-mocking\n        Timers[name] = function () {\n            return timers[name].apply(timers, arguments);\n        };\n    });\n    return Timers;\n};\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* eslint-disable */\n/**\n * @fileoverview Transport\n */\n/* Transport\n * @class Abstract transport layer parent class\n * @param {Logger} logger\n * @param {Object} [options]\n */\nmodule.exports = function (SIP) {\n    var Transport = function (logger, options) { };\n    Transport.prototype = Object.create(SIP.EventEmitter.prototype, {\n        /**\n        * Returns the promise designated by the child layer then emits a connected event. Automatically emits an event upon resolution, unless overrideEvent is set. If you override the event in this fashion, you should emit it in your implementation of connectPromise\n        * @param {Object} [options]\n        * @returns {Promise}\n        */\n        connect: { writable: true, value: function connect(options) {\n                options = options || {};\n                return this.connectPromise(options).then(function (data) { !data.overrideEvent && this.emit('connected'); }.bind(this));\n            } },\n        /**\n        * Called by connect, must return a promise\n        * promise must resolve to an object. object supports 1 parameter: overrideEvent - Boolean\n        * @abstract\n        * @private\n        * @param {Object} [options]\n        * @returns {Promise}\n        */\n        connectPromise: { writable: true, value: function connectPromise(options) { } },\n        /**\n        * Returns true if the transport is connected\n        * @abstract\n        * @returns {Boolean}\n        */\n        isConnected: { writable: true, value: function isConnected() { } },\n        /**\n        * Sends a message then emits a 'messageSent' event. Automatically emits an event upon resolution, unless data.overrideEvent is set. If you override the event in this fashion, you should emit it in your implementation of sendPromise\n        * @param {SIP.OutgoingRequest|String} msg\n        * @param {Object} options\n        * @returns {Promise}\n        */\n        send: { writable: true, value: function send(msg, options) {\n                options = options || {};\n                return this.sendPromise(msg).then(function (data) { !data.overrideEvent && this.emit('messageSent', data.msg); }.bind(this));\n            } },\n        /**\n        * Called by send, must return a promise\n        * promise must resolve to an object. object supports 2 parameters: msg - string (mandatory) and overrideEvent - Boolean (optional)\n        * @abstract\n        * @private\n        * @param {SIP.OutgoingRequest|String} msg\n        * @param {Object} [options]\n        * @returns {Promise}\n        */\n        sendPromise: { writable: true, value: function sendPromise(msg, options) { } },\n        /**\n        * To be called when a message is received\n        * @abstract\n        * @param {Event} e\n        */\n        onMessage: { writable: true, value: function onMessage(e) { } },\n        /**\n        * Returns the promise designated by the child layer then emits a disconnected event. Automatically emits an event upon resolution, unless overrideEvent is set. If you override the event in this fashion, you should emit it in your implementation of disconnectPromise\n        * @param {Object} [options]\n        * @returns {Promise}\n        */\n        disconnect: { writable: true, value: function disconnect(options) {\n                options = options || {};\n                return this.disconnectPromise(options).then(function (data) { !data.overrideEvent && this.emit('disconnected'); }.bind(this));\n            } },\n        /**\n        * Called by disconnect, must return a promise\n        * promise must resolve to an object. object supports 1 parameter: overrideEvent - Boolean\n        * @abstract\n        * @private\n        * @param {Object} [options]\n        * @returns {Promise}\n        */\n        disconnectPromise: { writable: true, value: function disconnectPromise(options) { } },\n        afterConnected: { writable: true, value: function afterConnected(callback) {\n                if (this.isConnected()) {\n                    callback();\n                }\n                else {\n                    this.once('connected', callback);\n                }\n            } },\n        /**\n         * Returns a promise which resolves once the UA is connected. DEPRECATION WARNING: just use afterConnected()\n         * @returns {Promise}\n         */\n        waitForConnected: { writable: true, value: function waitForConnected() {\n                console.warn(\"DEPRECATION WARNING Transport.waitForConnected(): use afterConnected() instead\");\n                return new SIP.Utils.Promise(function (resolve) {\n                    this.afterConnected(resolve);\n                }.bind(this));\n            } },\n    });\n    return Transport;\n};\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP Message Parser\n */\n/**\n * Extract and parse every header of a SIP message.\n * @augments SIP\n * @namespace\n */\nmodule.exports = function (SIP) {\n    var Parser;\n    function getHeader(data, headerStart) {\n        var \n        // 'start' position of the header.\n        start = headerStart, \n        // 'end' position of the header.\n        end = 0, \n        // 'partial end' position of the header.\n        partialEnd = 0;\n        //End of message.\n        if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n            return -2;\n        }\n        while (end === 0) {\n            // Partial End of Header.\n            partialEnd = data.indexOf('\\r\\n', start);\n            // 'indexOf' returns -1 if the value to be found never occurs.\n            if (partialEnd === -1) {\n                return partialEnd;\n            }\n            if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n                // Not the end of the message. Continue from the next position.\n                start = partialEnd + 2;\n            }\n            else {\n                end = partialEnd;\n            }\n        }\n        return end;\n    }\n    function parseHeader(message, data, headerStart, headerEnd) {\n        var header, idx, length, parsed, hcolonIndex = data.indexOf(':', headerStart), headerName = data.substring(headerStart, hcolonIndex).trim(), headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();\n        // If header-field is well-known, parse it.\n        switch (headerName.toLowerCase()) {\n            case 'via':\n            case 'v':\n                message.addHeader('via', headerValue);\n                if (message.getHeaders('via').length === 1) {\n                    parsed = message.parseHeader('Via');\n                    if (parsed) {\n                        message.via = parsed;\n                        message.via_branch = parsed.branch;\n                    }\n                }\n                else {\n                    parsed = 0;\n                }\n                break;\n            case 'from':\n            case 'f':\n                message.setHeader('from', headerValue);\n                parsed = message.parseHeader('from');\n                if (parsed) {\n                    message.from = parsed;\n                    message.from_tag = parsed.getParam('tag');\n                }\n                break;\n            case 'to':\n            case 't':\n                message.setHeader('to', headerValue);\n                parsed = message.parseHeader('to');\n                if (parsed) {\n                    message.to = parsed;\n                    message.to_tag = parsed.getParam('tag');\n                }\n                break;\n            case 'record-route':\n                parsed = SIP.Grammar.parse(headerValue, 'Record_Route');\n                if (parsed === -1) {\n                    parsed = undefined;\n                    break;\n                }\n                length = parsed.length;\n                for (idx = 0; idx < length; idx++) {\n                    header = parsed[idx];\n                    message.addHeader('record-route', headerValue.substring(header.position, header.offset));\n                    message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;\n                }\n                break;\n            case 'call-id':\n            case 'i':\n                message.setHeader('call-id', headerValue);\n                parsed = message.parseHeader('call-id');\n                if (parsed) {\n                    message.call_id = headerValue;\n                }\n                break;\n            case 'contact':\n            case 'm':\n                parsed = SIP.Grammar.parse(headerValue, 'Contact');\n                if (parsed === -1) {\n                    parsed = undefined;\n                    break;\n                }\n                length = parsed.length;\n                for (idx = 0; idx < length; idx++) {\n                    header = parsed[idx];\n                    message.addHeader('contact', headerValue.substring(header.position, header.offset));\n                    message.headers['Contact'][message.getHeaders('contact').length - 1].parsed = header.parsed;\n                }\n                break;\n            case 'content-length':\n            case 'l':\n                message.setHeader('content-length', headerValue);\n                parsed = message.parseHeader('content-length');\n                break;\n            case 'content-type':\n            case 'c':\n                message.setHeader('content-type', headerValue);\n                parsed = message.parseHeader('content-type');\n                break;\n            case 'cseq':\n                message.setHeader('cseq', headerValue);\n                parsed = message.parseHeader('cseq');\n                if (parsed) {\n                    message.cseq = parsed.value;\n                }\n                if (message instanceof SIP.IncomingResponse) {\n                    message.method = parsed.method;\n                }\n                break;\n            case 'max-forwards':\n                message.setHeader('max-forwards', headerValue);\n                parsed = message.parseHeader('max-forwards');\n                break;\n            case 'www-authenticate':\n                message.setHeader('www-authenticate', headerValue);\n                parsed = message.parseHeader('www-authenticate');\n                break;\n            case 'proxy-authenticate':\n                message.setHeader('proxy-authenticate', headerValue);\n                parsed = message.parseHeader('proxy-authenticate');\n                break;\n            case 'refer-to':\n            case 'r':\n                message.setHeader('refer-to', headerValue);\n                parsed = message.parseHeader('refer-to');\n                if (parsed) {\n                    message.refer_to = parsed;\n                }\n                break;\n            default:\n                // Do not parse this header.\n                message.setHeader(headerName, headerValue);\n                parsed = 0;\n        }\n        if (parsed === undefined) {\n            return {\n                error: 'error parsing header \"' + headerName + '\"'\n            };\n        }\n        else {\n            return true;\n        }\n    }\n    /** Parse SIP Message\n     * @function\n     * @param {String} message SIP message.\n     * @param {Object} logger object.\n     * @returns {SIP.IncomingRequest|SIP.IncomingResponse|undefined}\n     */\n    Parser = {};\n    Parser.parseMessage = function (data, ua) {\n        var message, firstLine, contentLength, bodyStart, parsed, headerStart = 0, headerEnd = data.indexOf('\\r\\n'), logger = ua.getLogger('sip.parser');\n        if (headerEnd === -1) {\n            logger.warn('no CRLF found, not a SIP message, discarded');\n            return;\n        }\n        // Parse first line. Check if it is a Request or a Reply.\n        firstLine = data.substring(0, headerEnd);\n        parsed = SIP.Grammar.parse(firstLine, 'Request_Response');\n        if (parsed === -1) {\n            logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n            return;\n        }\n        else if (!parsed.status_code) {\n            message = new SIP.IncomingRequest(ua);\n            message.method = parsed.method;\n            message.ruri = parsed.uri;\n        }\n        else {\n            message = new SIP.IncomingResponse(ua);\n            message.status_code = parsed.status_code;\n            message.reason_phrase = parsed.reason_phrase;\n        }\n        message.data = data;\n        headerStart = headerEnd + 2;\n        /* Loop over every line in data. Detect the end of each header and parse\n        * it or simply add to the headers collection.\n        */\n        while (true) {\n            headerEnd = getHeader(data, headerStart);\n            // The SIP message has normally finished.\n            if (headerEnd === -2) {\n                bodyStart = headerStart + 2;\n                break;\n            }\n            // data.indexOf returned -1 due to a malformed message.\n            else if (headerEnd === -1) {\n                logger.error('malformed message');\n                return;\n            }\n            parsed = parseHeader(message, data, headerStart, headerEnd);\n            if (parsed !== true) {\n                logger.error(parsed.error);\n                return;\n            }\n            headerStart = headerEnd + 2;\n        }\n        /* RFC3261 18.3.\n         * If there are additional bytes in the transport packet\n         * beyond the end of the body, they MUST be discarded.\n         */\n        if (message.hasHeader('content-length')) {\n            contentLength = message.getHeader('content-length');\n            message.body = data.substr(bodyStart, contentLength);\n        }\n        else {\n            message.body = data.substring(bodyStart);\n        }\n        return message;\n    };\n    SIP.Parser = Parser;\n};\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP Message\n */\nmodule.exports = function (SIP) {\n    var OutgoingRequest, IncomingMessage, IncomingRequest, IncomingResponse;\n    function getSupportedHeader(request) {\n        var allowUnregistered = request.ua.configuration.hackAllowUnregisteredOptionTags;\n        var optionTags = [];\n        var optionTagSet = {};\n        if (request.method === SIP.C.REGISTER) {\n            optionTags.push('path', 'gruu');\n        }\n        else if (request.method === SIP.C.INVITE &&\n            (request.ua.contact.pub_gruu || request.ua.contact.temp_gruu)) {\n            optionTags.push('gruu');\n        }\n        if (request.ua.configuration.rel100 === SIP.C.supported.SUPPORTED) {\n            optionTags.push('100rel');\n        }\n        if (request.ua.configuration.replaces === SIP.C.supported.SUPPORTED) {\n            optionTags.push('replaces');\n        }\n        optionTags.push('outbound');\n        optionTags = optionTags.concat(request.ua.configuration.extraSupported);\n        optionTags = optionTags.filter(function (optionTag) {\n            var registered = SIP.C.OPTION_TAGS[optionTag];\n            var unique = !optionTagSet[optionTag];\n            optionTagSet[optionTag] = true;\n            return (registered || allowUnregistered) && unique;\n        });\n        return 'Supported: ' + optionTags.join(', ') + '\\r\\n';\n    }\n    /**\n     * @augments SIP\n     * @class Class for outgoing SIP request.\n     * @param {String} method request method\n     * @param {String} ruri request uri\n     * @param {SIP.UA} ua\n     * @param {Object} params parameters that will have priority over ua.configuration parameters:\n     * <br>\n     *  - cseq, call_id, from_tag, from_uri, from_displayName, to_uri, to_tag, route_set\n     * @param {Object} [headers] extra headers\n     * @param {String} [body]\n     */\n    OutgoingRequest = function (method, ruri, ua, params, extraHeaders, body) {\n        var to, from, call_id, cseq, to_uri, from_uri;\n        params = params || {};\n        // Mandatory parameters check\n        if (!method || !ruri || !ua) {\n            return null;\n        }\n        this.logger = ua.getLogger('sip.sipmessage');\n        this.ua = ua;\n        this.headers = {};\n        this.method = method;\n        this.ruri = ruri;\n        this.body = body;\n        this.extraHeaders = (extraHeaders || []).slice();\n        this.statusCode = params.status_code;\n        this.reasonPhrase = params.reason_phrase;\n        // Fill the Common SIP Request Headers\n        // Route\n        if (params.route_set) {\n            this.setHeader('route', params.route_set);\n        }\n        else if (ua.configuration.usePreloadedRoute) {\n            this.setHeader('route', ua.transport.server.sip_uri);\n        }\n        // Via\n        // Empty Via header. Will be filled by the client transaction.\n        this.setHeader('via', '');\n        // Max-Forwards\n        this.setHeader('max-forwards', SIP.UA.C.MAX_FORWARDS);\n        // To\n        to_uri = params.to_uri || ruri;\n        to = (params.to_displayName || params.to_displayName === 0) ? '\"' + params.to_displayName + '\" ' : '';\n        to += '<' + (to_uri && to_uri.toRaw ? to_uri.toRaw() : to_uri) + '>';\n        to += params.to_tag ? ';tag=' + params.to_tag : '';\n        this.to = new SIP.NameAddrHeader.parse(to);\n        this.setHeader('to', to);\n        // From\n        from_uri = params.from_uri || ua.configuration.uri;\n        if (params.from_displayName || params.from_displayName === 0) {\n            from = '\"' + params.from_displayName + '\" ';\n        }\n        else if (ua.configuration.displayName) {\n            from = '\"' + ua.configuration.displayName + '\" ';\n        }\n        else {\n            from = '';\n        }\n        from += '<' + (from_uri && from_uri.toRaw ? from_uri.toRaw() : from_uri) + '>;tag=';\n        from += params.from_tag || SIP.Utils.newTag();\n        this.from = new SIP.NameAddrHeader.parse(from);\n        this.setHeader('from', from);\n        // Call-ID\n        call_id = params.call_id || (ua.configuration.sipjsId + SIP.Utils.createRandomToken(15));\n        this.call_id = call_id;\n        this.setHeader('call-id', call_id);\n        // CSeq\n        cseq = params.cseq || Math.floor(Math.random() * 10000);\n        this.cseq = cseq;\n        this.setHeader('cseq', cseq + ' ' + method);\n    };\n    OutgoingRequest.prototype = {\n        /**\n         * Replace the the given header by the given value.\n         * @param {String} name header name\n         * @param {String | Array} value header value\n         */\n        setHeader: function (name, value) {\n            this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n        },\n        /**\n         * Get the value of the given header name at the given position.\n         * @param {String} name header name\n         * @returns {String|undefined} Returns the specified header, undefined if header doesn't exist.\n         */\n        getHeader: function (name) {\n            var regexp, idx, length = this.extraHeaders.length, header = this.headers[SIP.Utils.headerize(name)];\n            if (header) {\n                if (header[0]) {\n                    return header[0];\n                }\n            }\n            else {\n                regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n                for (idx = 0; idx < length; idx++) {\n                    header = this.extraHeaders[idx];\n                    if (regexp.test(header)) {\n                        return header.substring(header.indexOf(':') + 1).trim();\n                    }\n                }\n            }\n            return;\n        },\n        /**\n         * Get the header/s of the given name.\n         * @param {String} name header name\n         * @returns {Array} Array with all the headers of the specified name.\n         */\n        getHeaders: function (name) {\n            var idx, length, regexp, header = this.headers[SIP.Utils.headerize(name)], result = [];\n            if (header) {\n                length = header.length;\n                for (idx = 0; idx < length; idx++) {\n                    result.push(header[idx]);\n                }\n                return result;\n            }\n            else {\n                length = this.extraHeaders.length;\n                regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n                for (idx = 0; idx < length; idx++) {\n                    header = this.extraHeaders[idx];\n                    if (regexp.test(header)) {\n                        result.push(header.substring(header.indexOf(':') + 1).trim());\n                    }\n                }\n                return result;\n            }\n        },\n        /**\n         * Verify the existence of the given header.\n         * @param {String} name header name\n         * @returns {boolean} true if header with given name exists, false otherwise\n         */\n        hasHeader: function (name) {\n            var regexp, idx, length = this.extraHeaders.length;\n            if (this.headers[SIP.Utils.headerize(name)]) {\n                return true;\n            }\n            else {\n                regexp = new RegExp('^\\\\s*' + name + '\\\\s*:', 'i');\n                for (idx = 0; idx < length; idx++) {\n                    if (regexp.test(this.extraHeaders[idx])) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        },\n        toString: function () {\n            var msg = '', header, length, idx;\n            msg += this.method + ' ' + (this.ruri.toRaw ? this.ruri.toRaw() : this.ruri) + ' SIP/2.0\\r\\n';\n            for (header in this.headers) {\n                length = this.headers[header].length;\n                for (idx = 0; idx < length; idx++) {\n                    msg += header + ': ' + this.headers[header][idx] + '\\r\\n';\n                }\n            }\n            length = this.extraHeaders.length;\n            for (idx = 0; idx < length; idx++) {\n                msg += this.extraHeaders[idx].trim() + '\\r\\n';\n            }\n            msg += getSupportedHeader(this);\n            msg += 'User-Agent: ' + this.ua.configuration.userAgentString + '\\r\\n';\n            if (this.body) {\n                if (typeof this.body === 'string') {\n                    length = SIP.Utils.str_utf8_length(this.body);\n                    msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n                    msg += this.body;\n                }\n                else {\n                    if (this.body.body && this.body.contentType) {\n                        length = SIP.Utils.str_utf8_length(this.body.body);\n                        msg += 'Content-Type: ' + this.body.contentType + '\\r\\n';\n                        msg += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n                        msg += this.body.body;\n                    }\n                    else {\n                        msg += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n                    }\n                }\n            }\n            else {\n                msg += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n            }\n            return msg;\n        }\n    };\n    /**\n     * @augments SIP\n     * @class Class for incoming SIP message.\n     */\n    IncomingMessage = function () {\n        this.data = null;\n        this.headers = null;\n        this.method = null;\n        this.via = null;\n        this.via_branch = null;\n        this.call_id = null;\n        this.cseq = null;\n        this.from = null;\n        this.from_tag = null;\n        this.to = null;\n        this.to_tag = null;\n        this.body = null;\n    };\n    IncomingMessage.prototype = {\n        /**\n        * Insert a header of the given name and value into the last position of the\n        * header array.\n        * @param {String} name header name\n        * @param {String} value header value\n        */\n        addHeader: function (name, value) {\n            var header = { raw: value };\n            name = SIP.Utils.headerize(name);\n            if (this.headers[name]) {\n                this.headers[name].push(header);\n            }\n            else {\n                this.headers[name] = [header];\n            }\n        },\n        /**\n         * Get the value of the given header name at the given position.\n         * @param {String} name header name\n         * @returns {String|undefined} Returns the specified header, null if header doesn't exist.\n         */\n        getHeader: function (name) {\n            var header = this.headers[SIP.Utils.headerize(name)];\n            if (header) {\n                if (header[0]) {\n                    return header[0].raw;\n                }\n            }\n            else {\n                return;\n            }\n        },\n        /**\n         * Get the header/s of the given name.\n         * @param {String} name header name\n         * @returns {Array} Array with all the headers of the specified name.\n         */\n        getHeaders: function (name) {\n            var idx, length, header = this.headers[SIP.Utils.headerize(name)], result = [];\n            if (!header) {\n                return [];\n            }\n            length = header.length;\n            for (idx = 0; idx < length; idx++) {\n                result.push(header[idx].raw);\n            }\n            return result;\n        },\n        /**\n         * Verify the existence of the given header.\n         * @param {String} name header name\n         * @returns {boolean} true if header with given name exists, false otherwise\n         */\n        hasHeader: function (name) {\n            return (this.headers[SIP.Utils.headerize(name)]) ? true : false;\n        },\n        /**\n        * Parse the given header on the given index.\n        * @param {String} name header name\n        * @param {Number} [idx=0] header index\n        * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n        */\n        parseHeader: function (name, idx) {\n            var header, value, parsed;\n            name = SIP.Utils.headerize(name);\n            idx = idx || 0;\n            if (!this.headers[name]) {\n                this.logger.log('header \"' + name + '\" not present');\n                return;\n            }\n            else if (idx >= this.headers[name].length) {\n                this.logger.log('not so many \"' + name + '\" headers present');\n                return;\n            }\n            header = this.headers[name][idx];\n            value = header.raw;\n            if (header.parsed) {\n                return header.parsed;\n            }\n            //substitute '-' by '_' for grammar rule matching.\n            parsed = SIP.Grammar.parse(value, name.replace(/-/g, '_'));\n            if (parsed === -1) {\n                this.headers[name].splice(idx, 1); //delete from headers\n                this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n                return;\n            }\n            else {\n                header.parsed = parsed;\n                return parsed;\n            }\n        },\n        /**\n         * Message Header attribute selector. Alias of parseHeader.\n         * @param {String} name header name\n         * @param {Number} [idx=0] header index\n         * @returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.\n         *\n         * @example\n         * message.s('via',3).port\n         */\n        s: function (name, idx) {\n            return this.parseHeader(name, idx);\n        },\n        /**\n        * Replace the value of the given header by the value.\n        * @param {String} name header name\n        * @param {String} value header value\n        */\n        setHeader: function (name, value) {\n            var header = { raw: value };\n            this.headers[SIP.Utils.headerize(name)] = [header];\n        },\n        toString: function () {\n            return this.data;\n        }\n    };\n    /**\n     * @augments IncomingMessage\n     * @class Class for incoming SIP request.\n     */\n    IncomingRequest = function (ua) {\n        this.logger = ua.getLogger('sip.sipmessage');\n        this.ua = ua;\n        this.headers = {};\n        this.ruri = null;\n        this.transport = null;\n        this.server_transaction = null;\n    };\n    IncomingRequest.prototype = new IncomingMessage();\n    /**\n    * Stateful reply.\n    * @param {Number} code status code\n    * @param {String} reason reason phrase\n    * @param {Object} headers extra headers\n    * @param {String} body body\n    * @param {Function} [onSuccess] onSuccess callback\n    * @param {Function} [onFailure] onFailure callback\n    */\n    // TODO: Get rid of callbacks and make promise based\n    IncomingRequest.prototype.reply = function (code, reason, extraHeaders, body, onSuccess, onFailure) {\n        var rr, vias, length, idx, response, to = this.getHeader('To'), r = 0, v = 0;\n        response = SIP.Utils.buildStatusLine(code, reason);\n        extraHeaders = (extraHeaders || []).slice();\n        if (this.method === SIP.C.INVITE && code > 100 && code <= 200) {\n            rr = this.getHeaders('record-route');\n            length = rr.length;\n            for (r; r < length; r++) {\n                response += 'Record-Route: ' + rr[r] + '\\r\\n';\n            }\n        }\n        vias = this.getHeaders('via');\n        length = vias.length;\n        for (v; v < length; v++) {\n            response += 'Via: ' + vias[v] + '\\r\\n';\n        }\n        if (!this.to_tag && code > 100) {\n            to += ';tag=' + SIP.Utils.newTag();\n        }\n        else if (this.to_tag && !this.s('to').hasParam('tag')) {\n            to += ';tag=' + this.to_tag;\n        }\n        response += 'To: ' + to + '\\r\\n';\n        response += 'From: ' + this.getHeader('From') + '\\r\\n';\n        response += 'Call-ID: ' + this.call_id + '\\r\\n';\n        response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n        length = extraHeaders.length;\n        for (idx = 0; idx < length; idx++) {\n            response += extraHeaders[idx].trim() + '\\r\\n';\n        }\n        response += getSupportedHeader(this);\n        response += 'User-Agent: ' + this.ua.configuration.userAgentString + '\\r\\n';\n        if (body) {\n            if (typeof body === 'string') {\n                length = SIP.Utils.str_utf8_length(body);\n                response += 'Content-Type: application/sdp\\r\\n';\n                response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n                response += body;\n            }\n            else {\n                if (body.body && body.contentType) {\n                    length = SIP.Utils.str_utf8_length(body.body);\n                    response += 'Content-Type: ' + body.contentType + '\\r\\n';\n                    response += 'Content-Length: ' + length + '\\r\\n\\r\\n';\n                    response += body.body;\n                }\n                else {\n                    response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n                }\n            }\n        }\n        else {\n            response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n        }\n        this.server_transaction.receiveResponse(code, response).then(onSuccess, onFailure);\n        return response;\n    };\n    /**\n    * Stateless reply.\n    * @param {Number} code status code\n    * @param {String} reason reason phrase\n    */\n    IncomingRequest.prototype.reply_sl = function (code, reason) {\n        var to, response, v = 0, vias = this.getHeaders('via'), length = vias.length;\n        response = SIP.Utils.buildStatusLine(code, reason);\n        for (v; v < length; v++) {\n            response += 'Via: ' + vias[v] + '\\r\\n';\n        }\n        to = this.getHeader('To');\n        if (!this.to_tag && code > 100) {\n            to += ';tag=' + SIP.Utils.newTag();\n        }\n        else if (this.to_tag && !this.s('to').hasParam('tag')) {\n            to += ';tag=' + this.to_tag;\n        }\n        response += 'To: ' + to + '\\r\\n';\n        response += 'From: ' + this.getHeader('From') + '\\r\\n';\n        response += 'Call-ID: ' + this.call_id + '\\r\\n';\n        response += 'CSeq: ' + this.cseq + ' ' + this.method + '\\r\\n';\n        response += 'User-Agent: ' + this.ua.configuration.userAgentString + '\\r\\n';\n        response += 'Content-Length: ' + 0 + '\\r\\n\\r\\n';\n        this.transport.send(response);\n    };\n    /**\n     * @augments IncomingMessage\n     * @class Class for incoming SIP response.\n     */\n    IncomingResponse = function (ua) {\n        this.logger = ua.getLogger('sip.sipmessage');\n        this.headers = {};\n        this.status_code = null;\n        this.reason_phrase = null;\n    };\n    IncomingResponse.prototype = new IncomingMessage();\n    SIP.OutgoingRequest = OutgoingRequest;\n    SIP.IncomingRequest = IncomingRequest;\n    SIP.IncomingResponse = IncomingResponse;\n};\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP URI\n */\n/**\n * @augments SIP\n * @class Class creating a SIP URI.\n *\n * @param {String} [scheme]\n * @param {String} [user]\n * @param {String} host\n * @param {String} [port]\n * @param {Object} [parameters]\n * @param {Object} [headers]\n *\n */\nmodule.exports = function (SIP) {\n    var URI;\n    URI = function (scheme, user, host, port, parameters, headers) {\n        var param, header, raw, normal;\n        // Checks\n        if (!host) {\n            throw new TypeError('missing or invalid \"host\" parameter');\n        }\n        // Initialize parameters\n        scheme = scheme || SIP.C.SIP;\n        this.parameters = {};\n        this.headers = {};\n        for (param in parameters) {\n            this.setParam(param, parameters[param]);\n        }\n        for (header in headers) {\n            this.setHeader(header, headers[header]);\n        }\n        // Raw URI\n        raw = {\n            scheme: scheme,\n            user: user,\n            host: host,\n            port: port\n        };\n        // Normalized URI\n        normal = {\n            scheme: scheme.toLowerCase(),\n            user: user,\n            host: host.toLowerCase(),\n            port: port\n        };\n        Object.defineProperties(this, {\n            _normal: {\n                get: function () { return normal; }\n            },\n            _raw: {\n                get: function () { return raw; }\n            },\n            scheme: {\n                get: function () { return normal.scheme; },\n                set: function (value) {\n                    raw.scheme = value;\n                    normal.scheme = value.toLowerCase();\n                }\n            },\n            user: {\n                get: function () { return normal.user; },\n                set: function (value) {\n                    normal.user = raw.user = value;\n                }\n            },\n            host: {\n                get: function () { return normal.host; },\n                set: function (value) {\n                    raw.host = value;\n                    normal.host = value.toLowerCase();\n                }\n            },\n            aor: {\n                get: function () { return normal.user + '@' + normal.host; }\n            },\n            port: {\n                get: function () { return normal.port; },\n                set: function (value) {\n                    normal.port = raw.port = value === 0 ? value : (parseInt(value, 10) || null);\n                }\n            }\n        });\n    };\n    URI.prototype = {\n        setParam: function (key, value) {\n            if (key) {\n                this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n            }\n        },\n        getParam: function (key) {\n            if (key) {\n                return this.parameters[key.toLowerCase()];\n            }\n        },\n        hasParam: function (key) {\n            if (key) {\n                return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;\n            }\n        },\n        deleteParam: function (parameter) {\n            var value;\n            parameter = parameter.toLowerCase();\n            if (this.parameters.hasOwnProperty(parameter)) {\n                value = this.parameters[parameter];\n                delete this.parameters[parameter];\n                return value;\n            }\n        },\n        clearParams: function () {\n            this.parameters = {};\n        },\n        setHeader: function (name, value) {\n            this.headers[SIP.Utils.headerize(name)] = (value instanceof Array) ? value : [value];\n        },\n        getHeader: function (name) {\n            if (name) {\n                return this.headers[SIP.Utils.headerize(name)];\n            }\n        },\n        hasHeader: function (name) {\n            if (name) {\n                return (this.headers.hasOwnProperty(SIP.Utils.headerize(name)) && true) || false;\n            }\n        },\n        deleteHeader: function (header) {\n            var value;\n            header = SIP.Utils.headerize(header);\n            if (this.headers.hasOwnProperty(header)) {\n                value = this.headers[header];\n                delete this.headers[header];\n                return value;\n            }\n        },\n        clearHeaders: function () {\n            this.headers = {};\n        },\n        clone: function () {\n            return new URI(this._raw.scheme, this._raw.user, this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));\n        },\n        toRaw: function () {\n            return this._toString(this._raw);\n        },\n        toString: function () {\n            return this._toString(this._normal);\n        },\n        _toString: function (uri) {\n            var header, parameter, idx, uriString, headers = [];\n            uriString = uri.scheme + ':';\n            // add slashes if it's not a sip(s) URI\n            if (!uri.scheme.toLowerCase().match(\"^sips?$\")) {\n                uriString += \"//\";\n            }\n            if (uri.user) {\n                uriString += SIP.Utils.escapeUser(uri.user) + '@';\n            }\n            uriString += uri.host;\n            if (uri.port || uri.port === 0) {\n                uriString += ':' + uri.port;\n            }\n            for (parameter in this.parameters) {\n                uriString += ';' + parameter;\n                if (this.parameters[parameter] !== null) {\n                    uriString += '=' + this.parameters[parameter];\n                }\n            }\n            for (header in this.headers) {\n                for (idx in this.headers[header]) {\n                    headers.push(header + '=' + this.headers[header][idx]);\n                }\n            }\n            if (headers.length > 0) {\n                uriString += '?' + headers.join('&');\n            }\n            return uriString;\n        }\n    };\n    /**\n      * Parse the given string and returns a SIP.URI instance or undefined if\n      * it is an invalid URI.\n      * @public\n      * @param {String} uri\n      */\n    URI.parse = function (uri) {\n        uri = SIP.Grammar.parse(uri, 'SIP_URI');\n        if (uri !== -1) {\n            return uri;\n        }\n        else {\n            return undefined;\n        }\n    };\n    SIP.URI = URI;\n};\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP NameAddrHeader\n */\n/**\n * @augments SIP\n * @class Class creating a Name Address SIP header.\n *\n * @param {SIP.URI} uri\n * @param {String} [displayName]\n * @param {Object} [parameters]\n *\n */\nmodule.exports = function (SIP) {\n    var NameAddrHeader;\n    NameAddrHeader = function (uri, displayName, parameters) {\n        var param;\n        // Checks\n        if (!uri || !(uri instanceof SIP.URI)) {\n            throw new TypeError('missing or invalid \"uri\" parameter');\n        }\n        // Initialize parameters\n        this.uri = uri;\n        this.parameters = {};\n        for (param in parameters) {\n            this.setParam(param, parameters[param]);\n        }\n        Object.defineProperties(this, {\n            friendlyName: {\n                get: function () { return this.displayName || uri.aor; }\n            },\n            displayName: {\n                get: function () { return displayName; },\n                set: function (value) {\n                    displayName = (value === 0) ? '0' : value;\n                }\n            }\n        });\n    };\n    NameAddrHeader.prototype = {\n        setParam: function (key, value) {\n            if (key) {\n                this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();\n            }\n        },\n        getParam: SIP.URI.prototype.getParam,\n        hasParam: SIP.URI.prototype.hasParam,\n        deleteParam: SIP.URI.prototype.deleteParam,\n        clearParams: SIP.URI.prototype.clearParams,\n        clone: function () {\n            return new NameAddrHeader(this.uri.clone(), this.displayName, JSON.parse(JSON.stringify(this.parameters)));\n        },\n        toString: function () {\n            var body, parameter;\n            body = (this.displayName || this.displayName === 0) ? '\"' + this.displayName + '\" ' : '';\n            body += '<' + this.uri.toString() + '>';\n            for (parameter in this.parameters) {\n                body += ';' + parameter;\n                if (this.parameters[parameter] !== null) {\n                    body += '=' + this.parameters[parameter];\n                }\n            }\n            return body;\n        }\n    };\n    /**\n      * Parse the given string and returns a SIP.NameAddrHeader instance or undefined if\n      * it is an invalid NameAddrHeader.\n      * @public\n      * @param {String} name_addr_header\n      */\n    NameAddrHeader.parse = function (name_addr_header) {\n        name_addr_header = SIP.Grammar.parse(name_addr_header, 'Name_Addr_Header');\n        if (name_addr_header !== -1) {\n            return name_addr_header;\n        }\n        else {\n            return undefined;\n        }\n    };\n    SIP.NameAddrHeader = NameAddrHeader;\n};\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP Transactions\n */\n/**\n * SIP Transactions module.\n * @augments SIP\n */\nmodule.exports = function (SIP) {\n    var C = {\n        // Transaction states\n        STATUS_TRYING: 1,\n        STATUS_PROCEEDING: 2,\n        STATUS_CALLING: 3,\n        STATUS_ACCEPTED: 4,\n        STATUS_COMPLETED: 5,\n        STATUS_TERMINATED: 6,\n        STATUS_CONFIRMED: 7,\n        // Transaction types\n        NON_INVITE_CLIENT: 'nict',\n        NON_INVITE_SERVER: 'nist',\n        INVITE_CLIENT: 'ict',\n        INVITE_SERVER: 'ist'\n    };\n    function buildViaHeader(request_sender, transport, id) {\n        var via;\n        via = 'SIP/2.0/' + (request_sender.ua.configuration.hackViaTcp ? 'TCP' : transport.server.scheme);\n        via += ' ' + request_sender.ua.configuration.viaHost + ';branch=' + id;\n        if (request_sender.ua.configuration.forceRport) {\n            via += ';rport';\n        }\n        return via;\n    }\n    /**\n    * @augments SIP.Transactions\n    * @class Non Invite Client Transaction\n    * @param {SIP.RequestSender} request_sender\n    * @param {SIP.OutgoingRequest} request\n    * @param {SIP.Transport} transport\n    */\n    var NonInviteClientTransaction = function (request_sender, request, transport) {\n        var via;\n        this.type = C.NON_INVITE_CLIENT;\n        this.transport = transport;\n        this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n        this.request_sender = request_sender;\n        this.request = request;\n        this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n        via = buildViaHeader(request_sender, transport, this.id);\n        this.request.setHeader('via', via);\n        this.request_sender.ua.newTransaction(this);\n    };\n    NonInviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n    NonInviteClientTransaction.prototype.stateChanged = function (state) {\n        this.state = state;\n        this.emit('stateChanged');\n    };\n    NonInviteClientTransaction.prototype.send = function () {\n        var tr = this;\n        this.stateChanged(C.STATUS_TRYING);\n        this.F = SIP.Timers.setTimeout(tr.timer_F.bind(tr), SIP.Timers.TIMER_F);\n        this.transport.send(this.request).catch(function () {\n            this.onTransportError();\n        }.bind(this));\n    };\n    NonInviteClientTransaction.prototype.onTransportError = function () {\n        this.logger.log('transport error occurred, deleting non-INVITE client transaction ' + this.id);\n        SIP.Timers.clearTimeout(this.F);\n        SIP.Timers.clearTimeout(this.K);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.request_sender.ua.destroyTransaction(this);\n        this.request_sender.onTransportError();\n    };\n    NonInviteClientTransaction.prototype.timer_F = function () {\n        this.logger.debug('Timer F expired for non-INVITE client transaction ' + this.id);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.request_sender.ua.destroyTransaction(this);\n        this.request_sender.onRequestTimeout();\n    };\n    NonInviteClientTransaction.prototype.timer_K = function () {\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.request_sender.ua.destroyTransaction(this);\n    };\n    NonInviteClientTransaction.prototype.receiveResponse = function (response) {\n        var tr = this, status_code = response.status_code;\n        if (status_code < 200) {\n            switch (this.state) {\n                case C.STATUS_TRYING:\n                case C.STATUS_PROCEEDING:\n                    this.stateChanged(C.STATUS_PROCEEDING);\n                    this.request_sender.receiveResponse(response);\n                    break;\n            }\n        }\n        else {\n            switch (this.state) {\n                case C.STATUS_TRYING:\n                case C.STATUS_PROCEEDING:\n                    this.stateChanged(C.STATUS_COMPLETED);\n                    SIP.Timers.clearTimeout(this.F);\n                    if (status_code === 408) {\n                        this.request_sender.onRequestTimeout();\n                    }\n                    else {\n                        this.request_sender.receiveResponse(response);\n                    }\n                    this.K = SIP.Timers.setTimeout(tr.timer_K.bind(tr), SIP.Timers.TIMER_K);\n                    break;\n                case C.STATUS_COMPLETED:\n                    break;\n            }\n        }\n    };\n    /**\n    * @augments SIP.Transactions\n    * @class Invite Client Transaction\n    * @param {SIP.RequestSender} request_sender\n    * @param {SIP.OutgoingRequest} request\n    * @param {SIP.Transport} transport\n    */\n    var InviteClientTransaction = function (request_sender, request, transport) {\n        var via, tr = this;\n        this.type = C.INVITE_CLIENT;\n        this.transport = transport;\n        this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n        this.request_sender = request_sender;\n        this.request = request;\n        this.logger = request_sender.ua.getLogger('sip.transaction.ict', this.id);\n        via = buildViaHeader(request_sender, transport, this.id);\n        this.request.setHeader('via', via);\n        this.request_sender.ua.newTransaction(this);\n        // Add the cancel property to the request.\n        //Will be called from the request instance, not the transaction itself.\n        this.request.cancel = function (reason, extraHeaders) {\n            extraHeaders = (extraHeaders || []).slice();\n            var length = extraHeaders.length;\n            var extraHeadersString = null;\n            for (var idx = 0; idx < length; idx++) {\n                extraHeadersString = (extraHeadersString || '') + extraHeaders[idx].trim() + '\\r\\n';\n            }\n            tr.cancel_request(tr, reason, extraHeadersString);\n        };\n    };\n    InviteClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n    InviteClientTransaction.prototype.stateChanged = function (state) {\n        this.state = state;\n        this.emit('stateChanged');\n    };\n    InviteClientTransaction.prototype.send = function () {\n        var tr = this;\n        this.stateChanged(C.STATUS_CALLING);\n        this.B = SIP.Timers.setTimeout(tr.timer_B.bind(tr), SIP.Timers.TIMER_B);\n        this.transport.send(this.request).catch(function () {\n            this.onTransportError();\n        }.bind(this));\n    };\n    InviteClientTransaction.prototype.onTransportError = function () {\n        this.logger.log('transport error occurred, deleting INVITE client transaction ' + this.id);\n        SIP.Timers.clearTimeout(this.B);\n        SIP.Timers.clearTimeout(this.D);\n        SIP.Timers.clearTimeout(this.M);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.request_sender.ua.destroyTransaction(this);\n        if (this.state !== C.STATUS_ACCEPTED) {\n            this.request_sender.onTransportError();\n        }\n    };\n    // RFC 6026 7.2\n    InviteClientTransaction.prototype.timer_M = function () {\n        this.logger.debug('Timer M expired for INVITE client transaction ' + this.id);\n        if (this.state === C.STATUS_ACCEPTED) {\n            SIP.Timers.clearTimeout(this.B);\n            this.stateChanged(C.STATUS_TERMINATED);\n            this.request_sender.ua.destroyTransaction(this);\n        }\n    };\n    // RFC 3261 17.1.1\n    InviteClientTransaction.prototype.timer_B = function () {\n        this.logger.debug('Timer B expired for INVITE client transaction ' + this.id);\n        if (this.state === C.STATUS_CALLING) {\n            this.stateChanged(C.STATUS_TERMINATED);\n            this.request_sender.ua.destroyTransaction(this);\n            this.request_sender.onRequestTimeout();\n        }\n    };\n    InviteClientTransaction.prototype.timer_D = function () {\n        this.logger.debug('Timer D expired for INVITE client transaction ' + this.id);\n        SIP.Timers.clearTimeout(this.B);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.request_sender.ua.destroyTransaction(this);\n    };\n    InviteClientTransaction.prototype.sendACK = function (options) {\n        // TODO: Move PRACK stuff into the transaction layer. That is really where it should be\n        var self = this, ruri;\n        options = options || {};\n        if (this.response.getHeader('contact')) {\n            ruri = this.response.parseHeader('contact').uri;\n        }\n        else {\n            ruri = this.request.ruri;\n        }\n        var ack = new SIP.OutgoingRequest(\"ACK\", ruri, this.request.ua, {\n            cseq: this.response.cseq,\n            call_id: this.response.call_id,\n            from_uri: this.response.from.uri,\n            from_tag: this.response.from_tag,\n            to_uri: this.response.to.uri,\n            to_tag: this.response.to_tag,\n            route_set: this.response.getHeaders('record-route').reverse()\n        }, options.extraHeaders || [], options.body);\n        this.ackSender = new SIP.RequestSender({\n            request: ack,\n            onRequestTimeout: this.request_sender.applicant.applicant ? this.request_sender.applicant.applicant.onRequestTimeout : function () {\n                self.logger.warn(\"ACK Request timed out\");\n            },\n            onTransportError: this.request_sender.applicant.applicant ? this.request_sender.applicant.applicant.onRequestTransportError : function () {\n                self.logger.warn(\"ACK Request had a transport error\");\n            },\n            receiveResponse: options.receiveResponse || function () {\n                self.logger.warn(\"Received a response to an ACK which was unexpected. Dropping Response.\");\n            }\n        }, this.request.ua).send();\n        return ack;\n    };\n    InviteClientTransaction.prototype.cancel_request = function (tr, reason, extraHeaders) {\n        var request = tr.request;\n        this.cancel = SIP.C.CANCEL + ' ' + request.ruri + ' SIP/2.0\\r\\n';\n        this.cancel += 'Via: ' + request.headers['Via'].toString() + '\\r\\n';\n        if (this.request.headers['Route']) {\n            this.cancel += 'Route: ' + request.headers['Route'].toString() + '\\r\\n';\n        }\n        this.cancel += 'To: ' + request.headers['To'].toString() + '\\r\\n';\n        this.cancel += 'From: ' + request.headers['From'].toString() + '\\r\\n';\n        this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\\r\\n';\n        this.cancel += 'Max-Forwards: ' + SIP.UA.C.MAX_FORWARDS + '\\r\\n';\n        this.cancel += 'CSeq: ' + request.headers['CSeq'].toString().split(' ')[0] +\n            ' CANCEL\\r\\n';\n        if (reason) {\n            this.cancel += 'Reason: ' + reason + '\\r\\n';\n        }\n        if (extraHeaders) {\n            this.cancel += extraHeaders;\n        }\n        this.cancel += 'Content-Length: 0\\r\\n\\r\\n';\n        // Send only if a provisional response (>100) has been received.\n        if (this.state === C.STATUS_PROCEEDING) {\n            this.transport.send(this.cancel);\n        }\n    };\n    InviteClientTransaction.prototype.receiveResponse = function (response) {\n        var tr = this, status_code = response.status_code;\n        // This may create a circular dependency...\n        response.transaction = this;\n        if (this.response &&\n            this.response.status_code === response.status_code &&\n            this.response.cseq === response.cseq) {\n            this.logger.debug(\"ICT Received a retransmission for cseq: \" + response.cseq);\n            if (this.ackSender) {\n                this.ackSender.send();\n            }\n            return;\n        }\n        this.response = response;\n        if (status_code >= 100 && status_code <= 199) {\n            switch (this.state) {\n                case C.STATUS_CALLING:\n                    this.stateChanged(C.STATUS_PROCEEDING);\n                    this.request_sender.receiveResponse(response);\n                    if (this.cancel) {\n                        this.transport.send(this.cancel);\n                    }\n                    break;\n                case C.STATUS_PROCEEDING:\n                    this.request_sender.receiveResponse(response);\n                    break;\n            }\n        }\n        else if (status_code >= 200 && status_code <= 299) {\n            switch (this.state) {\n                case C.STATUS_CALLING:\n                case C.STATUS_PROCEEDING:\n                    this.stateChanged(C.STATUS_ACCEPTED);\n                    this.M = SIP.Timers.setTimeout(tr.timer_M.bind(tr), SIP.Timers.TIMER_M);\n                    this.request_sender.receiveResponse(response);\n                    break;\n                case C.STATUS_ACCEPTED:\n                    this.request_sender.receiveResponse(response);\n                    break;\n            }\n        }\n        else if (status_code >= 300 && status_code <= 699) {\n            switch (this.state) {\n                case C.STATUS_CALLING:\n                case C.STATUS_PROCEEDING:\n                    this.stateChanged(C.STATUS_COMPLETED);\n                    this.sendACK();\n                    this.request_sender.receiveResponse(response);\n                    break;\n                case C.STATUS_COMPLETED:\n                    this.sendACK();\n                    break;\n            }\n        }\n    };\n    /**\n     * @augments SIP.Transactions\n     * @class ACK Client Transaction\n     * @param {SIP.RequestSender} request_sender\n     * @param {SIP.OutgoingRequest} request\n     * @param {SIP.Transport} transport\n     */\n    var AckClientTransaction = function (request_sender, request, transport) {\n        var via;\n        this.transport = transport;\n        this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);\n        this.request_sender = request_sender;\n        this.request = request;\n        this.logger = request_sender.ua.getLogger('sip.transaction.nict', this.id);\n        via = buildViaHeader(request_sender, transport, this.id);\n        this.request.setHeader('via', via);\n    };\n    AckClientTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n    AckClientTransaction.prototype.send = function () {\n        this.transport.send(this.request).catch(function () {\n            this.onTransportError();\n        }.bind(this));\n    };\n    AckClientTransaction.prototype.onTransportError = function () {\n        this.logger.log('transport error occurred, for an ACK client transaction ' + this.id);\n        this.request_sender.onTransportError();\n    };\n    /**\n    * @augments SIP.Transactions\n    * @class Non Invite Server Transaction\n    * @param {SIP.IncomingRequest} request\n    * @param {SIP.UA} ua\n    */\n    var NonInviteServerTransaction = function (request, ua) {\n        this.type = C.NON_INVITE_SERVER;\n        this.id = request.via_branch;\n        this.request = request;\n        this.transport = ua.transport;\n        this.ua = ua;\n        this.last_response = '';\n        request.server_transaction = this;\n        this.logger = ua.getLogger('sip.transaction.nist', this.id);\n        this.state = C.STATUS_TRYING;\n        ua.newTransaction(this);\n    };\n    NonInviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n    NonInviteServerTransaction.prototype.stateChanged = function (state) {\n        this.state = state;\n        this.emit('stateChanged');\n    };\n    NonInviteServerTransaction.prototype.timer_J = function () {\n        this.logger.debug('Timer J expired for non-INVITE server transaction ' + this.id);\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n    };\n    NonInviteServerTransaction.prototype.onTransportError = function () {\n        if (!this.transportError) {\n            this.transportError = true;\n            this.logger.log('transport error occurred, deleting non-INVITE server transaction ' + this.id);\n            SIP.Timers.clearTimeout(this.J);\n            this.stateChanged(C.STATUS_TERMINATED);\n            this.ua.destroyTransaction(this);\n        }\n    };\n    NonInviteServerTransaction.prototype.receiveResponse = function (status_code, response) {\n        var tr = this;\n        var deferred = SIP.Utils.defer();\n        if (status_code === 100) {\n            /* RFC 4320 4.1\n             * 'A SIP element MUST NOT\n             * send any provisional response with a\n             * Status-Code other than 100 to a non-INVITE request.'\n             */\n            switch (this.state) {\n                case C.STATUS_TRYING:\n                    this.stateChanged(C.STATUS_PROCEEDING);\n                    this.transport.send(response).catch(function () {\n                        this.onTransportError();\n                    }.bind(this));\n                    break;\n                case C.STATUS_PROCEEDING:\n                    this.last_response = response;\n                    this.transport.send(response).then(function () {\n                        deferred.resolve();\n                    }).catch(function () {\n                        this.onTransportError();\n                        deferred.reject();\n                    }.bind(this));\n                    break;\n            }\n        }\n        else if (status_code >= 200 && status_code <= 699) {\n            switch (this.state) {\n                case C.STATUS_TRYING:\n                case C.STATUS_PROCEEDING:\n                    this.stateChanged(C.STATUS_COMPLETED);\n                    this.last_response = response;\n                    this.J = SIP.Timers.setTimeout(tr.timer_J.bind(tr), SIP.Timers.TIMER_J);\n                    this.transport.send(response).then(function () {\n                        deferred.resolve();\n                    }).catch(function () {\n                        this.onTransportError();\n                        deferred.reject();\n                    }.bind(this));\n                    break;\n                case C.STATUS_COMPLETED:\n                    break;\n            }\n        }\n        return deferred.promise;\n    };\n    /**\n    * @augments SIP.Transactions\n    * @class Invite Server Transaction\n    * @param {SIP.IncomingRequest} request\n    * @param {SIP.UA} ua\n    */\n    var InviteServerTransaction = function (request, ua) {\n        this.type = C.INVITE_SERVER;\n        this.id = request.via_branch;\n        this.request = request;\n        this.transport = ua.transport;\n        this.ua = ua;\n        this.last_response = '';\n        request.server_transaction = this;\n        this.logger = ua.getLogger('sip.transaction.ist', this.id);\n        this.state = C.STATUS_PROCEEDING;\n        ua.newTransaction(this);\n        this.resendProvisionalTimer = null;\n        request.reply(100);\n    };\n    InviteServerTransaction.prototype = Object.create(SIP.EventEmitter.prototype);\n    InviteServerTransaction.prototype.stateChanged = function (state) {\n        this.state = state;\n        this.emit('stateChanged');\n    };\n    InviteServerTransaction.prototype.timer_H = function () {\n        this.logger.debug('Timer H expired for INVITE server transaction ' + this.id);\n        if (this.state === C.STATUS_COMPLETED) {\n            this.logger.warn('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');\n        }\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n    };\n    InviteServerTransaction.prototype.timer_I = function () {\n        this.stateChanged(C.STATUS_TERMINATED);\n        this.ua.destroyTransaction(this);\n    };\n    // RFC 6026 7.1\n    InviteServerTransaction.prototype.timer_L = function () {\n        this.logger.debug('Timer L expired for INVITE server transaction ' + this.id);\n        if (this.state === C.STATUS_ACCEPTED) {\n            this.stateChanged(C.STATUS_TERMINATED);\n            this.ua.destroyTransaction(this);\n        }\n    };\n    InviteServerTransaction.prototype.onTransportError = function () {\n        if (!this.transportError) {\n            this.transportError = true;\n            this.logger.log('transport error occurred, deleting INVITE server transaction ' + this.id);\n            if (this.resendProvisionalTimer !== null) {\n                SIP.Timers.clearInterval(this.resendProvisionalTimer);\n                this.resendProvisionalTimer = null;\n            }\n            SIP.Timers.clearTimeout(this.L);\n            SIP.Timers.clearTimeout(this.H);\n            SIP.Timers.clearTimeout(this.I);\n            this.stateChanged(C.STATUS_TERMINATED);\n            this.ua.destroyTransaction(this);\n        }\n    };\n    InviteServerTransaction.prototype.resend_provisional = function () {\n        this.transport.send(this.request).catch(function () {\n            this.onTransportError();\n        }.bind(this));\n    };\n    // INVITE Server Transaction RFC 3261 17.2.1\n    InviteServerTransaction.prototype.receiveResponse = function (status_code, response) {\n        var tr = this;\n        var deferred = SIP.Utils.defer();\n        if (status_code >= 100 && status_code <= 199) {\n            switch (this.state) {\n                case C.STATUS_PROCEEDING:\n                    this.transport.send(response).catch(function () {\n                        this.onTransportError();\n                    }.bind(this));\n                    this.last_response = response;\n                    break;\n            }\n        }\n        if (status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {\n            // Trigger the resendProvisionalTimer only for the first non 100 provisional response.\n            if (this.resendProvisionalTimer === null) {\n                this.resendProvisionalTimer = SIP.Timers.setInterval(tr.resend_provisional.bind(tr), SIP.Timers.PROVISIONAL_RESPONSE_INTERVAL);\n            }\n        }\n        else if (status_code >= 200 && status_code <= 299) {\n            switch (this.state) {\n                case C.STATUS_PROCEEDING:\n                    this.stateChanged(C.STATUS_ACCEPTED);\n                    this.last_response = response;\n                    this.L = SIP.Timers.setTimeout(tr.timer_L.bind(tr), SIP.Timers.TIMER_L);\n                    if (this.resendProvisionalTimer !== null) {\n                        SIP.Timers.clearInterval(this.resendProvisionalTimer);\n                        this.resendProvisionalTimer = null;\n                    }\n                /* falls through */\n                case C.STATUS_ACCEPTED:\n                    // Note that this point will be reached for proceeding tr.state also.\n                    this.transport.send(response).then(function () {\n                        deferred.resolve();\n                    }).catch(function (error) {\n                        this.logger.error(error);\n                        this.onTransportError();\n                        deferred.reject();\n                    }.bind(this));\n                    break;\n            }\n        }\n        else if (status_code >= 300 && status_code <= 699) {\n            switch (this.state) {\n                case C.STATUS_PROCEEDING:\n                    if (this.resendProvisionalTimer !== null) {\n                        SIP.Timers.clearInterval(this.resendProvisionalTimer);\n                        this.resendProvisionalTimer = null;\n                    }\n                    this.transport.send(response).then(function () {\n                        this.stateChanged(C.STATUS_COMPLETED);\n                        this.H = SIP.Timers.setTimeout(tr.timer_H.bind(tr), SIP.Timers.TIMER_H);\n                        deferred.resolve();\n                    }.bind(this)).catch(function (error) {\n                        this.logger.error(error);\n                        this.onTransportError();\n                        deferred.reject();\n                    }.bind(this));\n                    break;\n            }\n        }\n        return deferred.promise;\n    };\n    /**\n     * @function\n     * @param {SIP.UA} ua\n     * @param {SIP.IncomingRequest} request\n     *\n     * @return {boolean}\n     * INVITE:\n     *  _true_ if retransmission\n     *  _false_ new request\n     *\n     * ACK:\n     *  _true_  ACK to non2xx response\n     *  _false_ ACK must be passed to TU (accepted state)\n     *          ACK to 2xx response\n     *\n     * CANCEL:\n     *  _true_  no matching invite transaction\n     *  _false_ matching invite transaction and no final response sent\n     *\n     * OTHER:\n     *  _true_  retransmission\n     *  _false_ new request\n     */\n    var checkTransaction = function (ua, request) {\n        var tr;\n        switch (request.method) {\n            case SIP.C.INVITE:\n                tr = ua.transactions.ist[request.via_branch];\n                if (tr) {\n                    switch (tr.state) {\n                        case C.STATUS_PROCEEDING:\n                            tr.transport.send(tr.last_response);\n                            break;\n                        // RFC 6026 7.1 Invite retransmission\n                        //received while in C.STATUS_ACCEPTED state. Absorb it.\n                        case C.STATUS_ACCEPTED:\n                            break;\n                    }\n                    return true;\n                }\n                break;\n            case SIP.C.ACK:\n                tr = ua.transactions.ist[request.via_branch];\n                // RFC 6026 7.1\n                if (tr) {\n                    if (tr.state === C.STATUS_ACCEPTED) {\n                        return false;\n                    }\n                    else if (tr.state === C.STATUS_COMPLETED) {\n                        tr.stateChanged(C.STATUS_CONFIRMED);\n                        tr.I = SIP.Timers.setTimeout(tr.timer_I.bind(tr), SIP.Timers.TIMER_I);\n                        return true;\n                    }\n                }\n                // ACK to 2XX Response.\n                else {\n                    return false;\n                }\n                break;\n            case SIP.C.CANCEL:\n                tr = ua.transactions.ist[request.via_branch];\n                if (tr) {\n                    request.reply_sl(200);\n                    if (tr.state === C.STATUS_PROCEEDING) {\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                }\n                else {\n                    request.reply_sl(481);\n                    return true;\n                }\n            default:\n                // Non-INVITE Server Transaction RFC 3261 17.2.2\n                tr = ua.transactions.nist[request.via_branch];\n                if (tr) {\n                    switch (tr.state) {\n                        case C.STATUS_TRYING:\n                            break;\n                        case C.STATUS_PROCEEDING:\n                        case C.STATUS_COMPLETED:\n                            tr.transport.send(tr.last_response);\n                            break;\n                    }\n                    return true;\n                }\n                break;\n        }\n    };\n    SIP.Transactions = {\n        C: C,\n        checkTransaction: checkTransaction,\n        NonInviteClientTransaction: NonInviteClientTransaction,\n        InviteClientTransaction: InviteClientTransaction,\n        AckClientTransaction: AckClientTransaction,\n        NonInviteServerTransaction: NonInviteServerTransaction,\n        InviteServerTransaction: InviteServerTransaction\n    };\n};\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP Dialog\n */\n/**\n * @augments SIP\n * @class Class creating a SIP dialog.\n * @param {SIP.RTCSession} owner\n * @param {SIP.IncomingRequest|SIP.IncomingResponse} message\n * @param {Enum} type UAC / UAS\n * @param {Enum} state SIP.Dialog.C.STATUS_EARLY / SIP.Dialog.C.STATUS_CONFIRMED\n */\nmodule.exports = function (SIP) {\n    var RequestSender = __webpack_require__(17)(SIP);\n    var Dialog, C = {\n        // Dialog states\n        STATUS_EARLY: 1,\n        STATUS_CONFIRMED: 2\n    };\n    // RFC 3261 12.1\n    Dialog = function (owner, message, type, state) {\n        var contact;\n        this.uac_pending_reply = false;\n        this.uas_pending_reply = false;\n        if (!message.hasHeader('contact')) {\n            return {\n                error: 'unable to create a Dialog without Contact header field'\n            };\n        }\n        if (message instanceof SIP.IncomingResponse) {\n            state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;\n        }\n        else {\n            // Create confirmed dialog if state is not defined\n            state = state || C.STATUS_CONFIRMED;\n        }\n        contact = message.parseHeader('contact');\n        // RFC 3261 12.1.1\n        if (type === 'UAS') {\n            this.id = {\n                call_id: message.call_id,\n                local_tag: message.to_tag,\n                remote_tag: message.from_tag,\n                toString: function () {\n                    return this.call_id + this.local_tag + this.remote_tag;\n                }\n            };\n            this.state = state;\n            this.remote_seqnum = message.cseq;\n            this.local_uri = message.parseHeader('to').uri;\n            this.remote_uri = message.parseHeader('from').uri;\n            this.remote_target = contact.uri;\n            this.route_set = message.getHeaders('record-route');\n            this.invite_seqnum = message.cseq;\n            this.local_seqnum = message.cseq;\n        }\n        // RFC 3261 12.1.2\n        else if (type === 'UAC') {\n            this.id = {\n                call_id: message.call_id,\n                local_tag: message.from_tag,\n                remote_tag: message.to_tag,\n                toString: function () {\n                    return this.call_id + this.local_tag + this.remote_tag;\n                }\n            };\n            this.state = state;\n            this.invite_seqnum = message.cseq;\n            this.local_seqnum = message.cseq;\n            this.local_uri = message.parseHeader('from').uri;\n            this.pracked = [];\n            this.remote_uri = message.parseHeader('to').uri;\n            this.remote_target = contact.uri;\n            this.route_set = message.getHeaders('record-route').reverse();\n        }\n        this.logger = owner.ua.getLogger('sip.dialog', this.id.toString());\n        this.owner = owner;\n        owner.ua.dialogs[this.id.toString()] = this;\n        this.logger.log('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY' : 'CONFIRMED'));\n        owner.emit('dialog', this);\n    };\n    Dialog.prototype = {\n        /**\n         * @param {SIP.IncomingMessage} message\n         * @param {Enum} UAC/UAS\n         */\n        update: function (message, type) {\n            this.state = C.STATUS_CONFIRMED;\n            this.logger.log('dialog ' + this.id.toString() + '  changed to CONFIRMED state');\n            if (type === 'UAC') {\n                // RFC 3261 13.2.2.4\n                this.route_set = message.getHeaders('record-route').reverse();\n            }\n        },\n        terminate: function () {\n            this.logger.log('dialog ' + this.id.toString() + ' deleted');\n            if (this.sessionDescriptionHandler && this.state !== C.STATUS_CONFIRMED) {\n                // TODO: This should call .close() on the handler when implemented\n                this.sessionDescriptionHandler.close();\n            }\n            delete this.owner.ua.dialogs[this.id.toString()];\n        },\n        /**\n        * @param {String} method request method\n        * @param {Object} extraHeaders extra headers\n        * @returns {SIP.OutgoingRequest}\n        */\n        // RFC 3261 12.2.1.1\n        createRequest: function (method, extraHeaders, body) {\n            var cseq, request;\n            extraHeaders = (extraHeaders || []).slice();\n            if (!this.local_seqnum) {\n                this.local_seqnum = Math.floor(Math.random() * 10000);\n            }\n            cseq = (method === SIP.C.CANCEL || method === SIP.C.ACK) ? this.invite_seqnum : this.local_seqnum += 1;\n            request = new SIP.OutgoingRequest(method, this.remote_target, this.owner.ua, {\n                'cseq': cseq,\n                'call_id': this.id.call_id,\n                'from_uri': this.local_uri,\n                'from_tag': this.id.local_tag,\n                'to_uri': this.remote_uri,\n                'to_tag': this.id.remote_tag,\n                'route_set': this.route_set\n            }, extraHeaders, body);\n            request.dialog = this;\n            return request;\n        },\n        /**\n        * @param {SIP.IncomingRequest} request\n        * @returns {Boolean}\n        */\n        // RFC 3261 12.2.2\n        checkInDialogRequest: function (request) {\n            var self = this;\n            if (!this.remote_seqnum) {\n                this.remote_seqnum = request.cseq;\n            }\n            else if (request.cseq < this.remote_seqnum) {\n                //Do not try to reply to an ACK request.\n                if (request.method !== SIP.C.ACK) {\n                    request.reply(500);\n                }\n                if (request.cseq === this.invite_seqnum) {\n                    return true;\n                }\n                return false;\n            }\n            switch (request.method) {\n                // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-\n                case SIP.C.INVITE:\n                    if (this.uac_pending_reply === true) {\n                        request.reply(491);\n                    }\n                    else if (this.uas_pending_reply === true && request.cseq > this.remote_seqnum) {\n                        var retryAfter = (Math.random() * 10 | 0) + 1;\n                        request.reply(500, null, ['Retry-After:' + retryAfter]);\n                        this.remote_seqnum = request.cseq;\n                        return false;\n                    }\n                    else {\n                        this.uas_pending_reply = true;\n                        request.server_transaction.on('stateChanged', function stateChanged() {\n                            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n                                this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n                                this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n                                this.removeListener('stateChanged', stateChanged);\n                                self.uas_pending_reply = false;\n                            }\n                        });\n                    }\n                    // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted\n                    if (request.hasHeader('contact')) {\n                        request.server_transaction.on('stateChanged', function () {\n                            if (this.state === SIP.Transactions.C.STATUS_ACCEPTED) {\n                                self.remote_target = request.parseHeader('contact').uri;\n                            }\n                        });\n                    }\n                    break;\n                case SIP.C.NOTIFY:\n                    // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted\n                    if (request.hasHeader('contact')) {\n                        request.server_transaction.on('stateChanged', function () {\n                            if (this.state === SIP.Transactions.C.STATUS_COMPLETED) {\n                                self.remote_target = request.parseHeader('contact').uri;\n                            }\n                        });\n                    }\n                    break;\n            }\n            if (request.cseq > this.remote_seqnum) {\n                this.remote_seqnum = request.cseq;\n            }\n            return true;\n        },\n        sendRequest: function (applicant, method, options) {\n            options = options || {};\n            var extraHeaders = (options.extraHeaders || []).slice();\n            var body = null;\n            if (options.body) {\n                if (options.body.body) {\n                    body = options.body;\n                }\n                else {\n                    body = {};\n                    body.body = options.body;\n                    if (options.contentType) {\n                        body.contentType = options.contentType;\n                    }\n                }\n            }\n            var request = this.createRequest(method, extraHeaders, body), request_sender = new RequestSender(this, applicant, request);\n            request_sender.send();\n            return request;\n        },\n        /**\n        * @param {SIP.IncomingRequest} request\n        */\n        receiveRequest: function (request) {\n            //Check in-dialog request\n            if (!this.checkInDialogRequest(request)) {\n                return;\n            }\n            this.owner.receiveRequest(request);\n        }\n    };\n    Dialog.C = C;\n    SIP.Dialog = Dialog;\n};\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview In-Dialog Request Sender\n */\n/**\n * @augments SIP.Dialog\n * @class Class creating an In-dialog request sender.\n * @param {SIP.Dialog} dialog\n * @param {Object} applicant\n * @param {SIP.OutgoingRequest} request\n */\n/**\n * @fileoverview in-Dialog Request Sender\n */\nmodule.exports = function (SIP) {\n    var RequestSender;\n    RequestSender = function (dialog, applicant, request) {\n        this.dialog = dialog;\n        this.applicant = applicant;\n        this.request = request;\n        // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.\n        this.reattempt = false;\n        this.reattemptTimer = null;\n    };\n    RequestSender.prototype = {\n        send: function () {\n            var self = this, request_sender = new SIP.RequestSender(this, this.dialog.owner.ua);\n            request_sender.send();\n            // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-\n            if (this.request.method === SIP.C.INVITE && request_sender.clientTransaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n                this.dialog.uac_pending_reply = true;\n                request_sender.clientTransaction.on('stateChanged', function stateChanged() {\n                    if (this.state === SIP.Transactions.C.STATUS_ACCEPTED ||\n                        this.state === SIP.Transactions.C.STATUS_COMPLETED ||\n                        this.state === SIP.Transactions.C.STATUS_TERMINATED) {\n                        this.removeListener('stateChanged', stateChanged);\n                        self.dialog.uac_pending_reply = false;\n                    }\n                });\n            }\n        },\n        onRequestTimeout: function () {\n            this.applicant.onRequestTimeout();\n        },\n        onTransportError: function () {\n            this.applicant.onTransportError();\n        },\n        receiveResponse: function (response) {\n            var self = this;\n            // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.\n            if (response.status_code === 408 || response.status_code === 481) {\n                this.applicant.onDialogError(response);\n            }\n            else if (response.method === SIP.C.INVITE && response.status_code === 491) {\n                if (this.reattempt) {\n                    this.applicant.receiveResponse(response);\n                }\n                else {\n                    this.request.cseq.value = this.dialog.local_seqnum += 1;\n                    this.reattemptTimer = SIP.Timers.setTimeout(function () {\n                        if (self.applicant.owner.status !== SIP.Session.C.STATUS_TERMINATED) {\n                            self.reattempt = true;\n                            self.request_sender.send();\n                        }\n                    }, this.getReattemptTimeout());\n                }\n            }\n            else {\n                this.applicant.receiveResponse(response);\n            }\n        }\n    };\n    return RequestSender;\n};\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview Request Sender\n */\n/**\n * @augments SIP\n * @class Class creating a request sender.\n * @param {Object} applicant\n * @param {SIP.UA} ua\n */\nmodule.exports = function (SIP) {\n    var RequestSender;\n    RequestSender = function (applicant, ua) {\n        this.logger = ua.getLogger('sip.requestsender');\n        this.ua = ua;\n        this.applicant = applicant;\n        this.method = applicant.request.method;\n        this.request = applicant.request;\n        this.credentials = null;\n        this.challenged = false;\n        this.staled = false;\n        // If ua is in closing process or even closed just allow sending Bye and ACK\n        if (ua.status === SIP.UA.C.STATUS_USER_CLOSED && (this.method !== SIP.C.BYE || this.method !== SIP.C.ACK)) {\n            this.onTransportError();\n        }\n    };\n    /**\n    * Create the client transaction and send the message.\n    */\n    RequestSender.prototype = {\n        send: function () {\n            switch (this.method) {\n                case \"INVITE\":\n                    this.clientTransaction = new SIP.Transactions.InviteClientTransaction(this, this.request, this.ua.transport);\n                    break;\n                case \"ACK\":\n                    this.clientTransaction = new SIP.Transactions.AckClientTransaction(this, this.request, this.ua.transport);\n                    break;\n                default:\n                    this.clientTransaction = new SIP.Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);\n            }\n            this.clientTransaction.send();\n            return this.clientTransaction;\n        },\n        /**\n        * Callback fired when receiving a request timeout error from the client transaction.\n        * To be re-defined by the applicant.\n        * @event\n        */\n        onRequestTimeout: function () {\n            this.applicant.onRequestTimeout();\n        },\n        /**\n        * Callback fired when receiving a transport error from the client transaction.\n        * To be re-defined by the applicant.\n        * @event\n        */\n        onTransportError: function () {\n            this.applicant.onTransportError();\n        },\n        /**\n        * Called from client transaction when receiving a correct response to the request.\n        * Authenticate request if needed or pass the response back to the applicant.\n        * @param {SIP.IncomingResponse} response\n        */\n        receiveResponse: function (response) {\n            var cseq, challenge, authorization_header_name, status_code = response.status_code;\n            /*\n            * Authentication\n            * Authenticate once. _challenged_ flag used to avoid infinite authentications.\n            */\n            if (status_code === 401 || status_code === 407) {\n                // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n                if (response.status_code === 401) {\n                    challenge = response.parseHeader('www-authenticate');\n                    authorization_header_name = 'authorization';\n                }\n                else {\n                    challenge = response.parseHeader('proxy-authenticate');\n                    authorization_header_name = 'proxy-authorization';\n                }\n                // Verify it seems a valid challenge.\n                if (!challenge) {\n                    this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');\n                    this.applicant.receiveResponse(response);\n                    return;\n                }\n                if (!this.challenged || (!this.staled && challenge.stale === true)) {\n                    if (!this.credentials) {\n                        this.credentials = this.ua.configuration.authenticationFactory(this.ua);\n                    }\n                    // Verify that the challenge is really valid.\n                    if (!this.credentials.authenticate(this.request, challenge)) {\n                        this.applicant.receiveResponse(response);\n                        return;\n                    }\n                    this.challenged = true;\n                    if (challenge.stale) {\n                        this.staled = true;\n                    }\n                    if (response.method === SIP.C.REGISTER) {\n                        cseq = this.applicant.cseq += 1;\n                    }\n                    else if (this.request.dialog) {\n                        cseq = this.request.dialog.local_seqnum += 1;\n                    }\n                    else {\n                        cseq = this.request.cseq + 1;\n                        this.request.cseq = cseq;\n                    }\n                    this.request.setHeader('cseq', cseq + ' ' + this.method);\n                    this.request.setHeader(authorization_header_name, this.credentials.toString());\n                    this.send();\n                }\n                else {\n                    this.applicant.receiveResponse(response);\n                }\n            }\n            else {\n                this.applicant.receiveResponse(response);\n            }\n        }\n    };\n    SIP.RequestSender = RequestSender;\n};\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = function (SIP) {\n    var RegisterContext;\n    RegisterContext = function (ua) {\n        var params = {}, regId = 1;\n        this.registrar = ua.configuration.registrarServer;\n        this.expires = ua.configuration.registerExpires;\n        // Contact header\n        this.contact = ua.contact.toString();\n        if (regId) {\n            this.contact += ';reg-id=' + regId;\n            this.contact += ';+sip.instance=\"<urn:uuid:' + ua.configuration.instanceId + '>\"';\n        }\n        // Call-ID and CSeq values RFC3261 10.2\n        this.call_id = SIP.Utils.createRandomToken(22);\n        this.cseq = Math.floor(Math.random() * 10000);\n        this.to_uri = ua.configuration.uri;\n        params.to_uri = this.to_uri;\n        params.to_displayName = ua.configuration.displayName;\n        params.call_id = this.call_id;\n        params.cseq = this.cseq;\n        // Extends ClientContext\n        SIP.Utils.augment(this, SIP.ClientContext, [ua, 'REGISTER', this.registrar, { params: params }]);\n        this.registrationTimer = null;\n        this.registrationExpiredTimer = null;\n        // Set status\n        this.registered = false;\n        this.logger = ua.getLogger('sip.registercontext');\n        ua.on('transportCreated', function (transport) {\n            transport.on('disconnected', this.onTransportDisconnected.bind(this));\n        }.bind(this));\n    };\n    RegisterContext.prototype = Object.create({}, {\n        register: { writable: true, value: function register(options) {\n                var self = this, extraHeaders;\n                // Handle Options\n                this.options = options || {};\n                extraHeaders = (this.options.extraHeaders || []).slice();\n                extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires);\n                extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n                // Save original extraHeaders to be used in .close\n                this.closeHeaders = this.options.closeWithHeaders ?\n                    (this.options.extraHeaders || []).slice() : [];\n                this.receiveResponse = function (response) {\n                    var contact, expires, contacts = response.getHeaders('contact').length, cause;\n                    // Discard responses to older REGISTER/un-REGISTER requests.\n                    if (response.cseq !== this.cseq) {\n                        return;\n                    }\n                    // Clear registration timer\n                    if (this.registrationTimer !== null) {\n                        SIP.Timers.clearTimeout(this.registrationTimer);\n                        this.registrationTimer = null;\n                    }\n                    switch (true) {\n                        case /^1[0-9]{2}$/.test(response.status_code):\n                            this.emit('progress', response);\n                            break;\n                        case /^2[0-9]{2}$/.test(response.status_code):\n                            this.emit('accepted', response);\n                            if (response.hasHeader('expires')) {\n                                expires = response.getHeader('expires');\n                            }\n                            if (this.registrationExpiredTimer !== null) {\n                                SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n                                this.registrationExpiredTimer = null;\n                            }\n                            // Search the Contact pointing to us and update the expires value accordingly.\n                            if (!contacts) {\n                                this.logger.warn('no Contact header in response to REGISTER, response ignored');\n                                break;\n                            }\n                            while (contacts--) {\n                                contact = response.parseHeader('contact', contacts);\n                                if (contact.uri.user === this.ua.contact.uri.user) {\n                                    expires = contact.getParam('expires');\n                                    break;\n                                }\n                                else {\n                                    contact = null;\n                                }\n                            }\n                            if (!contact) {\n                                this.logger.warn('no Contact header pointing to us, response ignored');\n                                break;\n                            }\n                            if (!expires) {\n                                expires = this.expires;\n                            }\n                            // Re-Register before the expiration interval has elapsed.\n                            // For that, decrease the expires value. ie: 3 seconds\n                            this.registrationTimer = SIP.Timers.setTimeout(function () {\n                                self.registrationTimer = null;\n                                self.register(self.options);\n                            }, (expires * 1000) - 3000);\n                            this.registrationExpiredTimer = SIP.Timers.setTimeout(function () {\n                                self.logger.warn('registration expired');\n                                if (self.registered) {\n                                    self.unregistered(null, SIP.C.causes.EXPIRES);\n                                }\n                            }, expires * 1000);\n                            //Save gruu values\n                            if (contact.hasParam('temp-gruu')) {\n                                this.ua.contact.temp_gruu = SIP.URI.parse(contact.getParam('temp-gruu').replace(/\"/g, ''));\n                            }\n                            if (contact.hasParam('pub-gruu')) {\n                                this.ua.contact.pub_gruu = SIP.URI.parse(contact.getParam('pub-gruu').replace(/\"/g, ''));\n                            }\n                            this.registered = true;\n                            this.emit('registered', response || null);\n                            break;\n                        // Interval too brief RFC3261 10.2.8\n                        case /^423$/.test(response.status_code):\n                            if (response.hasHeader('min-expires')) {\n                                // Increase our registration interval to the suggested minimum\n                                this.expires = response.getHeader('min-expires');\n                                // Attempt the registration again immediately\n                                this.register(this.options);\n                            }\n                            else { //This response MUST contain a Min-Expires header field\n                                this.logger.warn('423 response received for REGISTER without Min-Expires');\n                                this.registrationFailure(response, SIP.C.causes.SIP_FAILURE_CODE);\n                            }\n                            break;\n                        default:\n                            cause = SIP.Utils.sipErrorCause(response.status_code);\n                            this.registrationFailure(response, cause);\n                    }\n                };\n                this.onRequestTimeout = function () {\n                    this.registrationFailure(null, SIP.C.causes.REQUEST_TIMEOUT);\n                };\n                this.onTransportError = function () {\n                    this.registrationFailure(null, SIP.C.causes.CONNECTION_ERROR);\n                };\n                this.cseq++;\n                this.request.cseq = this.cseq;\n                this.request.setHeader('cseq', this.cseq + ' REGISTER');\n                this.request.extraHeaders = extraHeaders;\n                this.send();\n            } },\n        registrationFailure: { writable: true, value: function registrationFailure(response, cause) {\n                this.emit('failed', response || null, cause || null);\n            } },\n        onTransportDisconnected: { writable: true, value: function onTransportDisconnected() {\n                this.registered_before = this.registered;\n                if (this.registrationTimer !== null) {\n                    SIP.Timers.clearTimeout(this.registrationTimer);\n                    this.registrationTimer = null;\n                }\n                if (this.registrationExpiredTimer !== null) {\n                    SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n                    this.registrationExpiredTimer = null;\n                }\n                if (this.registered) {\n                    this.unregistered(null, SIP.C.causes.CONNECTION_ERROR);\n                }\n            } },\n        onTransportConnected: { writable: true, value: function onTransportConnected() {\n                this.register(this.options);\n            } },\n        close: { writable: true, value: function close() {\n                var options = {\n                    all: false,\n                    extraHeaders: this.closeHeaders\n                };\n                this.registered_before = this.registered;\n                if (this.registered) {\n                    this.unregister(options);\n                }\n            } },\n        unregister: { writable: true, value: function unregister(options) {\n                var extraHeaders;\n                options = options || {};\n                if (!this.registered && !options.all) {\n                    this.logger.warn('Already unregistered, but sending an unregister anyways.');\n                }\n                extraHeaders = (options.extraHeaders || []).slice();\n                this.registered = false;\n                // Clear the registration timer.\n                if (this.registrationTimer !== null) {\n                    SIP.Timers.clearTimeout(this.registrationTimer);\n                    this.registrationTimer = null;\n                }\n                if (options.all) {\n                    extraHeaders.push('Contact: *');\n                    extraHeaders.push('Expires: 0');\n                }\n                else {\n                    extraHeaders.push('Contact: ' + this.contact + ';expires=0');\n                }\n                this.receiveResponse = function (response) {\n                    var cause;\n                    switch (true) {\n                        case /^1[0-9]{2}$/.test(response.status_code):\n                            this.emit('progress', response);\n                            break;\n                        case /^2[0-9]{2}$/.test(response.status_code):\n                            this.emit('accepted', response);\n                            if (this.registrationExpiredTimer !== null) {\n                                SIP.Timers.clearTimeout(this.registrationExpiredTimer);\n                                this.registrationExpiredTimer = null;\n                            }\n                            this.unregistered(response);\n                            break;\n                        default:\n                            cause = SIP.Utils.sipErrorCause(response.status_code);\n                            this.unregistered(response, cause);\n                    }\n                };\n                this.onRequestTimeout = function () {\n                    // Not actually unregistered...\n                    //this.unregistered(null, SIP.C.causes.REQUEST_TIMEOUT);\n                };\n                this.cseq++;\n                this.request.cseq = this.cseq;\n                this.request.setHeader('cseq', this.cseq + ' REGISTER');\n                this.request.extraHeaders = extraHeaders;\n                this.send();\n            } },\n        unregistered: { writable: true, value: function unregistered(response, cause) {\n                this.registered = false;\n                this.emit('unregistered', response || null, cause || null);\n            } }\n    });\n    SIP.RegisterContext = RegisterContext;\n};\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/* eslint-disable */\n/**\n * @fileoverview SessionDescriptionHandler\n */\n/* SessionDescriptionHandler\n * @class PeerConnection helper Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n */\nmodule.exports = function (EventEmitter) {\n    var SessionDescriptionHandler = function () { };\n    SessionDescriptionHandler.prototype = Object.create(EventEmitter.prototype, {\n        /**\n         * Destructor\n         */\n        close: { value: function close() { } },\n        /**\n         * Gets the local description from the underlying media implementation\n         * @param {Object} [options] Options object to be used by getDescription\n         * @param {Array} [modifiers] Array with one time use description modifiers\n         * @returns {Promise} Promise that resolves with the local description to be used for the session\n         */\n        getDescription: { value: function getDescription(options, modifiers) { } },\n        /**\n         * Check if the Session Description Handler can handle the Content-Type described by a SIP Message\n         * @param {String} contentType The content type that is in the SIP Message\n         * @returns {boolean}\n         */\n        hasDescription: { value: function hasSessionDescription(contentType) { } },\n        /**\n         * The modifier that should be used when the session would like to place the call on hold\n         * @param {String} [sdp] The description that will be modified\n         * @returns {Promise} Promise that resolves with modified SDP\n         */\n        holdModifier: { value: function holdModifier(sdp) { } },\n        /**\n         * Set the remote description to the underlying media implementation\n         * @param {String} sessionDescription The description provided by a SIP message to be set on the media implementation\n         * @param {Object} [options] Options object to be used by setDescription\n         * @param {Array} [modifiers] Array with one time use description modifiers\n         * @returns {Promise} Promise that resolves once the description is set\n         */\n        setDescription: { value: function setDescription(sessionDescription, options, modifiers) { } },\n        /**\n         * Send DTMF via RTP (RFC 4733)\n         * @param {String} tones A string containing DTMF digits\n         * @param {Object} [options] Options object to be used by sendDtmf\n         * @returns {boolean} true if DTMF send is successful, false otherwise\n         */\n        sendDtmf: { value: function sendDtmf(tones, options) { } },\n        /**\n        * Get the direction of the session description\n        * @returns {String} direction of the description\n        */\n        getDirection: { value: function getDirection() { } },\n    });\n    return SessionDescriptionHandler;\n};\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = function (SIP) {\n    var ClientContext;\n    ClientContext = function (ua, method, target, options) {\n        var originalTarget = target;\n        // Validate arguments\n        if (target === undefined) {\n            throw new TypeError('Not enough arguments');\n        }\n        this.ua = ua;\n        this.logger = ua.getLogger('sip.clientcontext');\n        this.method = method;\n        target = ua.normalizeTarget(target);\n        if (!target) {\n            throw new TypeError('Invalid target: ' + originalTarget);\n        }\n        /* Options\n         * - extraHeaders\n         * - params\n         * - contentType\n         * - body\n         */\n        options = Object.create(options || Object.prototype);\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        // Build the request\n        this.request = new SIP.OutgoingRequest(this.method, target, this.ua, options.params, options.extraHeaders);\n        if (options.body) {\n            this.body = {};\n            this.body.body = options.body;\n            if (options.contentType) {\n                this.body.contentType = options.contentType;\n            }\n            this.request.body = this.body;\n        }\n        /* Set other properties from the request */\n        this.localIdentity = this.request.from;\n        this.remoteIdentity = this.request.to;\n        this.data = {};\n    };\n    ClientContext.prototype = Object.create(SIP.EventEmitter.prototype);\n    ClientContext.prototype.send = function () {\n        (new SIP.RequestSender(this, this.ua)).send();\n        return this;\n    };\n    ClientContext.prototype.cancel = function (options) {\n        options = options || {};\n        options.extraHeaders = (options.extraHeaders || []).slice();\n        var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n        this.request.cancel(cancel_reason, options.extraHeaders);\n        this.emit('cancel');\n    };\n    ClientContext.prototype.receiveResponse = function (response) {\n        var cause = SIP.Utils.getReasonPhrase(response.status_code);\n        switch (true) {\n            case /^1[0-9]{2}$/.test(response.status_code):\n                this.emit('progress', response, cause);\n                break;\n            case /^2[0-9]{2}$/.test(response.status_code):\n                if (this.ua.applicants[this]) {\n                    delete this.ua.applicants[this];\n                }\n                this.emit('accepted', response, cause);\n                break;\n            default:\n                if (this.ua.applicants[this]) {\n                    delete this.ua.applicants[this];\n                }\n                this.emit('rejected', response, cause);\n                this.emit('failed', response, cause);\n                break;\n        }\n    };\n    ClientContext.prototype.onRequestTimeout = function () {\n        this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n    };\n    ClientContext.prototype.onTransportError = function () {\n        this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n    };\n    SIP.ClientContext = ClientContext;\n};\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = function (SIP) {\n    var ServerContext;\n    ServerContext = function (ua, request) {\n        this.ua = ua;\n        this.logger = ua.getLogger('sip.servercontext');\n        this.request = request;\n        if (request.method === SIP.C.INVITE) {\n            this.transaction = new SIP.Transactions.InviteServerTransaction(request, ua);\n        }\n        else {\n            this.transaction = new SIP.Transactions.NonInviteServerTransaction(request, ua);\n        }\n        if (request.body) {\n            this.body = request.body;\n        }\n        if (request.hasHeader('Content-Type')) {\n            this.contentType = request.getHeader('Content-Type');\n        }\n        this.method = request.method;\n        this.data = {};\n        this.localIdentity = request.to;\n        this.remoteIdentity = request.from;\n        if (request.hasHeader('P-Asserted-Identity')) {\n            this.assertedIdentity = new SIP.NameAddrHeader.parse(request.getHeader('P-Asserted-Identity'));\n        }\n    };\n    ServerContext.prototype = Object.create(SIP.EventEmitter.prototype);\n    ServerContext.prototype.progress = function (options) {\n        options = Object.create(options || Object.prototype);\n        options.statusCode || (options.statusCode = 180);\n        options.minCode = 100;\n        options.maxCode = 199;\n        options.events = ['progress'];\n        return this.reply(options);\n    };\n    ServerContext.prototype.accept = function (options) {\n        options = Object.create(options || Object.prototype);\n        options.statusCode || (options.statusCode = 200);\n        options.minCode = 200;\n        options.maxCode = 299;\n        options.events = ['accepted'];\n        return this.reply(options);\n    };\n    ServerContext.prototype.reject = function (options) {\n        options = Object.create(options || Object.prototype);\n        options.statusCode || (options.statusCode = 480);\n        options.minCode = 300;\n        options.maxCode = 699;\n        options.events = ['rejected', 'failed'];\n        return this.reply(options);\n    };\n    ServerContext.prototype.reply = function (options) {\n        options = options || {}; // This is okay, so long as we treat options as read-only in this method\n        var statusCode = options.statusCode || 100, minCode = options.minCode || 100, maxCode = options.maxCode || 699, reasonPhrase = SIP.Utils.getReasonPhrase(statusCode, options.reasonPhrase), extraHeaders = options.extraHeaders || [], body = options.body, events = options.events || [], response;\n        if (statusCode < minCode || statusCode > maxCode) {\n            throw new TypeError('Invalid statusCode: ' + statusCode);\n        }\n        response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n        events.forEach(function (event) {\n            this.emit(event, response, reasonPhrase);\n        }, this);\n        return this;\n    };\n    ServerContext.prototype.onRequestTimeout = function () {\n        this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n    };\n    ServerContext.prototype.onTransportError = function () {\n        this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n    };\n    SIP.ServerContext = ServerContext;\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nmodule.exports = function (SIP) {\n    var DTMF = __webpack_require__(24)(SIP);\n    var Session, InviteServerContext, InviteClientContext, ReferServerContext, ReferClientContext, C = {\n        //Session states\n        STATUS_NULL: 0,\n        STATUS_INVITE_SENT: 1,\n        STATUS_1XX_RECEIVED: 2,\n        STATUS_INVITE_RECEIVED: 3,\n        STATUS_WAITING_FOR_ANSWER: 4,\n        STATUS_ANSWERED: 5,\n        STATUS_WAITING_FOR_PRACK: 6,\n        STATUS_WAITING_FOR_ACK: 7,\n        STATUS_CANCELED: 8,\n        STATUS_TERMINATED: 9,\n        STATUS_ANSWERED_WAITING_FOR_PRACK: 10,\n        STATUS_EARLY_MEDIA: 11,\n        STATUS_CONFIRMED: 12\n    };\n    /*\n     * @param {function returning SIP.sessionDescriptionHandler} [sessionDescriptionHandlerFactory]\n     *        (See the documentation for the sessionDescriptionHandlerFactory argument of the UA constructor.)\n     */\n    Session = function (sessionDescriptionHandlerFactory) {\n        this.status = C.STATUS_NULL;\n        this.dialog = null;\n        this.pendingReinvite = false;\n        this.earlyDialogs = {};\n        if (!sessionDescriptionHandlerFactory) {\n            throw new SIP.Exceptions.SessionDescriptionHandlerMissing('A session description handler is required for the session to function');\n        }\n        this.sessionDescriptionHandlerFactory = sessionDescriptionHandlerFactory;\n        this.hasOffer = false;\n        this.hasAnswer = false;\n        // Session Timers\n        this.timers = {\n            ackTimer: null,\n            expiresTimer: null,\n            invite2xxTimer: null,\n            userNoAnswerTimer: null,\n            rel1xxTimer: null,\n            prackTimer: null\n        };\n        // Session info\n        this.startTime = null;\n        this.endTime = null;\n        this.tones = null;\n        // Hold state\n        this.local_hold = false;\n        this.early_sdp = null;\n        this.rel100 = SIP.C.supported.UNSUPPORTED;\n    };\n    Session.prototype = {\n        dtmf: function (tones, options) {\n            var tone, dtmfs = [], self = this, dtmfType = this.ua.configuration.dtmfType;\n            options = options || {};\n            if (tones === undefined) {\n                throw new TypeError('Not enough arguments');\n            }\n            // Check Session Status\n            if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {\n                throw new SIP.Exceptions.InvalidStateError(this.status);\n            }\n            // Check tones\n            if ((typeof tones !== 'string' && typeof tones !== 'number') || !tones.toString().match(/^[0-9A-D#*,]+$/i)) {\n                throw new TypeError('Invalid tones: ' + tones);\n            }\n            var sendDTMF = function () {\n                var dtmf, timeout;\n                if (self.status === C.STATUS_TERMINATED || !self.tones || self.tones.length === 0) {\n                    // Stop sending DTMF\n                    self.tones = null;\n                    return this;\n                }\n                dtmf = self.tones.shift();\n                if (tone === ',') {\n                    timeout = 2000;\n                }\n                else {\n                    dtmf.on('failed', function () { self.tones = null; });\n                    dtmf.send(options);\n                    timeout = dtmf.duration + dtmf.interToneGap;\n                }\n                // Set timeout for the next tone\n                SIP.Timers.setTimeout(sendDTMF, timeout);\n            };\n            tones = tones.toString();\n            if (dtmfType === SIP.C.dtmfType.RTP) {\n                var sent = this.sessionDescriptionHandler.sendDtmf(tones, options);\n                if (!sent) {\n                    this.logger.warn(\"Attempt to use dtmfType 'RTP' has failed, falling back to INFO packet method\");\n                    dtmfType = SIP.C.dtmfType.INFO;\n                }\n            }\n            if (dtmfType === SIP.C.dtmfType.INFO) {\n                tones = tones.split('');\n                while (tones.length > 0) {\n                    dtmfs.push(new DTMF(this, tones.shift(), options));\n                }\n                if (this.tones) {\n                    // Tones are already queued, just add to the queue\n                    this.tones = this.tones.concat(dtmfs);\n                    return this;\n                }\n                this.tones = dtmfs;\n                sendDTMF();\n            }\n            return this;\n        },\n        bye: function (options) {\n            options = Object.create(options || Object.prototype);\n            var statusCode = options.statusCode;\n            // Check Session Status\n            if (this.status === C.STATUS_TERMINATED) {\n                this.logger.error('Error: Attempted to send BYE in a terminated session.');\n                return this;\n            }\n            this.logger.log('terminating Session');\n            if (statusCode && (statusCode < 200 || statusCode >= 700)) {\n                throw new TypeError('Invalid statusCode: ' + statusCode);\n            }\n            options.receiveResponse = function () { };\n            return this.\n                sendRequest(SIP.C.BYE, options).\n                terminated();\n        },\n        refer: function (target, options) {\n            options = options || {};\n            // Check Session Status\n            if (this.status !== C.STATUS_CONFIRMED) {\n                throw new SIP.Exceptions.InvalidStateError(this.status);\n            }\n            this.referContext = new SIP.ReferClientContext(this.ua, this, target, options);\n            this.emit('referRequested', this.referContext);\n            this.referContext.refer(options);\n        },\n        sendRequest: function (method, options) {\n            options = options || {};\n            var self = this;\n            var request = new SIP.OutgoingRequest(method, this.dialog.remote_target, this.ua, {\n                cseq: options.cseq || (this.dialog.local_seqnum += 1),\n                call_id: this.dialog.id.call_id,\n                from_uri: this.dialog.local_uri,\n                from_tag: this.dialog.id.local_tag,\n                to_uri: this.dialog.remote_uri,\n                to_tag: this.dialog.id.remote_tag,\n                route_set: this.dialog.route_set,\n                statusCode: options.statusCode,\n                reasonPhrase: options.reasonPhrase\n            }, options.extraHeaders || [], options.body);\n            new SIP.RequestSender({\n                request: request,\n                onRequestTimeout: function () {\n                    self.onRequestTimeout();\n                },\n                onTransportError: function () {\n                    self.onTransportError();\n                },\n                receiveResponse: options.receiveResponse || function (response) {\n                    self.receiveNonInviteResponse(response);\n                }\n            }, this.ua).send();\n            // Emit the request event\n            this.emit(method.toLowerCase(), request);\n            return this;\n        },\n        close: function () {\n            var idx;\n            if (this.status === C.STATUS_TERMINATED) {\n                return this;\n            }\n            this.logger.log('closing INVITE session ' + this.id);\n            // 1st Step. Terminate media.\n            if (this.sessionDescriptionHandler) {\n                this.sessionDescriptionHandler.close();\n            }\n            // 2nd Step. Terminate signaling.\n            // Clear session timers\n            for (idx in this.timers) {\n                SIP.Timers.clearTimeout(this.timers[idx]);\n            }\n            // Terminate dialogs\n            // Terminate confirmed dialog\n            if (this.dialog) {\n                this.dialog.terminate();\n                delete this.dialog;\n            }\n            // Terminate early dialogs\n            for (idx in this.earlyDialogs) {\n                this.earlyDialogs[idx].terminate();\n                delete this.earlyDialogs[idx];\n            }\n            this.status = C.STATUS_TERMINATED;\n            this.ua.transport.removeListener(\"transportError\", this.errorListener);\n            delete this.ua.sessions[this.id];\n            return this;\n        },\n        createDialog: function (message, type, early) {\n            var dialog, early_dialog, local_tag = message[(type === 'UAS') ? 'to_tag' : 'from_tag'], remote_tag = message[(type === 'UAS') ? 'from_tag' : 'to_tag'], id = message.call_id + local_tag + remote_tag;\n            early_dialog = this.earlyDialogs[id];\n            // Early Dialog\n            if (early) {\n                if (early_dialog) {\n                    return true;\n                }\n                else {\n                    early_dialog = new SIP.Dialog(this, message, type, SIP.Dialog.C.STATUS_EARLY);\n                    // Dialog has been successfully created.\n                    if (early_dialog.error) {\n                        this.logger.error(early_dialog.error);\n                        this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n                        return false;\n                    }\n                    else {\n                        this.earlyDialogs[id] = early_dialog;\n                        return true;\n                    }\n                }\n            }\n            // Confirmed Dialog\n            else {\n                // In case the dialog is in _early_ state, update it\n                if (early_dialog) {\n                    early_dialog.update(message, type);\n                    this.dialog = early_dialog;\n                    delete this.earlyDialogs[id];\n                    for (var dia in this.earlyDialogs) {\n                        this.earlyDialogs[dia].terminate();\n                        delete this.earlyDialogs[dia];\n                    }\n                    return true;\n                }\n                // Otherwise, create a _confirmed_ dialog\n                dialog = new SIP.Dialog(this, message, type);\n                if (dialog.error) {\n                    this.logger.error(dialog.error);\n                    this.failed(message, SIP.C.causes.INTERNAL_ERROR);\n                    return false;\n                }\n                else {\n                    this.to_tag = message.to_tag;\n                    this.dialog = dialog;\n                    return true;\n                }\n            }\n        },\n        /**\n         * Hold\n         */\n        hold: function (options, modifiers) {\n            if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n                throw new SIP.Exceptions.InvalidStateError(this.status);\n            }\n            if (this.local_hold) {\n                this.logger.log('Session is already on hold, cannot put it on hold again');\n                return;\n            }\n            options = options || {};\n            options.modifiers = modifiers || [];\n            options.modifiers.push(this.sessionDescriptionHandler.holdModifier);\n            this.local_hold = true;\n            this.sendReinvite(options);\n        },\n        /**\n         * Unhold\n         */\n        unhold: function (options, modifiers) {\n            if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {\n                throw new SIP.Exceptions.InvalidStateError(this.status);\n            }\n            if (!this.local_hold) {\n                this.logger.log('Session is not on hold, cannot unhold it');\n                return;\n            }\n            options = options || {};\n            if (modifiers) {\n                options.modifiers = modifiers;\n            }\n            this.local_hold = false;\n            this.sendReinvite(options);\n        },\n        reinvite: function (options, modifiers) {\n            options = options || {};\n            if (modifiers) {\n                options.modifiers = modifiers;\n            }\n            return this.sendReinvite(options);\n        },\n        /**\n         * In dialog INVITE Reception\n         * @private\n         */\n        receiveReinvite: function (request) {\n            var self = this, promise;\n            // TODO: Should probably check state of the session\n            self.emit('reinvite', this);\n            if (request.hasHeader('P-Asserted-Identity')) {\n                this.assertedIdentity = new SIP.NameAddrHeader.parse(request.getHeader('P-Asserted-Identity'));\n            }\n            // Invite w/o SDP\n            if (request.getHeader('Content-Length') === '0' && !request.getHeader('Content-Type')) {\n                promise = this.sessionDescriptionHandler.getDescription(this.sessionDescriptionHandlerOptions, this.modifiers);\n                // Invite w/ SDP\n            }\n            else if (this.sessionDescriptionHandler.hasDescription(request.getHeader('Content-Type'))) {\n                promise = this.sessionDescriptionHandler.setDescription(request.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                    .then(this.sessionDescriptionHandler.getDescription.bind(this.sessionDescriptionHandler, this.sessionDescriptionHandlerOptions, this.modifiers));\n                // Bad Packet (should never get hit)\n            }\n            else {\n                request.reply(415);\n                this.emit('reinviteFailed', self);\n                return;\n            }\n            this.receiveRequest = function (request) {\n                if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n                    if (this.sessionDescriptionHandler.hasDescription(request.getHeader('Content-Type'))) {\n                        this.hasAnswer = true;\n                        this.sessionDescriptionHandler.setDescription(request.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                            .then(function () {\n                            SIP.Timers.clearTimeout(this.timers.ackTimer);\n                            SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n                            this.status = C.STATUS_CONFIRMED;\n                            this.emit('confirmed', request);\n                        }.bind(this));\n                    }\n                    else {\n                        SIP.Timers.clearTimeout(this.timers.ackTimer);\n                        SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n                        this.status = C.STATUS_CONFIRMED;\n                        this.emit('confirmed', request);\n                    }\n                }\n                else {\n                    SIP.Session.prototype.receiveRequest.apply(this, [request]);\n                }\n            }.bind(this);\n            promise.catch(function onFailure(e) {\n                var statusCode;\n                if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                    statusCode = 500;\n                }\n                else if (e instanceof SIP.Exceptions.RenegotiationError) {\n                    self.emit('renegotiationError', e);\n                    self.logger.warn(e);\n                    statusCode = 488;\n                }\n                else {\n                    self.logger.error(e);\n                    statusCode = 488;\n                }\n                request.reply(statusCode);\n                self.emit('reinviteFailed', self);\n                // TODO: This could be better\n                throw e;\n            })\n                .then(function (description) {\n                var extraHeaders = ['Contact: ' + self.contact];\n                request.reply(200, null, extraHeaders, description, function () {\n                    self.status = C.STATUS_WAITING_FOR_ACK;\n                    self.setACKTimer();\n                    self.emit('reinviteAccepted', self);\n                });\n            });\n        },\n        sendReinvite: function (options) {\n            if (this.pendingReinvite) {\n                this.logger.warn('Reinvite in progress. Please wait until complete, then try again.');\n                return;\n            }\n            this.pendingReinvite = true;\n            options = options || {};\n            options.modifiers = options.modifiers || [];\n            var self = this, extraHeaders = (options.extraHeaders || []).slice();\n            extraHeaders.push('Contact: ' + this.contact);\n            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n            this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)\n                .then(function (description) {\n                self.sendRequest(SIP.C.INVITE, {\n                    extraHeaders: extraHeaders,\n                    body: description,\n                    receiveResponse: self.receiveReinviteResponse.bind(self)\n                });\n            }).catch(function onFailure(e) {\n                if (e instanceof SIP.Exceptions.RenegotiationError) {\n                    self.pendingReinvite = false;\n                    self.emit('renegotiationError', e);\n                    self.logger.warn('Renegotiation Error');\n                    self.logger.warn(e);\n                    return;\n                }\n                self.logger.error('sessionDescriptionHandler error');\n                self.logger.error(e);\n            });\n        },\n        receiveRequest: function (request) {\n            switch (request.method) {\n                case SIP.C.BYE:\n                    request.reply(200);\n                    if (this.status === C.STATUS_CONFIRMED) {\n                        this.emit('bye', request);\n                        this.terminated(request, SIP.C.causes.BYE);\n                    }\n                    break;\n                case SIP.C.INVITE:\n                    if (this.status === C.STATUS_CONFIRMED) {\n                        this.logger.log('re-INVITE received');\n                        this.receiveReinvite(request);\n                    }\n                    break;\n                case SIP.C.INFO:\n                    if (this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK) {\n                        if (this.onInfo) {\n                            return this.onInfo(request);\n                        }\n                        var body, tone, duration, contentType = request.getHeader('content-type'), reg_tone = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/, reg_duration = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n                        if (contentType) {\n                            if (contentType.match(/^application\\/dtmf-relay/i)) {\n                                if (request.body) {\n                                    body = request.body.split('\\r\\n', 2);\n                                    if (body.length === 2) {\n                                        if (reg_tone.test(body[0])) {\n                                            tone = body[0].replace(reg_tone, \"$2\");\n                                        }\n                                        if (reg_duration.test(body[1])) {\n                                            duration = parseInt(body[1].replace(reg_duration, \"$2\"), 10);\n                                        }\n                                    }\n                                }\n                                new DTMF(this, tone, { duration: duration }).init_incoming(request);\n                            }\n                            else {\n                                request.reply(415, null, [\"Accept: application/dtmf-relay\"]);\n                            }\n                        }\n                    }\n                    break;\n                case SIP.C.REFER:\n                    if (this.status === C.STATUS_CONFIRMED) {\n                        this.logger.log('REFER received');\n                        this.referContext = new SIP.ReferServerContext(this.ua, request);\n                        var hasReferListener = this.listeners('referRequested').length;\n                        if (hasReferListener) {\n                            this.emit('referRequested', this.referContext);\n                        }\n                        else {\n                            this.logger.log('No referRequested listeners, automatically accepting and following the refer');\n                            var options = { followRefer: true };\n                            if (this.passedOptions) {\n                                options.inviteOptions = this.passedOptions;\n                            }\n                            this.referContext.accept(options, this.modifiers);\n                        }\n                    }\n                    break;\n                case SIP.C.NOTIFY:\n                    if ((this.referContext && this.referContext instanceof SIP.ReferClientContext) && request.hasHeader('event') && /^refer(;.*)?$/.test(request.getHeader('event'))) {\n                        this.referContext.receiveNotify(request);\n                        return;\n                    }\n                    request.reply(200, 'OK');\n                    this.emit('notify', request);\n                    break;\n            }\n        },\n        /**\n         * Reception of Response for in-dialog INVITE\n         * @private\n         */\n        receiveReinviteResponse: function (response) {\n            var self = this;\n            if (this.status === C.STATUS_TERMINATED) {\n                this.logger.error('Received reinvite response, but in STATUS_TERMINATED');\n                // TODO: Do we need to send a SIP response?\n                return;\n            }\n            if (!this.pendingReinvite) {\n                this.logger.error('Received reinvite response, but have no pending reinvite');\n                // TODO: Do we need to send a SIP response?\n                return;\n            }\n            switch (true) {\n                case /^1[0-9]{2}$/.test(response.status_code):\n                    break;\n                case /^2[0-9]{2}$/.test(response.status_code):\n                    this.status = C.STATUS_CONFIRMED;\n                    // 17.1.1.1 - For each final response that is received at the client transaction, the client transaction sends an ACK,\n                    this.emit(\"ack\", response.transaction.sendACK());\n                    this.pendingReinvite = false;\n                    // TODO: All of these timers should move into the Transaction layer\n                    SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n                    if (!this.sessionDescriptionHandler.hasDescription(response.getHeader('Content-Type'))) {\n                        this.logger.error('2XX response received to re-invite but did not have a description');\n                        this.emit('reinviteFailed', self);\n                        this.emit('renegotiationError', new SIP.Exceptions.RenegotiationError('2XX response received to re-invite but did not have a description'));\n                        break;\n                    }\n                    this.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                        .catch(function onFailure(e) {\n                        self.logger.error('Could not set the description in 2XX response');\n                        self.logger.error(e);\n                        self.emit('reinviteFailed', self);\n                        self.emit('renegotiationError', e);\n                        self.sendRequest(SIP.C.BYE, {\n                            extraHeaders: ['Reason: ' + SIP.Utils.getReasonHeaderValue(488, 'Not Acceptable Here')]\n                        });\n                        self.terminated(null, SIP.C.causes.INCOMPATIBLE_SDP);\n                    }).then(function () {\n                        self.emit('reinviteAccepted', self);\n                    });\n                    break;\n                default:\n                    this.pendingReinvite = false;\n                    this.logger.log('Received a non 1XX or 2XX response to a re-invite');\n                    this.emit('reinviteFailed', self);\n                    this.emit('renegotiationError', new SIP.Exceptions.RenegotiationError('Invalid response to a re-invite'));\n            }\n        },\n        acceptAndTerminate: function (response, status_code, reason_phrase) {\n            var extraHeaders = [];\n            if (status_code) {\n                extraHeaders.push('Reason: ' + SIP.Utils.getReasonHeaderValue(status_code, reason_phrase));\n            }\n            // An error on dialog creation will fire 'failed' event\n            if (this.dialog || this.createDialog(response, 'UAC')) {\n                this.emit(\"ack\", response.transaction.sendACK());\n                this.sendRequest(SIP.C.BYE, {\n                    extraHeaders: extraHeaders\n                });\n            }\n            return this;\n        },\n        /**\n         * RFC3261 13.3.1.4\n         * Response retransmissions cannot be accomplished by transaction layer\n         *  since it is destroyed when receiving the first 2xx answer\n         */\n        setInvite2xxTimer: function (request, description) {\n            var self = this, timeout = SIP.Timers.T1;\n            this.timers.invite2xxTimer = SIP.Timers.setTimeout(function invite2xxRetransmission() {\n                if (self.status !== C.STATUS_WAITING_FOR_ACK) {\n                    return;\n                }\n                self.logger.log('no ACK received, attempting to retransmit OK');\n                var extraHeaders = ['Contact: ' + self.contact];\n                request.reply(200, null, extraHeaders, description);\n                timeout = Math.min(timeout * 2, SIP.Timers.T2);\n                self.timers.invite2xxTimer = SIP.Timers.setTimeout(invite2xxRetransmission, timeout);\n            }, timeout);\n        },\n        /**\n         * RFC3261 14.2\n         * If a UAS generates a 2xx response and never receives an ACK,\n         *  it SHOULD generate a BYE to terminate the dialog.\n         */\n        setACKTimer: function () {\n            var self = this;\n            this.timers.ackTimer = SIP.Timers.setTimeout(function () {\n                if (self.status === C.STATUS_WAITING_FOR_ACK) {\n                    self.logger.log('no ACK received for an extended period of time, terminating the call');\n                    SIP.Timers.clearTimeout(self.timers.invite2xxTimer);\n                    self.sendRequest(SIP.C.BYE);\n                    self.terminated(null, SIP.C.causes.NO_ACK);\n                }\n            }, SIP.Timers.TIMER_H);\n        },\n        /*\n         * @private\n         */\n        onTransportError: function () {\n            if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n                this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n            }\n        },\n        onRequestTimeout: function () {\n            if (this.status === C.STATUS_CONFIRMED) {\n                this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n            }\n            else if (this.status !== C.STATUS_TERMINATED) {\n                this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n                this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n            }\n        },\n        onDialogError: function (response) {\n            if (this.status === C.STATUS_CONFIRMED) {\n                this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n            }\n            else if (this.status !== C.STATUS_TERMINATED) {\n                this.failed(response, SIP.C.causes.DIALOG_ERROR);\n                this.terminated(response, SIP.C.causes.DIALOG_ERROR);\n            }\n        },\n        /**\n         * @private\n         */\n        failed: function (response, cause) {\n            if (this.status === C.STATUS_TERMINATED) {\n                return this;\n            }\n            this.emit('failed', response || null, cause || null);\n            return this;\n        },\n        rejected: function (response, cause) {\n            this.emit('rejected', response || null, cause || null);\n            return this;\n        },\n        canceled: function () {\n            if (this.sessionDescriptionHandler) {\n                this.sessionDescriptionHandler.close();\n            }\n            this.emit('cancel');\n            return this;\n        },\n        accepted: function (response, cause) {\n            cause = SIP.Utils.getReasonPhrase(response && response.status_code, cause);\n            this.startTime = new Date();\n            if (this.replacee) {\n                this.replacee.emit('replaced', this);\n                this.replacee.terminate();\n            }\n            this.emit('accepted', response, cause);\n            return this;\n        },\n        terminated: function (message, cause) {\n            if (this.status === C.STATUS_TERMINATED) {\n                return this;\n            }\n            this.endTime = new Date();\n            this.close();\n            this.emit('terminated', message || null, cause || null);\n            return this;\n        },\n        connecting: function (request) {\n            this.emit('connecting', { request: request });\n            return this;\n        }\n    };\n    Session.C = C;\n    SIP.Session = Session;\n    InviteServerContext = function (ua, request) {\n        var expires, self = this, contentType = request.getHeader('Content-Type'), contentDisp = request.parseHeader('Content-Disposition');\n        SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n        SIP.Utils.augment(this, SIP.Session, [ua.configuration.sessionDescriptionHandlerFactory]);\n        if (contentDisp && contentDisp.type === 'render') {\n            this.renderbody = request.body;\n            this.rendertype = contentType;\n        }\n        this.status = C.STATUS_INVITE_RECEIVED;\n        this.from_tag = request.from_tag;\n        this.id = request.call_id + this.from_tag;\n        this.request = request;\n        this.contact = this.ua.contact.toString();\n        this.receiveNonInviteResponse = function () { }; // intentional no-op\n        this.logger = ua.getLogger('sip.inviteservercontext', this.id);\n        //Save the session into the ua sessions collection.\n        this.ua.sessions[this.id] = this;\n        //Get the Expires header value if exists\n        if (request.hasHeader('expires')) {\n            expires = request.getHeader('expires') * 1000;\n        }\n        //Set 100rel if necessary\n        function set100rel(h, c) {\n            if (request.hasHeader(h) && request.getHeader(h).toLowerCase().indexOf('100rel') >= 0) {\n                self.rel100 = c;\n            }\n        }\n        set100rel('require', SIP.C.supported.REQUIRED);\n        set100rel('supported', SIP.C.supported.SUPPORTED);\n        /* Set the to_tag before\n         * replying a response code that will create a dialog.\n         */\n        request.to_tag = SIP.Utils.newTag();\n        // An error on dialog creation will fire 'failed' event\n        if (!this.createDialog(request, 'UAS', true)) {\n            request.reply(500, 'Missing Contact header field');\n            return;\n        }\n        var options = { extraHeaders: ['Contact: ' + self.contact] };\n        if (self.rel100 !== SIP.C.supported.REQUIRED) {\n            self.progress(options);\n        }\n        self.status = C.STATUS_WAITING_FOR_ANSWER;\n        // Set userNoAnswerTimer\n        self.timers.userNoAnswerTimer = SIP.Timers.setTimeout(function () {\n            request.reply(408);\n            self.failed(request, SIP.C.causes.NO_ANSWER);\n            self.terminated(request, SIP.C.causes.NO_ANSWER);\n        }, self.ua.configuration.noAnswerTimeout);\n        /* Set expiresTimer\n         * RFC3261 13.3.1\n         */\n        if (expires) {\n            self.timers.expiresTimer = SIP.Timers.setTimeout(function () {\n                if (self.status === C.STATUS_WAITING_FOR_ANSWER) {\n                    request.reply(487);\n                    self.failed(request, SIP.C.causes.EXPIRES);\n                    self.terminated(request, SIP.C.causes.EXPIRES);\n                }\n            }, expires);\n        }\n        this.errorListener = this.onTransportError.bind(this);\n        ua.transport.on('transportError', this.errorListener);\n    };\n    InviteServerContext.prototype = Object.create({}, {\n        reject: { writable: true, value: function (options) {\n                // Check Session Status\n                if (this.status === C.STATUS_TERMINATED) {\n                    throw new SIP.Exceptions.InvalidStateError(this.status);\n                }\n                this.logger.log('rejecting RTCSession');\n                SIP.ServerContext.prototype.reject.call(this, options);\n                return this.terminated();\n            } },\n        terminate: { writable: true, value: function (options) {\n                options = options || {};\n                var extraHeaders = (options.extraHeaders || []).slice(), body = options.body, dialog, self = this;\n                if (this.status === C.STATUS_WAITING_FOR_ACK &&\n                    this.request.server_transaction.state !== SIP.Transactions.C.STATUS_TERMINATED) {\n                    dialog = this.dialog;\n                    this.receiveRequest = function (request) {\n                        if (request.method === SIP.C.ACK) {\n                            this.sendRequest(SIP.C.BYE, {\n                                extraHeaders: extraHeaders,\n                                body: body\n                            });\n                            dialog.terminate();\n                        }\n                    };\n                    this.request.server_transaction.on('stateChanged', function () {\n                        if (this.state === SIP.Transactions.C.STATUS_TERMINATED && this.dialog) {\n                            this.request = new SIP.OutgoingRequest(SIP.C.BYE, this.dialog.remote_target, this.ua, {\n                                'cseq': this.dialog.local_seqnum += 1,\n                                'call_id': this.dialog.id.call_id,\n                                'from_uri': this.dialog.local_uri,\n                                'from_tag': this.dialog.id.local_tag,\n                                'to_uri': this.dialog.remote_uri,\n                                'to_tag': this.dialog.id.remote_tag,\n                                'route_set': this.dialog.route_set\n                            }, extraHeaders, body);\n                            new SIP.RequestSender({\n                                request: this.request,\n                                onRequestTimeout: function () {\n                                    self.onRequestTimeout();\n                                },\n                                onTransportError: function () {\n                                    self.onTransportError();\n                                },\n                                receiveResponse: function () {\n                                    return;\n                                }\n                            }, this.ua).send();\n                            dialog.terminate();\n                        }\n                    });\n                    this.emit('bye', this.request);\n                    this.terminated();\n                    // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)\n                    this.dialog = dialog;\n                    // Restore the dialog into 'ua' so the ACK can reach 'this' session\n                    this.ua.dialogs[dialog.id.toString()] = dialog;\n                }\n                else if (this.status === C.STATUS_CONFIRMED) {\n                    this.bye(options);\n                }\n                else {\n                    this.reject(options);\n                }\n                return this;\n            } },\n        /*\n         * @param {Object} [options.sessionDescriptionHandlerOptions] gets passed to SIP.SessionDescriptionHandler.getDescription as options\n         */\n        progress: { writable: true, value: function (options) {\n                options = options || {};\n                var statusCode = options.statusCode || 180, reasonPhrase = options.reasonPhrase, extraHeaders = (options.extraHeaders || []).slice(), body = options.body, response;\n                if (statusCode < 100 || statusCode > 199) {\n                    throw new TypeError('Invalid statusCode: ' + statusCode);\n                }\n                if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n                    return this;\n                }\n                function do100rel() {\n                    /* jshint validthis: true */\n                    statusCode = options.statusCode || 183;\n                    // Set status and add extra headers\n                    this.status = C.STATUS_WAITING_FOR_PRACK;\n                    extraHeaders.push('Contact: ' + this.contact);\n                    extraHeaders.push('Require: 100rel');\n                    extraHeaders.push('RSeq: ' + Math.floor(Math.random() * 10000));\n                    // Get the session description to add to preaccept with\n                    this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)\n                        .then(function onSuccess(description) {\n                        if (this.isCanceled || this.status === C.STATUS_TERMINATED) {\n                            return;\n                        }\n                        this.early_sdp = description.body;\n                        this[this.hasOffer ? 'hasAnswer' : 'hasOffer'] = true;\n                        // Retransmit until we get a response or we time out (see prackTimer below)\n                        var timeout = SIP.Timers.T1;\n                        this.timers.rel1xxTimer = SIP.Timers.setTimeout(function rel1xxRetransmission() {\n                            this.request.reply(statusCode, null, extraHeaders, description);\n                            timeout *= 2;\n                            this.timers.rel1xxTimer = SIP.Timers.setTimeout(rel1xxRetransmission.bind(this), timeout);\n                        }.bind(this), timeout);\n                        // Timeout and reject INVITE if no response\n                        this.timers.prackTimer = SIP.Timers.setTimeout(function () {\n                            if (this.status !== C.STATUS_WAITING_FOR_PRACK) {\n                                return;\n                            }\n                            this.logger.log('no PRACK received, rejecting the call');\n                            SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n                            this.request.reply(504);\n                            this.terminated(null, SIP.C.causes.NO_PRACK);\n                        }.bind(this), SIP.Timers.T1 * 64);\n                        // Send the initial response\n                        response = this.request.reply(statusCode, reasonPhrase, extraHeaders, description);\n                        this.emit('progress', response, reasonPhrase);\n                    }.bind(this), function onFailure() {\n                        this.request.reply(480);\n                        this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                        this.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n                    }.bind(this));\n                } // end do100rel\n                function normalReply() {\n                    /* jshint validthis:true */\n                    response = this.request.reply(statusCode, reasonPhrase, extraHeaders, body);\n                    this.emit('progress', response, reasonPhrase);\n                }\n                if (options.statusCode !== 100 &&\n                    (this.rel100 === SIP.C.supported.REQUIRED ||\n                        (this.rel100 === SIP.C.supported.SUPPORTED && options.rel100) ||\n                        (this.rel100 === SIP.C.supported.SUPPORTED && (this.ua.configuration.rel100 === SIP.C.supported.REQUIRED)))) {\n                    this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();\n                    this.emit('SessionDescriptionHandler-created', this.sessionDescriptionHandler);\n                    if (this.sessionDescriptionHandler.hasDescription(this.request.getHeader('Content-Type'))) {\n                        this.hasOffer = true;\n                        this.sessionDescriptionHandler.setDescription(this.request.body, options.sessionDescriptionHandlerOptions, options.modifiers)\n                            .then(do100rel.apply(this))\n                            .catch(function onFailure(e) {\n                            this.logger.warn('invalid description');\n                            this.logger.warn(e);\n                            this.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                            this.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n                        }.bind(this));\n                    }\n                    else {\n                        do100rel.apply(this);\n                    }\n                }\n                else {\n                    normalReply.apply(this);\n                }\n                return this;\n            } },\n        /*\n         * @param {Object} [options.sessionDescriptionHandlerOptions] gets passed to SIP.SessionDescriptionHandler.getDescription as options\n         */\n        accept: { writable: true, value: function (options) {\n                options = options || {};\n                this.onInfo = options.onInfo;\n                var self = this, request = this.request, extraHeaders = (options.extraHeaders || []).slice(), descriptionCreationSucceeded = function (description) {\n                    var response, \n                    // run for reply success callback\n                    replySucceeded = function () {\n                        self.status = C.STATUS_WAITING_FOR_ACK;\n                        self.setInvite2xxTimer(request, description);\n                        self.setACKTimer();\n                    }, \n                    // run for reply failure callback\n                    replyFailed = function () {\n                        self.failed(null, SIP.C.causes.CONNECTION_ERROR);\n                        self.terminated(null, SIP.C.causes.CONNECTION_ERROR);\n                    };\n                    extraHeaders.push('Contact: ' + self.contact);\n                    extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n                    if (!self.hasOffer) {\n                        self.hasOffer = true;\n                    }\n                    else {\n                        self.hasAnswer = true;\n                    }\n                    response = request.reply(200, null, extraHeaders, description, replySucceeded, replyFailed);\n                    if (self.status !== C.STATUS_TERMINATED) { // Didn't fail\n                        self.accepted(response, SIP.Utils.getReasonPhrase(200));\n                    }\n                }, descriptionCreationFailed = function (err) {\n                    if (err instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        self.logger.log(err.message);\n                        self.logger.log(err.error);\n                    }\n                    // TODO: This should check the actual error and make sure it is an\n                    //        \"expected\" error. Otherwise it should throw.\n                    if (self.status === C.STATUS_TERMINATED) {\n                        return;\n                    }\n                    self.request.reply(480);\n                    self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                    self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n                };\n                // Check Session Status\n                if (this.status === C.STATUS_WAITING_FOR_PRACK) {\n                    this.status = C.STATUS_ANSWERED_WAITING_FOR_PRACK;\n                    return this;\n                }\n                else if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n                    this.status = C.STATUS_ANSWERED;\n                }\n                else if (this.status !== C.STATUS_EARLY_MEDIA) {\n                    throw new SIP.Exceptions.InvalidStateError(this.status);\n                }\n                // An error on dialog creation will fire 'failed' event\n                if (!this.createDialog(request, 'UAS')) {\n                    request.reply(500, 'Missing Contact header field');\n                    return this;\n                }\n                SIP.Timers.clearTimeout(this.timers.userNoAnswerTimer);\n                if (this.status === C.STATUS_EARLY_MEDIA) {\n                    descriptionCreationSucceeded({});\n                }\n                else {\n                    this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();\n                    this.emit('SessionDescriptionHandler-created', this.sessionDescriptionHandler);\n                    if (this.request.getHeader('Content-Length') === '0' && !this.request.getHeader('Content-Type')) {\n                        this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers)\n                            .catch(descriptionCreationFailed)\n                            .then(descriptionCreationSucceeded);\n                    }\n                    else if (this.sessionDescriptionHandler.hasDescription(this.request.getHeader('Content-Type'))) {\n                        this.hasOffer = true;\n                        this.sessionDescriptionHandler.setDescription(this.request.body, options.sessionDescriptionHandlerOptions, options.modifiers)\n                            .then(function () {\n                            return this.sessionDescriptionHandler.getDescription(options.sessionDescriptionHandlerOptions, options.modifiers);\n                        }.bind(this))\n                            .catch(descriptionCreationFailed)\n                            .then(descriptionCreationSucceeded);\n                    }\n                    else {\n                        this.request.reply(415);\n                        // TODO: Events\n                        return;\n                    }\n                }\n                return this;\n            } },\n        receiveRequest: { writable: true, value: function (request) {\n                // ISC RECEIVE REQUEST\n                function confirmSession() {\n                    /* jshint validthis:true */\n                    var contentType, contentDisp;\n                    SIP.Timers.clearTimeout(this.timers.ackTimer);\n                    SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n                    this.status = C.STATUS_CONFIRMED;\n                    contentType = request.getHeader('Content-Type');\n                    contentDisp = request.getHeader('Content-Disposition');\n                    if (contentDisp && contentDisp.type === 'render') {\n                        this.renderbody = request.body;\n                        this.rendertype = contentType;\n                    }\n                    this.emit('confirmed', request);\n                }\n                switch (request.method) {\n                    case SIP.C.CANCEL:\n                        /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL\n                         * was in progress and that the UAC MAY continue with the session established by\n                         * any 2xx response, or MAY terminate with BYE. SIP does continue with the\n                         * established session. So the CANCEL is processed only if the session is not yet\n                         * established.\n                         */\n                        /*\n                         * Terminate the whole session in case the user didn't accept (or yet to send the answer) nor reject the\n                         *request opening the session.\n                         */\n                        if (this.status === C.STATUS_WAITING_FOR_ANSWER ||\n                            this.status === C.STATUS_WAITING_FOR_PRACK ||\n                            this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK ||\n                            this.status === C.STATUS_EARLY_MEDIA ||\n                            this.status === C.STATUS_ANSWERED) {\n                            this.status = C.STATUS_CANCELED;\n                            this.request.reply(487);\n                            this.canceled(request);\n                            this.rejected(request, SIP.C.causes.CANCELED);\n                            this.failed(request, SIP.C.causes.CANCELED);\n                            this.terminated(request, SIP.C.causes.CANCELED);\n                        }\n                        break;\n                    case SIP.C.ACK:\n                        if (this.status === C.STATUS_WAITING_FOR_ACK) {\n                            if (this.sessionDescriptionHandler.hasDescription(request.getHeader('Content-Type'))) {\n                                // ACK contains answer to an INVITE w/o SDP negotiation\n                                this.hasAnswer = true;\n                                this.sessionDescriptionHandler.setDescription(request.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                                    .then(\n                                // TODO: Catch then .then\n                                confirmSession.bind(this), function onFailure(e) {\n                                    this.logger.warn(e);\n                                    this.terminate({\n                                        statusCode: '488',\n                                        reasonPhrase: 'Bad Media Description'\n                                    });\n                                    this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                    this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                }.bind(this));\n                            }\n                            else {\n                                confirmSession.apply(this);\n                            }\n                        }\n                        break;\n                    case SIP.C.PRACK:\n                        if (this.status === C.STATUS_WAITING_FOR_PRACK || this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n                            if (!this.hasAnswer) {\n                                this.sessionDescriptionHandler = this.setupSessionDescriptionHandler();\n                                this.emit('SessionDescriptionHandler-created', this.sessionDescriptionHandler);\n                                if (this.sessionDescriptionHandler.hasDescription(request.getHeader('Content-Type'))) {\n                                    this.hasAnswer = true;\n                                    this.sessionDescriptionHandler.setDescription(request.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                                        .then(function onSuccess() {\n                                        SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n                                        SIP.Timers.clearTimeout(this.timers.prackTimer);\n                                        request.reply(200);\n                                        if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n                                            this.status = C.STATUS_EARLY_MEDIA;\n                                            this.accept();\n                                        }\n                                        this.status = C.STATUS_EARLY_MEDIA;\n                                    }.bind(this), function onFailure(e) {\n                                        this.logger.warn(e);\n                                        this.terminate({\n                                            statusCode: '488',\n                                            reasonPhrase: 'Bad Media Description'\n                                        });\n                                        this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                        this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                    }.bind(this));\n                                }\n                                else {\n                                    this.terminate({\n                                        statusCode: '488',\n                                        reasonPhrase: 'Bad Media Description'\n                                    });\n                                    this.failed(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                    this.terminated(request, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                }\n                            }\n                            else {\n                                SIP.Timers.clearTimeout(this.timers.rel1xxTimer);\n                                SIP.Timers.clearTimeout(this.timers.prackTimer);\n                                request.reply(200);\n                                if (this.status === C.STATUS_ANSWERED_WAITING_FOR_PRACK) {\n                                    this.status = C.STATUS_EARLY_MEDIA;\n                                    this.accept();\n                                }\n                                this.status = C.STATUS_EARLY_MEDIA;\n                            }\n                        }\n                        else if (this.status === C.STATUS_EARLY_MEDIA) {\n                            request.reply(200);\n                        }\n                        break;\n                    default:\n                        Session.prototype.receiveRequest.apply(this, [request]);\n                        break;\n                }\n            } },\n        // Internal Function to setup the handler consistently\n        setupSessionDescriptionHandler: { writable: true, value: function () {\n                if (this.sessionDescriptionHandler) {\n                    return this.sessionDescriptionHandler;\n                }\n                return this.sessionDescriptionHandlerFactory(this, this.ua.configuration.sessionDescriptionHandlerFactoryOptions);\n            } },\n        onTransportError: { writable: true, value: function () {\n                if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n                    this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n                }\n            } },\n        onRequestTimeout: { writable: true, value: function () {\n                if (this.status === C.STATUS_CONFIRMED) {\n                    this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n                }\n                else if (this.status !== C.STATUS_TERMINATED) {\n                    this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n                    this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n                }\n            } }\n    });\n    SIP.InviteServerContext = InviteServerContext;\n    InviteClientContext = function (ua, target, options, modifiers) {\n        options = options || {};\n        this.passedOptions = options; // Save for later to use with refer\n        options.params = Object.create(options.params || Object.prototype);\n        var extraHeaders = (options.extraHeaders || []).slice(), sessionDescriptionHandlerFactory = ua.configuration.sessionDescriptionHandlerFactory;\n        this.sessionDescriptionHandlerFactoryOptions = ua.configuration.sessionDescriptionHandlerFactoryOptions || {};\n        this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions || {};\n        this.modifiers = modifiers;\n        this.inviteWithoutSdp = options.inviteWithoutSdp || false;\n        // Set anonymous property\n        this.anonymous = options.anonymous || false;\n        // Custom data to be sent either in INVITE or in ACK\n        this.renderbody = options.renderbody || null;\n        this.rendertype = options.rendertype || 'text/plain';\n        // Session parameter initialization\n        this.from_tag = SIP.Utils.newTag();\n        options.params.from_tag = this.from_tag;\n        /* Do not add ;ob in initial forming dialog requests if the registration over\n         *  the current connection got a GRUU URI.\n         */\n        this.contact = ua.contact.toString({\n            anonymous: this.anonymous,\n            outbound: this.anonymous ? !ua.contact.temp_gruu : !ua.contact.pub_gruu\n        });\n        if (this.anonymous) {\n            options.params.from_displayName = 'Anonymous';\n            options.params.from_uri = 'sip:anonymous@anonymous.invalid';\n            extraHeaders.push('P-Preferred-Identity: ' + ua.configuration.uri.toString());\n            extraHeaders.push('Privacy: id');\n        }\n        extraHeaders.push('Contact: ' + this.contact);\n        extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n        if (this.inviteWithoutSdp && this.renderbody) {\n            extraHeaders.push('Content-Type: ' + this.rendertype);\n            extraHeaders.push('Content-Disposition: render;handling=optional');\n        }\n        if (ua.configuration.rel100 === SIP.C.supported.REQUIRED) {\n            extraHeaders.push('Require: 100rel');\n        }\n        if (ua.configuration.replaces === SIP.C.supported.REQUIRED) {\n            extraHeaders.push('Require: replaces');\n        }\n        options.extraHeaders = extraHeaders;\n        SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.INVITE, target, options]);\n        SIP.Utils.augment(this, SIP.Session, [sessionDescriptionHandlerFactory]);\n        // Check Session Status\n        if (this.status !== C.STATUS_NULL) {\n            throw new SIP.Exceptions.InvalidStateError(this.status);\n        }\n        // OutgoingSession specific parameters\n        this.isCanceled = false;\n        this.received_100 = false;\n        this.method = SIP.C.INVITE;\n        this.receiveNonInviteResponse = this.receiveResponse;\n        this.receiveResponse = this.receiveInviteResponse;\n        this.logger = ua.getLogger('sip.inviteclientcontext');\n        ua.applicants[this] = this;\n        this.id = this.request.call_id + this.from_tag;\n        this.onInfo = options.onInfo;\n        this.errorListener = this.onTransportError.bind(this);\n        ua.transport.on('transportError', this.errorListener);\n    };\n    InviteClientContext.prototype = Object.create({}, {\n        invite: { writable: true, value: function () {\n                var self = this;\n                //Save the session into the ua sessions collection.\n                //Note: placing in constructor breaks call to request.cancel on close... User does not need this anyway\n                this.ua.sessions[this.id] = this;\n                // This should allow the function to return so that listeners can be set up for these events\n                SIP.Utils.Promise.resolve().then(function () {\n                    if (this.inviteWithoutSdp) {\n                        //just send an invite with no sdp...\n                        this.request.body = self.renderbody;\n                        this.status = C.STATUS_INVITE_SENT;\n                        this.send();\n                    }\n                    else {\n                        //Initialize Media Session\n                        this.sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.sessionDescriptionHandlerFactoryOptions);\n                        this.emit('SessionDescriptionHandler-created', this.sessionDescriptionHandler);\n                        this.sessionDescriptionHandler.getDescription(this.sessionDescriptionHandlerOptions, this.modifiers)\n                            .then(function onSuccess(description) {\n                            if (self.isCanceled || self.status === C.STATUS_TERMINATED) {\n                                return;\n                            }\n                            self.hasOffer = true;\n                            self.request.body = description;\n                            self.status = C.STATUS_INVITE_SENT;\n                            self.send();\n                        }, function onFailure(err) {\n                            if (err instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                                self.logger.log(err.message);\n                                self.logger.log(err.error);\n                            }\n                            if (self.status === C.STATUS_TERMINATED) {\n                                return;\n                            }\n                            self.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                            self.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n                        });\n                    }\n                }.bind(this));\n                return this;\n            } },\n        receiveInviteResponse: { writable: true, value: function (response) {\n                var cause, session = this, id = response.call_id + response.from_tag + response.to_tag, extraHeaders = [], options = {};\n                if (this.status === C.STATUS_TERMINATED || response.method !== SIP.C.INVITE) {\n                    return;\n                }\n                if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {\n                    if (id !== this.dialog.id.toString()) {\n                        if (!this.createDialog(response, 'UAC', true)) {\n                            return;\n                        }\n                        this.emit(\"ack\", response.transaction.sendACK({ body: SIP.Utils.generateFakeSDP(response.body) }));\n                        this.earlyDialogs[id].sendRequest(this, SIP.C.BYE);\n                        /* NOTE: This fails because the forking proxy does not recognize that an unanswerable\n                         * leg (due to peerConnection limitations) has been answered first. If your forking\n                         * proxy does not hang up all unanswered branches on the first branch answered, remove this.\n                         */\n                        if (this.status !== C.STATUS_CONFIRMED) {\n                            this.failed(response, SIP.C.causes.WEBRTC_ERROR);\n                            this.terminated(response, SIP.C.causes.WEBRTC_ERROR);\n                        }\n                        return;\n                    }\n                    else if (this.status === C.STATUS_CONFIRMED) {\n                        this.emit(\"ack\", response.transaction.sendACK());\n                        return;\n                    }\n                    else if (!this.hasAnswer) {\n                        // invite w/o sdp is waiting for callback\n                        //an invite with sdp must go on, and hasAnswer is true\n                        return;\n                    }\n                }\n                if (this.dialog && response.status_code < 200) {\n                    /*\n                      Early media has been set up with at least one other different branch,\n                      but a final 2xx response hasn't been received\n                    */\n                    if (this.dialog.pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n                        (this.dialog.pracked[this.dialog.pracked.length - 1] >= response.getHeader('rseq') && this.dialog.pracked.length > 0)) {\n                        return;\n                    }\n                    if (!this.earlyDialogs[id] && !this.createDialog(response, 'UAC', true)) {\n                        return;\n                    }\n                    if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n                        (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length - 1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n                        return;\n                    }\n                    extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                    this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n                    this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n                        extraHeaders: extraHeaders,\n                        body: SIP.Utils.generateFakeSDP(response.body)\n                    });\n                    return;\n                }\n                // Proceed to cancellation if the user requested.\n                if (this.isCanceled) {\n                    if (response.status_code >= 100 && response.status_code < 200) {\n                        this.request.cancel(this.cancelReason, extraHeaders);\n                        this.canceled(null);\n                    }\n                    else if (response.status_code >= 200 && response.status_code < 299) {\n                        this.acceptAndTerminate(response);\n                        this.emit('bye', this.request);\n                    }\n                    else if (response.status_code >= 300) {\n                        cause = SIP.C.REASON_PHRASE[response.status_code] || SIP.C.causes.CANCELED;\n                        this.rejected(response, cause);\n                        this.failed(response, cause);\n                        this.terminated(response, cause);\n                    }\n                    return;\n                }\n                switch (true) {\n                    case /^100$/.test(response.status_code):\n                        this.received_100 = true;\n                        this.emit('progress', response);\n                        break;\n                    case (/^1[0-9]{2}$/.test(response.status_code)):\n                        // Do nothing with 1xx responses without To tag.\n                        if (!response.to_tag) {\n                            this.logger.warn('1xx response received without to tag');\n                            break;\n                        }\n                        // Create Early Dialog if 1XX comes with contact\n                        if (response.hasHeader('contact')) {\n                            // An error on dialog creation will fire 'failed' event\n                            if (!this.createDialog(response, 'UAC', true)) {\n                                break;\n                            }\n                        }\n                        this.status = C.STATUS_1XX_RECEIVED;\n                        if (response.hasHeader('P-Asserted-Identity')) {\n                            this.assertedIdentity = new SIP.NameAddrHeader.parse(response.getHeader('P-Asserted-Identity'));\n                        }\n                        if (response.hasHeader('require') &&\n                            response.getHeader('require').indexOf('100rel') !== -1) {\n                            // Do nothing if this.dialog is already confirmed\n                            if (this.dialog || !this.earlyDialogs[id]) {\n                                break;\n                            }\n                            if (this.earlyDialogs[id].pracked.indexOf(response.getHeader('rseq')) !== -1 ||\n                                (this.earlyDialogs[id].pracked[this.earlyDialogs[id].pracked.length - 1] >= response.getHeader('rseq') && this.earlyDialogs[id].pracked.length > 0)) {\n                                return;\n                            }\n                            // TODO: This may be broken. It may have to be on the early dialog\n                            this.sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.sessionDescriptionHandlerFactoryOptions);\n                            this.emit('SessionDescriptionHandler-created', this.sessionDescriptionHandler);\n                            if (!this.sessionDescriptionHandler.hasDescription(response.getHeader('Content-Type'))) {\n                                extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                                this.earlyDialogs[id].pracked.push(response.getHeader('rseq'));\n                                this.earlyDialogs[id].sendRequest(this, SIP.C.PRACK, {\n                                    extraHeaders: extraHeaders\n                                });\n                                this.emit('progress', response);\n                            }\n                            else if (this.hasOffer) {\n                                if (!this.createDialog(response, 'UAC')) {\n                                    break;\n                                }\n                                this.hasAnswer = true;\n                                this.dialog.pracked.push(response.getHeader('rseq'));\n                                this.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                                    .then(function onSuccess() {\n                                    extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                                    session.sendRequest(SIP.C.PRACK, {\n                                        extraHeaders: extraHeaders,\n                                        receiveResponse: function () { }\n                                    });\n                                    session.status = C.STATUS_EARLY_MEDIA;\n                                    session.emit('progress', response);\n                                }, function onFailure(e) {\n                                    session.logger.warn(e);\n                                    session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                                    session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                });\n                            }\n                            else {\n                                var earlyDialog = this.earlyDialogs[id];\n                                var earlyMedia = earlyDialog.sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.sessionDescriptionHandlerFactoryOptions);\n                                this.emit('SessionDescriptionHandler-created', earlyMedia);\n                                earlyDialog.pracked.push(response.getHeader('rseq'));\n                                earlyMedia.setDescription(response.body, session.sessionDescriptionHandlerOptions, session.modifers)\n                                    .then(earlyMedia.getDescription.bind(earlyMedia, session.sessionDescriptionHandlerOptions, session.modifiers))\n                                    .then(function onSuccess(description) {\n                                    extraHeaders.push('RAck: ' + response.getHeader('rseq') + ' ' + response.getHeader('cseq'));\n                                    earlyDialog.sendRequest(session, SIP.C.PRACK, {\n                                        extraHeaders: extraHeaders,\n                                        body: description\n                                    });\n                                    session.status = C.STATUS_EARLY_MEDIA;\n                                    session.emit('progress', response);\n                                })\n                                    .catch(function onFailure(e) {\n                                    // TODO: This is a bit wonky\n                                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                                        earlyDialog.pracked.push(response.getHeader('rseq'));\n                                        if (session.status === C.STATUS_TERMINATED) {\n                                            return;\n                                        }\n                                        session.failed(null, SIP.C.causes.WEBRTC_ERROR);\n                                        session.terminated(null, SIP.C.causes.WEBRTC_ERROR);\n                                    }\n                                    else {\n                                        earlyDialog.pracked.splice(earlyDialog.pracked.indexOf(response.getHeader('rseq')), 1);\n                                        // Could not set remote description\n                                        session.logger.warn('invalid description');\n                                        session.logger.warn(e);\n                                    }\n                                });\n                            }\n                        }\n                        else {\n                            this.emit('progress', response);\n                        }\n                        break;\n                    case /^2[0-9]{2}$/.test(response.status_code):\n                        var cseq = this.request.cseq + ' ' + this.request.method;\n                        if (cseq !== response.getHeader('cseq')) {\n                            break;\n                        }\n                        if (response.hasHeader('P-Asserted-Identity')) {\n                            this.assertedIdentity = new SIP.NameAddrHeader.parse(response.getHeader('P-Asserted-Identity'));\n                        }\n                        if (this.status === C.STATUS_EARLY_MEDIA && this.dialog) {\n                            this.status = C.STATUS_CONFIRMED;\n                            options = {};\n                            if (this.renderbody) {\n                                extraHeaders.push('Content-Type: ' + this.rendertype);\n                                options.extraHeaders = extraHeaders;\n                                options.body = this.renderbody;\n                            }\n                            this.emit(\"ack\", response.transaction.sendACK(options));\n                            this.accepted(response);\n                            break;\n                        }\n                        // Do nothing if this.dialog is already confirmed\n                        if (this.dialog) {\n                            break;\n                        }\n                        // This is an invite without sdp\n                        if (!this.hasOffer) {\n                            if (this.earlyDialogs[id] && this.earlyDialogs[id].sessionDescriptionHandler) {\n                                //REVISIT\n                                this.hasOffer = true;\n                                this.hasAnswer = true;\n                                this.sessionDescriptionHandler = this.earlyDialogs[id].sessionDescriptionHandler;\n                                if (!this.createDialog(response, 'UAC')) {\n                                    break;\n                                }\n                                this.status = C.STATUS_CONFIRMED;\n                                this.emit(\"ack\", response.transaction.sendACK());\n                                this.accepted(response);\n                            }\n                            else {\n                                this.sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.sessionDescriptionHandlerFactoryOptions);\n                                this.emit('SessionDescriptionHandler-created', this.sessionDescriptionHandler);\n                                if (!this.sessionDescriptionHandler.hasDescription(response.getHeader('Content-Type'))) {\n                                    this.acceptAndTerminate(response, 400, 'Missing session description');\n                                    this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                    break;\n                                }\n                                if (!this.createDialog(response, 'UAC')) {\n                                    break;\n                                }\n                                this.hasOffer = true;\n                                this.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                                    .then(this.sessionDescriptionHandler.getDescription.bind(this.sessionDescriptionHandler, this.sessionDescriptionHandlerOptions, this.modifiers))\n                                    .then(function onSuccess(description) {\n                                    //var localMedia;\n                                    if (session.isCanceled || session.status === C.STATUS_TERMINATED) {\n                                        return;\n                                    }\n                                    session.status = C.STATUS_CONFIRMED;\n                                    session.hasAnswer = true;\n                                    session.emit(\"ack\", response.transaction.sendACK({ body: description }));\n                                    session.accepted(response);\n                                })\n                                    .catch(function onFailure(e) {\n                                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                                        session.logger.warn('invalid description');\n                                        session.logger.warn(e);\n                                        // TODO: This message is inconsistent\n                                        session.acceptAndTerminate(response, 488, 'Invalid session description');\n                                        session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                    }\n                                });\n                            }\n                        }\n                        else if (this.hasAnswer) {\n                            if (this.renderbody) {\n                                extraHeaders.push('Content-Type: ' + session.rendertype);\n                                options.extraHeaders = extraHeaders;\n                                options.body = this.renderbody;\n                            }\n                            this.emit(\"ack\", response.transaction.sendACK(options));\n                        }\n                        else {\n                            if (!this.sessionDescriptionHandler.hasDescription(response.getHeader('Content-Type'))) {\n                                this.acceptAndTerminate(response, 400, 'Missing session description');\n                                this.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                                break;\n                            }\n                            if (!this.createDialog(response, 'UAC')) {\n                                break;\n                            }\n                            this.hasAnswer = true;\n                            this.sessionDescriptionHandler.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.modifiers)\n                                .then(function onSuccess() {\n                                var options = {};\n                                session.status = C.STATUS_CONFIRMED;\n                                if (session.renderbody) {\n                                    extraHeaders.push('Content-Type: ' + session.rendertype);\n                                    options.extraHeaders = extraHeaders;\n                                    options.body = session.renderbody;\n                                }\n                                session.emit(\"ack\", response.transaction.sendACK(options));\n                                session.accepted(response);\n                            }, function onFailure(e) {\n                                session.logger.warn(e);\n                                session.acceptAndTerminate(response, 488, 'Not Acceptable Here');\n                                session.failed(response, SIP.C.causes.BAD_MEDIA_DESCRIPTION);\n                            });\n                        }\n                        break;\n                    default:\n                        cause = SIP.Utils.sipErrorCause(response.status_code);\n                        this.rejected(response, cause);\n                        this.failed(response, cause);\n                        this.terminated(response, cause);\n                }\n            } },\n        cancel: { writable: true, value: function (options) {\n                options = options || {};\n                options.extraHeaders = (options.extraHeaders || []).slice();\n                if (this.isCanceled) {\n                    throw new SIP.Exceptions.InvalidStateError('CANCELED');\n                }\n                // Check Session Status\n                if (this.status === C.STATUS_TERMINATED || this.status === C.STATUS_CONFIRMED) {\n                    throw new SIP.Exceptions.InvalidStateError(this.status);\n                }\n                this.logger.log('canceling RTCSession');\n                this.isCanceled = true;\n                var cancel_reason = SIP.Utils.getCancelReason(options.status_code, options.reason_phrase);\n                // Check Session Status\n                if (this.status === C.STATUS_NULL ||\n                    (this.status === C.STATUS_INVITE_SENT && !this.received_100)) {\n                    this.cancelReason = cancel_reason;\n                }\n                else if (this.status === C.STATUS_INVITE_SENT ||\n                    this.status === C.STATUS_1XX_RECEIVED ||\n                    this.status === C.STATUS_EARLY_MEDIA) {\n                    this.request.cancel(cancel_reason, options.extraHeaders);\n                }\n                return this.canceled();\n            } },\n        terminate: { writable: true, value: function (options) {\n                if (this.status === C.STATUS_TERMINATED) {\n                    return this;\n                }\n                if (this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_CONFIRMED) {\n                    this.bye(options);\n                }\n                else {\n                    this.cancel(options);\n                }\n                return this;\n            } },\n        receiveRequest: { writable: true, value: function (request) {\n                // ICC RECEIVE REQUEST\n                // Reject CANCELs\n                if (request.method === SIP.C.CANCEL) {\n                    // TODO; make this a switch when it gets added\n                }\n                if (request.method === SIP.C.ACK && this.status === C.STATUS_WAITING_FOR_ACK) {\n                    SIP.Timers.clearTimeout(this.timers.ackTimer);\n                    SIP.Timers.clearTimeout(this.timers.invite2xxTimer);\n                    this.status = C.STATUS_CONFIRMED;\n                    this.accepted();\n                }\n                return Session.prototype.receiveRequest.apply(this, [request]);\n            } },\n        onTransportError: { writable: true, value: function () {\n                if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_TERMINATED) {\n                    this.failed(null, SIP.C.causes.CONNECTION_ERROR);\n                }\n            } },\n        onRequestTimeout: { writable: true, value: function () {\n                if (this.status === C.STATUS_CONFIRMED) {\n                    this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n                }\n                else if (this.status !== C.STATUS_TERMINATED) {\n                    this.failed(null, SIP.C.causes.REQUEST_TIMEOUT);\n                    this.terminated(null, SIP.C.causes.REQUEST_TIMEOUT);\n                }\n            } }\n    });\n    SIP.InviteClientContext = InviteClientContext;\n    ReferClientContext = function (ua, applicant, target, options) {\n        this.options = options || {};\n        this.extraHeaders = (this.options.extraHeaders || []).slice();\n        if (ua === undefined || applicant === undefined || target === undefined) {\n            throw new TypeError('Not enough arguments');\n        }\n        SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.REFER, applicant.remoteIdentity.uri.toString(), options]);\n        this.applicant = applicant;\n        var withReplaces = target instanceof SIP.InviteServerContext ||\n            target instanceof SIP.InviteClientContext;\n        if (withReplaces) {\n            // Attended Transfer\n            // All of these fields should be defined based on the check above\n            this.target = '\"' + target.remoteIdentity.friendlyName + '\" ' +\n                '<' + target.dialog.remote_target.toString() +\n                '?Replaces=' + target.dialog.id.call_id +\n                '%3Bto-tag%3D' + target.dialog.id.remote_tag +\n                '%3Bfrom-tag%3D' + target.dialog.id.local_tag + '>';\n        }\n        else {\n            // Blind Transfer\n            // Refer-To: <sip:bob@example.com>\n            try {\n                this.target = SIP.Grammar.parse(target, 'Refer_To').uri || target;\n            }\n            catch (e) {\n                this.logger.debug(\".refer() cannot parse Refer_To from\", target);\n                this.logger.debug(\"...falling through to normalizeTarget()\");\n            }\n            // Check target validity\n            this.target = this.ua.normalizeTarget(this.target);\n            if (!this.target) {\n                throw new TypeError('Invalid target: ' + target);\n            }\n        }\n        if (this.ua) {\n            this.extraHeaders.push('Referred-By: <' + this.ua.configuration.uri + '>');\n        }\n        // TODO: Check that this is correct isc/icc\n        this.extraHeaders.push('Contact: ' + applicant.contact);\n        this.extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n        this.extraHeaders.push('Refer-To: ' + this.target);\n        this.errorListener = this.onTransportError.bind(this);\n        ua.transport.on('transportError', this.errorListener);\n    };\n    ReferClientContext.prototype = Object.create({}, {\n        refer: { writable: true, value: function (options) {\n                options = options || {};\n                var extraHeaders = (this.extraHeaders || []).slice();\n                if (options.extraHeaders) {\n                    extraHeaders.concat(options.extraHeaders);\n                }\n                this.applicant.sendRequest(SIP.C.REFER, {\n                    extraHeaders: this.extraHeaders,\n                    receiveResponse: function (response) {\n                        if (/^1[0-9]{2}$/.test(response.status_code)) {\n                            this.emit('referRequestProgress', this);\n                        }\n                        else if (/^2[0-9]{2}$/.test(response.status_code)) {\n                            this.emit('referRequestAccepted', this);\n                        }\n                        else if (/^[4-6][0-9]{2}$/.test(response.status_code)) {\n                            this.emit('referRequestRejected', this);\n                        }\n                        if (options.receiveResponse) {\n                            options.receiveResponse(response);\n                        }\n                    }.bind(this)\n                });\n                return this;\n            } },\n        receiveNotify: { writable: true, value: function (request) {\n                // If we can correctly handle this, then we need to send a 200 OK!\n                if (request.hasHeader('Content-Type') && request.getHeader('Content-Type').search(/^message\\/sipfrag/) !== -1) {\n                    var messageBody = SIP.Grammar.parse(request.body, 'sipfrag');\n                    if (messageBody === -1) {\n                        request.reply(489, 'Bad Event');\n                        return;\n                    }\n                    switch (true) {\n                        case (/^1[0-9]{2}$/.test(messageBody.status_code)):\n                            this.emit('referProgress', this);\n                            break;\n                        case (/^2[0-9]{2}$/.test(messageBody.status_code)):\n                            this.emit('referAccepted', this);\n                            if (!this.options.activeAfterTransfer && this.applicant.terminate) {\n                                this.applicant.terminate();\n                            }\n                            break;\n                        default:\n                            this.emit('referRejected', this);\n                            break;\n                    }\n                    request.reply(200);\n                    this.emit('notify', request);\n                    return;\n                }\n                request.reply(489, 'Bad Event');\n            } }\n    });\n    SIP.ReferClientContext = ReferClientContext;\n    ReferServerContext = function (ua, request) {\n        SIP.Utils.augment(this, SIP.ServerContext, [ua, request]);\n        this.ua = ua;\n        this.status = C.STATUS_INVITE_RECEIVED;\n        this.from_tag = request.from_tag;\n        this.id = request.call_id + this.from_tag;\n        this.request = request;\n        this.contact = this.ua.contact.toString();\n        this.logger = ua.getLogger('sip.referservercontext', this.id);\n        // RFC 3515 2.4.1\n        if (!this.request.hasHeader('refer-to')) {\n            this.logger.warn('Invalid REFER packet. A refer-to header is required. Rejecting refer.');\n            this.reject();\n            return;\n        }\n        this.referTo = this.request.parseHeader('refer-to');\n        // TODO: Must set expiration timer and send 202 if there is no response by then\n        this.referredSession = this.ua.findSession(request);\n        // Needed to send the NOTIFY's\n        this.cseq = Math.floor(Math.random() * 10000);\n        this.call_id = this.request.call_id;\n        this.from_uri = this.request.to.uri;\n        this.from_tag = this.request.to.parameters.tag;\n        this.remote_target = this.request.headers.Contact[0].parsed.uri;\n        this.to_uri = this.request.from.uri;\n        this.to_tag = this.request.from_tag;\n        this.route_set = this.request.getHeaders('record-route');\n        this.receiveNonInviteResponse = function () { };\n        if (this.request.hasHeader('referred-by')) {\n            this.referredBy = this.request.getHeader('referred-by');\n        }\n        if (this.referTo.uri.hasHeader('replaces')) {\n            this.replaces = this.referTo.uri.getHeader('replaces');\n        }\n        this.errorListener = this.onTransportError.bind(this);\n        ua.transport.on('transportError', this.errorListener);\n        this.status = C.STATUS_WAITING_FOR_ANSWER;\n    };\n    ReferServerContext.prototype = Object.create({}, {\n        progress: { writable: true, value: function () {\n                if (this.status !== C.STATUS_WAITING_FOR_ANSWER) {\n                    throw new SIP.Exceptions.InvalidStateError(this.status);\n                }\n                this.request.reply(100);\n            } },\n        reject: { writable: true, value: function (options) {\n                if (this.status === C.STATUS_TERMINATED) {\n                    throw new SIP.Exceptions.InvalidStateError(this.status);\n                }\n                this.logger.log('Rejecting refer');\n                this.status = C.STATUS_TERMINATED;\n                SIP.ServerContext.prototype.reject.call(this, options);\n                this.emit('referRequestRejected', this);\n            } },\n        accept: { writable: true, value: function (options, modifiers) {\n                options = options || {};\n                if (this.status === C.STATUS_WAITING_FOR_ANSWER) {\n                    this.status = C.STATUS_ANSWERED;\n                }\n                else {\n                    throw new SIP.Exceptions.InvalidStateError(this.status);\n                }\n                this.request.reply(202, 'Accepted');\n                this.emit('referRequestAccepted', this);\n                if (options.followRefer) {\n                    this.logger.log('Accepted refer, attempting to automatically follow it');\n                    var target = this.referTo.uri;\n                    if (!target.scheme.match(\"^sips?$\")) {\n                        this.logger.error('SIP.js can only automatically follow SIP refer target');\n                        this.reject();\n                        return;\n                    }\n                    var inviteOptions = options.inviteOptions || {};\n                    var extraHeaders = (inviteOptions.extraHeaders || []).slice();\n                    if (this.replaces) {\n                        // decodeURIComponent is a holdover from 2c086eb4. Not sure that it is actually necessary\n                        extraHeaders.push('Replaces: ' + decodeURIComponent(this.replaces));\n                    }\n                    if (this.referredBy) {\n                        extraHeaders.push('Referred-By: ' + this.referredBy);\n                    }\n                    inviteOptions.extraHeaders = extraHeaders;\n                    target.clearHeaders();\n                    this.targetSession = this.ua.invite(target, inviteOptions, modifiers);\n                    this.emit('referInviteSent', this);\n                    this.targetSession.once('progress', function () {\n                        this.sendNotify('SIP/2.0 100 Trying');\n                        this.emit('referProgress', this);\n                        if (this.referredSession) {\n                            this.referredSession.emit('referProgress', this);\n                        }\n                    }.bind(this));\n                    this.targetSession.once('accepted', function () {\n                        this.logger.log('Successfully followed the refer');\n                        this.sendNotify('SIP/2.0 200 OK');\n                        this.emit('referAccepted', this);\n                        if (this.referredSession) {\n                            this.referredSession.emit('referAccepted', this);\n                        }\n                    }.bind(this));\n                    var referFailed = function (response) {\n                        if (this.status === C.STATUS_TERMINATED) {\n                            return; // No throw here because it is possible this gets called multiple times\n                        }\n                        this.logger.log('Refer was not successful. Resuming session');\n                        if (response && response.status_code === 429) {\n                            this.logger.log('Alerting referrer that identity is required.');\n                            this.sendNotify('SIP/2.0 429 Provide Referrer Identity');\n                            return;\n                        }\n                        this.sendNotify('SIP/2.0 603 Declined');\n                        // Must change the status after sending the final Notify or it will not send due to check\n                        this.status = C.STATUS_TERMINATED;\n                        this.emit('referRejected', this);\n                        if (this.referredSession) {\n                            this.referredSession.emit('referRejected');\n                        }\n                    };\n                    this.targetSession.once('rejected', referFailed.bind(this));\n                    this.targetSession.once('failed', referFailed.bind(this));\n                }\n                else {\n                    this.logger.log('Accepted refer, but did not automatically follow it');\n                    this.sendNotify('SIP/2.0 200 OK');\n                    this.emit('referAccepted', this);\n                    if (this.referredSession) {\n                        this.referredSession.emit('referAccepted', this);\n                    }\n                }\n            } },\n        sendNotify: { writable: true, value: function (body) {\n                if (this.status !== C.STATUS_ANSWERED) {\n                    throw new SIP.Exceptions.InvalidStateError(this.status);\n                }\n                if (SIP.Grammar.parse(body, 'sipfrag') === -1) {\n                    throw new Error('sipfrag body is required to send notify for refer');\n                }\n                var request = new SIP.OutgoingRequest(SIP.C.NOTIFY, this.remote_target, this.ua, {\n                    cseq: this.cseq += 1,\n                    call_id: this.call_id,\n                    from_uri: this.from_uri,\n                    from_tag: this.from_tag,\n                    to_uri: this.to_uri,\n                    to_tag: this.to_tag,\n                    route_set: this.route_set\n                }, [\n                    'Event: refer',\n                    'Subscription-State: terminated',\n                    'Content-Type: message/sipfrag'\n                ], body);\n                new SIP.RequestSender({\n                    request: request,\n                    onRequestTimeout: function () {\n                        return;\n                    },\n                    onTransportError: function () {\n                        return;\n                    },\n                    receiveResponse: function () {\n                        return;\n                    }\n                }, this.ua).send();\n            } }\n    });\n    SIP.ReferServerContext = ReferServerContext;\n};\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview DTMF\n */\n/**\n * @class DTMF\n * @param {SIP.Session} session\n */\nmodule.exports = function (SIP) {\n    var DTMF, C = {\n        MIN_DURATION: 70,\n        MAX_DURATION: 6000,\n        DEFAULT_DURATION: 100,\n        MIN_INTER_TONE_GAP: 50,\n        DEFAULT_INTER_TONE_GAP: 500\n    };\n    DTMF = function (session, tone, options) {\n        var duration, interToneGap;\n        if (tone === undefined) {\n            throw new TypeError('Not enough arguments');\n        }\n        this.logger = session.ua.getLogger('sip.invitecontext.dtmf', session.id);\n        this.owner = session;\n        this.direction = null;\n        options = options || {};\n        duration = options.duration || null;\n        interToneGap = options.interToneGap || null;\n        // Check tone type\n        if (typeof tone === 'string') {\n            tone = tone.toUpperCase();\n        }\n        else if (typeof tone === 'number') {\n            tone = tone.toString();\n        }\n        else {\n            throw new TypeError('Invalid tone: ' + tone);\n        }\n        // Check tone value\n        if (!tone.match(/^[0-9A-D#*]$/)) {\n            throw new TypeError('Invalid tone: ' + tone);\n        }\n        else {\n            this.tone = tone;\n        }\n        // Check duration\n        if (duration && !SIP.Utils.isDecimal(duration)) {\n            throw new TypeError('Invalid tone duration: ' + duration);\n        }\n        else if (!duration) {\n            duration = DTMF.C.DEFAULT_DURATION;\n        }\n        else if (duration < DTMF.C.MIN_DURATION) {\n            this.logger.warn('\"duration\" value is lower than the minimum allowed, setting it to ' + DTMF.C.MIN_DURATION + ' milliseconds');\n            duration = DTMF.C.MIN_DURATION;\n        }\n        else if (duration > DTMF.C.MAX_DURATION) {\n            this.logger.warn('\"duration\" value is greater than the maximum allowed, setting it to ' + DTMF.C.MAX_DURATION + ' milliseconds');\n            duration = DTMF.C.MAX_DURATION;\n        }\n        else {\n            duration = Math.abs(duration);\n        }\n        this.duration = duration;\n        // Check interToneGap\n        if (interToneGap && !SIP.Utils.isDecimal(interToneGap)) {\n            throw new TypeError('Invalid interToneGap: ' + interToneGap);\n        }\n        else if (!interToneGap) {\n            interToneGap = DTMF.C.DEFAULT_INTER_TONE_GAP;\n        }\n        else if (interToneGap < DTMF.C.MIN_INTER_TONE_GAP) {\n            this.logger.warn('\"interToneGap\" value is lower than the minimum allowed, setting it to ' + DTMF.C.MIN_INTER_TONE_GAP + ' milliseconds');\n            interToneGap = DTMF.C.MIN_INTER_TONE_GAP;\n        }\n        else {\n            interToneGap = Math.abs(interToneGap);\n        }\n        this.interToneGap = interToneGap;\n    };\n    DTMF.prototype = Object.create(SIP.EventEmitter.prototype);\n    DTMF.prototype.send = function (options) {\n        var extraHeaders, body = {};\n        this.direction = 'outgoing';\n        // Check RTCSession Status\n        if (this.owner.status !== SIP.Session.C.STATUS_CONFIRMED &&\n            this.owner.status !== SIP.Session.C.STATUS_WAITING_FOR_ACK) {\n            throw new SIP.Exceptions.InvalidStateError(this.owner.status);\n        }\n        // Get DTMF options\n        options = options || {};\n        extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];\n        body.contentType = 'application/dtmf-relay';\n        body.body = \"Signal= \" + this.tone + \"\\r\\n\";\n        body.body += \"Duration= \" + this.duration;\n        this.request = this.owner.dialog.sendRequest(this, SIP.C.INFO, {\n            extraHeaders: extraHeaders,\n            body: body\n        });\n        this.owner.emit('dtmf', this.request, this);\n    };\n    /**\n     * @private\n     */\n    DTMF.prototype.receiveResponse = function (response) {\n        var cause;\n        switch (true) {\n            case /^1[0-9]{2}$/.test(response.status_code):\n                // Ignore provisional responses.\n                break;\n            case /^2[0-9]{2}$/.test(response.status_code):\n                this.emit('succeeded', {\n                    originator: 'remote',\n                    response: response\n                });\n                break;\n            default:\n                cause = SIP.Utils.sipErrorCause(response.status_code);\n                this.emit('failed', response, cause);\n                break;\n        }\n    };\n    /**\n     * @private\n     */\n    DTMF.prototype.onRequestTimeout = function () {\n        this.emit('failed', null, SIP.C.causes.REQUEST_TIMEOUT);\n        this.owner.onRequestTimeout();\n    };\n    /**\n     * @private\n     */\n    DTMF.prototype.onTransportError = function () {\n        this.emit('failed', null, SIP.C.causes.CONNECTION_ERROR);\n        this.owner.onTransportError();\n    };\n    /**\n     * @private\n     */\n    DTMF.prototype.onDialogError = function (response) {\n        this.emit('failed', response, SIP.C.causes.DIALOG_ERROR);\n        this.owner.onDialogError(response);\n    };\n    /**\n     * @private\n     */\n    DTMF.prototype.init_incoming = function (request) {\n        this.direction = 'incoming';\n        this.request = request;\n        request.reply(200);\n        if (!this.tone || !this.duration) {\n            this.logger.warn('invalid INFO DTMF received, discarded');\n        }\n        else {\n            this.owner.emit('dtmf', request, this);\n        }\n    };\n    DTMF.C = C;\n    return DTMF;\n};\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP Subscriber (SIP-Specific Event Notifications RFC6665)\n */\n/**\n * @augments SIP\n * @class Class creating a SIP Subscription.\n */\nmodule.exports = function (SIP) {\n    SIP.Subscription = function (ua, target, event, options) {\n        options = Object.create(options || Object.prototype);\n        this.extraHeaders = options.extraHeaders = (options.extraHeaders || []).slice();\n        this.id = null;\n        this.state = 'init';\n        if (!event) {\n            throw new TypeError('Event necessary to create a subscription.');\n        }\n        else {\n            //TODO: check for valid events here probably make a list in SIP.C; or leave it up to app to check?\n            //The check may need to/should probably occur on the other side,\n            this.event = event;\n        }\n        if (typeof options.expires !== 'number') {\n            ua.logger.warn('expires must be a number. Using default of 3600.');\n            this.expires = 3600;\n        }\n        else {\n            this.expires = options.expires;\n        }\n        this.requestedExpires = this.expires;\n        options.extraHeaders.push('Event: ' + this.event);\n        options.extraHeaders.push('Expires: ' + this.expires);\n        if (options.body) {\n            this.body = options.body;\n        }\n        this.contact = ua.contact.toString();\n        options.extraHeaders.push('Contact: ' + this.contact);\n        options.extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n        SIP.Utils.augment(this, SIP.ClientContext, [ua, SIP.C.SUBSCRIBE, target, options]);\n        this.logger = ua.getLogger('sip.subscription');\n        this.dialog = null;\n        this.timers = { N: null, sub_duration: null };\n        this.errorCodes = [404, 405, 410, 416, 480, 481, 482, 483, 484, 485, 489, 501, 604];\n    };\n    SIP.Subscription.prototype = {\n        subscribe: function () {\n            var sub = this;\n            //these states point to an existing subscription, no subscribe is necessary\n            if (this.state === 'active') {\n                this.refresh();\n                return this;\n            }\n            else if (this.state === 'notify_wait') {\n                return this;\n            }\n            SIP.Timers.clearTimeout(this.timers.sub_duration);\n            SIP.Timers.clearTimeout(this.timers.N);\n            this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n            this.ua.earlySubscriptions[this.request.call_id + this.request.from.parameters.tag + this.event] = this;\n            this.send();\n            this.state = 'notify_wait';\n            return this;\n        },\n        refresh: function () {\n            if (this.state === 'terminated' || this.state === 'pending' || this.state === 'notify_wait') {\n                return;\n            }\n            this.dialog.sendRequest(this, SIP.C.SUBSCRIBE, {\n                extraHeaders: this.extraHeaders,\n                body: this.body\n            });\n        },\n        receiveResponse: function (response) {\n            var expires, sub = this, cause = SIP.Utils.getReasonPhrase(response.status_code);\n            if ((this.state === 'notify_wait' && response.status_code >= 300) ||\n                (this.state !== 'notify_wait' && this.errorCodes.indexOf(response.status_code) !== -1)) {\n                this.failed(response, null);\n            }\n            else if (/^2[0-9]{2}$/.test(response.status_code)) {\n                this.emit('accepted', response, cause);\n                //As we don't support RFC 5839 or other extensions where the NOTIFY is optional, timer N will not be cleared\n                //SIP.Timers.clearTimeout(this.timers.N);\n                expires = response.getHeader('Expires');\n                if (expires && expires <= this.requestedExpires) {\n                    // Preserve new expires value for subsequent requests\n                    this.expires = expires;\n                    this.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), expires * 900);\n                }\n                else {\n                    if (!expires) {\n                        this.logger.warn('Expires header missing in a 200-class response to SUBSCRIBE');\n                        this.failed(response, SIP.C.EXPIRES_HEADER_MISSING);\n                    }\n                    else {\n                        this.logger.warn('Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request');\n                        this.failed(response, SIP.C.INVALID_EXPIRES_HEADER);\n                    }\n                }\n            }\n            else if (response.statusCode > 300) {\n                this.emit('failed', response, cause);\n                this.emit('rejected', response, cause);\n            }\n        },\n        unsubscribe: function () {\n            var extraHeaders = [], sub = this;\n            this.state = 'terminated';\n            extraHeaders.push('Event: ' + this.event);\n            extraHeaders.push('Expires: 0');\n            extraHeaders.push('Contact: ' + this.contact);\n            extraHeaders.push('Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString());\n            //makes sure expires isn't set, and other typical resubscribe behavior\n            this.receiveResponse = function () { };\n            this.dialog.sendRequest(this, this.method, {\n                extraHeaders: extraHeaders,\n                body: this.body\n            });\n            SIP.Timers.clearTimeout(this.timers.sub_duration);\n            SIP.Timers.clearTimeout(this.timers.N);\n            this.timers.N = SIP.Timers.setTimeout(sub.timer_fire.bind(sub), SIP.Timers.TIMER_N);\n        },\n        /**\n        * @private\n        */\n        timer_fire: function () {\n            if (this.state === 'terminated') {\n                this.terminateDialog();\n                SIP.Timers.clearTimeout(this.timers.N);\n                SIP.Timers.clearTimeout(this.timers.sub_duration);\n                delete this.ua.subscriptions[this.id];\n            }\n            else if (this.state === 'notify_wait' || this.state === 'pending') {\n                this.close();\n            }\n            else {\n                this.refresh();\n            }\n        },\n        /**\n        * @private\n        */\n        close: function () {\n            if (this.state === 'notify_wait') {\n                this.state = 'terminated';\n                SIP.Timers.clearTimeout(this.timers.N);\n                SIP.Timers.clearTimeout(this.timers.sub_duration);\n                this.receiveResponse = function () { };\n                delete this.ua.earlySubscriptions[this.request.call_id + this.request.from.parameters.tag + this.event];\n            }\n            else if (this.state !== 'terminated') {\n                this.unsubscribe();\n            }\n        },\n        /**\n        * @private\n        */\n        createConfirmedDialog: function (message, type) {\n            var dialog;\n            this.terminateDialog();\n            dialog = new SIP.Dialog(this, message, type);\n            dialog.invite_seqnum = this.request.cseq;\n            dialog.local_seqnum = this.request.cseq;\n            if (!dialog.error) {\n                this.dialog = dialog;\n                return true;\n            }\n            // Dialog not created due to an error\n            else {\n                return false;\n            }\n        },\n        /**\n        * @private\n        */\n        terminateDialog: function () {\n            if (this.dialog) {\n                delete this.ua.subscriptions[this.id];\n                this.dialog.terminate();\n                delete this.dialog;\n            }\n        },\n        /**\n        * @private\n        */\n        receiveRequest: function (request) {\n            var sub_state, sub = this;\n            function setExpiresTimeout() {\n                if (sub_state.expires) {\n                    SIP.Timers.clearTimeout(sub.timers.sub_duration);\n                    sub_state.expires = Math.min(sub.expires, Math.max(sub_state.expires, 0));\n                    sub.timers.sub_duration = SIP.Timers.setTimeout(sub.refresh.bind(sub), sub_state.expires * 900);\n                }\n            }\n            if (!this.matchEvent(request)) { //checks event and subscription_state headers\n                request.reply(489);\n                return;\n            }\n            if (!this.dialog) {\n                if (this.createConfirmedDialog(request, 'UAS')) {\n                    this.id = this.dialog.id.toString();\n                    delete this.ua.earlySubscriptions[this.request.call_id + this.request.from.parameters.tag + this.event];\n                    this.ua.subscriptions[this.id] = this;\n                    // UPDATE ROUTE SET TO BE BACKWARDS COMPATIBLE?\n                }\n            }\n            sub_state = request.parseHeader('Subscription-State');\n            request.reply(200, SIP.C.REASON_200);\n            SIP.Timers.clearTimeout(this.timers.N);\n            this.emit('notify', { request: request });\n            // if we've set state to terminated, no further processing should take place\n            // and we are only interested in cleaning up after the appropriate NOTIFY\n            if (this.state === 'terminated') {\n                if (sub_state.state === 'terminated') {\n                    this.terminateDialog();\n                    SIP.Timers.clearTimeout(this.timers.N);\n                    SIP.Timers.clearTimeout(this.timers.sub_duration);\n                    delete this.ua.subscriptions[this.id];\n                }\n                return;\n            }\n            switch (sub_state.state) {\n                case 'active':\n                    this.state = 'active';\n                    setExpiresTimeout();\n                    break;\n                case 'pending':\n                    if (this.state === 'notify_wait') {\n                        setExpiresTimeout();\n                    }\n                    this.state = 'pending';\n                    break;\n                case 'terminated':\n                    SIP.Timers.clearTimeout(this.timers.sub_duration);\n                    if (sub_state.reason) {\n                        this.logger.log('terminating subscription with reason ' + sub_state.reason);\n                        switch (sub_state.reason) {\n                            case 'deactivated':\n                            case 'timeout':\n                                this.subscribe();\n                                return;\n                            case 'probation':\n                            case 'giveup':\n                                if (sub_state.params && sub_state.params['retry-after']) {\n                                    this.timers.sub_duration = SIP.Timers.setTimeout(sub.subscribe.bind(sub), sub_state.params['retry-after']);\n                                }\n                                else {\n                                    this.subscribe();\n                                }\n                                return;\n                            case 'rejected':\n                            case 'noresource':\n                            case 'invariant':\n                                break;\n                        }\n                    }\n                    this.close();\n                    break;\n            }\n        },\n        failed: function (response, cause) {\n            this.close();\n            this.emit('failed', response, cause);\n            this.emit('rejected', response, cause);\n            return this;\n        },\n        onDialogError: function (response) {\n            this.failed(response, SIP.C.causes.DIALOG_ERROR);\n        },\n        /**\n        * @private\n        */\n        matchEvent: function (request) {\n            var event;\n            // Check mandatory header Event\n            if (!request.hasHeader('Event')) {\n                this.logger.warn('missing Event header');\n                return false;\n            }\n            // Check mandatory header Subscription-State\n            if (!request.hasHeader('Subscription-State')) {\n                this.logger.warn('missing Subscription-State header');\n                return false;\n            }\n            // Check whether the event in NOTIFY matches the event in SUBSCRIBE\n            event = request.parseHeader('event').event;\n            if (this.event !== event) {\n                this.logger.warn('event match failed');\n                request.reply(481, 'Event Match Failed');\n                return false;\n            }\n            else {\n                return true;\n            }\n        }\n    };\n};\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SIP Publish (SIP Extension for Event State Publication RFC3903)\n */\n/**\n * @augments SIP\n * @class Class creating a SIP PublishContext.\n */\nmodule.exports = function (SIP) {\n    var PublishContext;\n    PublishContext = function (ua, target, event, options) {\n        this.options = options = (options || {});\n        this.options.extraHeaders = (options.extraHeaders || []).slice();\n        this.options.contentType = (options.contentType || 'text/plain');\n        if (typeof options.expires !== 'number' || (options.expires % 1) !== 0) {\n            this.options.expires = 3600;\n        }\n        else {\n            this.options.expires = Number(options.expires);\n        }\n        if (typeof (options.unpublishOnClose) !== \"boolean\") {\n            this.options.unpublishOnClose = true;\n        }\n        else {\n            this.options.unpublishOnClose = options.unpublishOnClose;\n        }\n        if (target === undefined || target === null || target === '') {\n            throw new SIP.Exceptions.MethodParameterError('Publish', 'Target', target);\n        }\n        else {\n            this.target = ua.normalizeTarget(target);\n        }\n        if (event === undefined || event === null || event === '') {\n            throw new SIP.Exceptions.MethodParameterError('Publish', 'Event', event);\n        }\n        else {\n            this.event = event;\n        }\n        // Call parent constructor\n        SIP.ClientContext.call(this, ua, SIP.C.PUBLISH, this.target, this.options);\n        this.logger = this.ua.getLogger('sip.publish');\n        this.pubRequestBody = null;\n        this.pubRequestExpires = this.options.expires;\n        this.pubRequestEtag = null;\n        this.publish_refresh_timer = null;\n        ua.on('transportCreated', function (transport) {\n            transport.on('transportError', this.onTransportError.bind(this));\n        }.bind(this));\n    };\n    // Extend ClientContext\n    PublishContext.prototype = Object.create(SIP.ClientContext.prototype);\n    // Restore the class constructor\n    PublishContext.prototype.constructor = PublishContext;\n    /**\n     * Publish\n     *\n     * @param {string} Event body to publish, optional\n     *\n     */\n    PublishContext.prototype.publish = function (body) {\n        // Clean up before the run\n        this.request = null;\n        SIP.Timers.clearTimeout(this.publish_refresh_timer);\n        if (body !== undefined && body !== null && body !== '') {\n            // is Inital or Modify request\n            this.options.body = body;\n            this.pubRequestBody = this.options.body;\n            if (this.pubRequestExpires === 0) {\n                // This is Initial request after unpublish\n                this.pubRequestExpires = this.options.expires;\n                this.pubRequestEtag = null;\n            }\n            if (!(this.ua.publishers[this.target.toString() + ':' + this.event])) {\n                this.ua.publishers[this.target.toString() + ':' + this.event] = this;\n            }\n        }\n        else {\n            // This is Refresh request\n            this.pubRequestBody = null;\n            if (this.pubRequestEtag === null) {\n                //Request not valid\n                throw new SIP.Exceptions.MethodParameterError('Publish', 'Body', body);\n            }\n            if (this.pubRequestExpires === 0) {\n                //Request not valid\n                throw new SIP.Exceptions.MethodParameterError('Publish', 'Expire', this.pubRequestExpires);\n            }\n        }\n        this.sendPublishRequest();\n    };\n    /**\n     * Unpublish\n     *\n     */\n    PublishContext.prototype.unpublish = function () {\n        // Clean up before the run\n        this.request = null;\n        SIP.Timers.clearTimeout(this.publish_refresh_timer);\n        this.pubRequestBody = null;\n        this.pubRequestExpires = 0;\n        if (this.pubRequestEtag !== null) {\n            this.sendPublishRequest();\n        }\n    };\n    /**\n     * Close\n     *\n     */\n    PublishContext.prototype.close = function () {\n        // Send unpublish, if requested\n        if (this.options.unpublishOnClose) {\n            this.unpublish();\n        }\n        else {\n            this.request = null;\n            SIP.Timers.clearTimeout(this.publish_refresh_timer);\n            this.pubRequestBody = null;\n            this.pubRequestExpires = 0;\n            this.pubRequestEtag = null;\n        }\n        if (this.ua.publishers[this.target.toString() + ':' + this.event]) {\n            delete this.ua.publishers[this.target.toString() + ':' + this.event];\n        }\n    };\n    /**\n     * @private\n     *\n     */\n    PublishContext.prototype.sendPublishRequest = function () {\n        var reqOptions;\n        reqOptions = Object.create(this.options || Object.prototype);\n        reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();\n        reqOptions.extraHeaders.push('Event: ' + this.event);\n        reqOptions.extraHeaders.push('Expires: ' + this.pubRequestExpires);\n        if (this.pubRequestEtag !== null) {\n            reqOptions.extraHeaders.push('SIP-If-Match: ' + this.pubRequestEtag);\n        }\n        this.request = new SIP.OutgoingRequest(SIP.C.PUBLISH, this.target, this.ua, this.options.params, reqOptions.extraHeaders);\n        if (this.pubRequestBody !== null) {\n            this.request.body = {};\n            this.request.body.body = this.pubRequestBody;\n            this.request.body.contentType = this.options.contentType;\n        }\n        this.send();\n    };\n    /**\n     * @private\n     *\n     */\n    PublishContext.prototype.receiveResponse = function (response) {\n        var expires, minExpires, cause = SIP.Utils.getReasonPhrase(response.status_code);\n        switch (true) {\n            case /^1[0-9]{2}$/.test(response.status_code):\n                this.emit('progress', response, cause);\n                break;\n            case /^2[0-9]{2}$/.test(response.status_code):\n                // Set SIP-Etag\n                if (response.hasHeader('SIP-ETag')) {\n                    this.pubRequestEtag = response.getHeader('SIP-ETag');\n                }\n                else {\n                    this.logger.warn('SIP-ETag header missing in a 200-class response to PUBLISH');\n                }\n                // Update Expire\n                if (response.hasHeader('Expires')) {\n                    expires = Number(response.getHeader('Expires'));\n                    if (typeof expires === 'number' && expires >= 0 && expires <= this.pubRequestExpires) {\n                        this.pubRequestExpires = expires;\n                    }\n                    else {\n                        this.logger.warn('Bad Expires header in a 200-class response to PUBLISH');\n                    }\n                }\n                else {\n                    this.logger.warn('Expires header missing in a 200-class response to PUBLISH');\n                }\n                if (this.pubRequestExpires !== 0) {\n                    // Schedule refresh\n                    this.publish_refresh_timer = SIP.Timers.setTimeout(this.publish.bind(this), this.pubRequestExpires * 900);\n                    this.emit('published', response, cause);\n                }\n                else {\n                    this.emit('unpublished', response, cause);\n                }\n                break;\n            case /^412$/.test(response.status_code):\n                // 412 code means no matching ETag - possibly the PUBLISH expired\n                // Resubmit as new request, if the current request is not a \"remove\"\n                if (this.pubRequestEtag !== null && this.pubRequestExpires !== 0) {\n                    this.logger.warn('412 response to PUBLISH, recovering');\n                    this.pubRequestEtag = null;\n                    this.emit('progress', response, cause);\n                    this.publish(this.options.body);\n                }\n                else {\n                    this.logger.warn('412 response to PUBLISH, recovery failed');\n                    this.pubRequestExpires = 0;\n                    this.emit('failed', response, cause);\n                    this.emit('unpublished', response, cause);\n                }\n                break;\n            case /^423$/.test(response.status_code):\n                // 423 code means we need to adjust the Expires interval up\n                if (this.pubRequestExpires !== 0 && response.hasHeader('Min-Expires')) {\n                    minExpires = Number(response.getHeader('Min-Expires'));\n                    if (typeof minExpires === 'number' || minExpires > this.pubRequestExpires) {\n                        this.logger.warn('423 code in response to PUBLISH, adjusting the Expires value and trying to recover');\n                        this.pubRequestExpires = minExpires;\n                        this.emit('progress', response, cause);\n                        this.publish(this.options.body);\n                    }\n                    else {\n                        this.logger.warn('Bad 423 response Min-Expires header received for PUBLISH');\n                        this.pubRequestExpires = 0;\n                        this.emit('failed', response, cause);\n                        this.emit('unpublished', response, cause);\n                    }\n                }\n                else {\n                    this.logger.warn('423 response to PUBLISH, recovery failed');\n                    this.pubRequestExpires = 0;\n                    this.emit('failed', response, cause);\n                    this.emit('unpublished', response, cause);\n                }\n                break;\n            default:\n                this.pubRequestExpires = 0;\n                this.emit('failed', response, cause);\n                this.emit('unpublished', response, cause);\n                break;\n        }\n        // Do the cleanup\n        if (this.pubRequestExpires === 0) {\n            SIP.Timers.clearTimeout(this.publish_refresh_timer);\n            this.pubRequestBody = null;\n            this.pubRequestEtag = null;\n        }\n    };\n    PublishContext.prototype.onRequestTimeout = function () {\n        SIP.ClientContext.prototype.onRequestTimeout.call(this);\n        this.emit('unpublished', null, SIP.C.causes.REQUEST_TIMEOUT);\n    };\n    PublishContext.prototype.onTransportError = function () {\n        SIP.ClientContext.prototype.onTransportError.call(this);\n        this.emit('unpublished', null, SIP.C.causes.CONNECTION_ERROR);\n    };\n    SIP.PublishContext = PublishContext;\n};\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * @augments SIP\n * @class Class creating a SIP User Agent.\n * @param {function returning SIP.sessionDescriptionHandler} [configuration.sessionDescriptionHandlerFactory]\n *        A function will be invoked by each of the UA's Sessions to build the sessionDescriptionHandler for that Session.\n *        If no (or a falsy) value is provided, each Session will use a default (WebRTC) sessionDescriptionHandler.\n *\n * @param {Object} [configuration.media] gets passed to SIP.sessionDescriptionHandler.getDescription as mediaHint\n */\nmodule.exports = function (SIP, environment) {\n    var UA, C = {\n        // UA status codes\n        STATUS_INIT: 0,\n        STATUS_STARTING: 1,\n        STATUS_READY: 2,\n        STATUS_USER_CLOSED: 3,\n        STATUS_NOT_READY: 4,\n        // UA error codes\n        CONFIGURATION_ERROR: 1,\n        NETWORK_ERROR: 2,\n        ALLOWED_METHODS: [\n            'ACK',\n            'CANCEL',\n            'INVITE',\n            'MESSAGE',\n            'BYE',\n            'OPTIONS',\n            'INFO',\n            'NOTIFY',\n            'REFER'\n        ],\n        ACCEPTED_BODY_TYPES: [\n            'application/sdp',\n            'application/dtmf-relay'\n        ],\n        MAX_FORWARDS: 70,\n        TAG_LENGTH: 10\n    };\n    UA = function (configuration) {\n        var self = this;\n        // Helper function for forwarding events\n        function selfEmit(type) {\n            //registrationFailed handler is invoked with two arguments. Allow event handlers to be invoked with a variable no. of arguments\n            return self.emit.bind(self, type);\n        }\n        // Set Accepted Body Types\n        C.ACCEPTED_BODY_TYPES = C.ACCEPTED_BODY_TYPES.toString();\n        this.log = new SIP.LoggerFactory();\n        this.logger = this.getLogger('sip.ua');\n        this.cache = {\n            credentials: {}\n        };\n        this.configuration = {};\n        this.dialogs = {};\n        //User actions outside any session/dialog (MESSAGE)\n        this.applicants = {};\n        this.data = {};\n        this.sessions = {};\n        this.subscriptions = {};\n        this.earlySubscriptions = {};\n        this.publishers = {};\n        this.transport = null;\n        this.contact = null;\n        this.status = C.STATUS_INIT;\n        this.error = null;\n        this.transactions = {\n            nist: {},\n            nict: {},\n            ist: {},\n            ict: {}\n        };\n        Object.defineProperties(this, {\n            transactionsCount: {\n                get: function () {\n                    var type, transactions = ['nist', 'nict', 'ist', 'ict'], count = 0;\n                    for (type in transactions) {\n                        count += Object.keys(this.transactions[transactions[type]]).length;\n                    }\n                    return count;\n                }\n            },\n            nictTransactionsCount: {\n                get: function () {\n                    return Object.keys(this.transactions['nict']).length;\n                }\n            },\n            nistTransactionsCount: {\n                get: function () {\n                    return Object.keys(this.transactions['nist']).length;\n                }\n            },\n            ictTransactionsCount: {\n                get: function () {\n                    return Object.keys(this.transactions['ict']).length;\n                }\n            },\n            istTransactionsCount: {\n                get: function () {\n                    return Object.keys(this.transactions['ist']).length;\n                }\n            }\n        });\n        /**\n         * Load configuration\n         *\n         * @throws {SIP.Exceptions.ConfigurationError}\n         * @throws {TypeError}\n         */\n        if (configuration === undefined) {\n            configuration = {};\n        }\n        else if (typeof configuration === 'string' || configuration instanceof String) {\n            configuration = {\n                uri: configuration\n            };\n        }\n        // Apply log configuration if present\n        if (configuration.log) {\n            if (configuration.log.hasOwnProperty('builtinEnabled')) {\n                this.log.builtinEnabled = configuration.log.builtinEnabled;\n            }\n            if (configuration.log.hasOwnProperty('level')) {\n                this.log.level = configuration.log.level;\n            }\n            if (configuration.log.hasOwnProperty('connector')) {\n                this.log.connector = configuration.log.connector;\n            }\n        }\n        try {\n            this.loadConfig(configuration);\n        }\n        catch (e) {\n            this.status = C.STATUS_NOT_READY;\n            this.error = C.CONFIGURATION_ERROR;\n            throw e;\n        }\n        // Initialize registerContext\n        this.registerContext = new SIP.RegisterContext(this);\n        this.registerContext.on('failed', selfEmit('registrationFailed'));\n        this.registerContext.on('registered', selfEmit('registered'));\n        this.registerContext.on('unregistered', selfEmit('unregistered'));\n        if (this.configuration.autostart) {\n            this.start();\n        }\n    };\n    UA.prototype = Object.create(SIP.EventEmitter.prototype);\n    //=================\n    //  High Level API\n    //=================\n    UA.prototype.register = function (options) {\n        this.configuration.register = true;\n        this.registerContext.register(options);\n        return this;\n    };\n    /**\n     * Unregister.\n     *\n     * @param {Boolean} [all] unregister all user bindings.\n     *\n     */\n    UA.prototype.unregister = function (options) {\n        this.configuration.register = false;\n        var context = this.registerContext;\n        this.transport.afterConnected(context.unregister.bind(context, options));\n        return this;\n    };\n    UA.prototype.isRegistered = function () {\n        return this.registerContext.registered;\n    };\n    /**\n     * Make an outgoing call.\n     *\n     * @param {String} target\n     * @param {Object} views\n     * @param {Object} [options.media] gets passed to SIP.sessionDescriptionHandler.getDescription as mediaHint\n     *\n     * @throws {TypeError}\n     *\n     */\n    UA.prototype.invite = function (target, options, modifiers) {\n        var context = new SIP.InviteClientContext(this, target, options, modifiers);\n        // Delay sending actual invite until the next 'tick' if we are already\n        // connected, so that API consumers can register to events fired by the\n        // the session.\n        this.transport.afterConnected(function () {\n            context.invite();\n            this.emit('inviteSent', context);\n        }.bind(this));\n        return context;\n    };\n    UA.prototype.subscribe = function (target, event, options) {\n        var sub = new SIP.Subscription(this, target, event, options);\n        this.transport.afterConnected(sub.subscribe.bind(sub));\n        return sub;\n    };\n    /**\n     * Send PUBLISH Event State Publication (RFC3903)\n     *\n     * @param {String} target\n     * @param {String} event\n     * @param {String} body\n     * @param {Object} [options]\n     *\n     * @throws {SIP.Exceptions.MethodParameterError}\n     *\n     */\n    UA.prototype.publish = function (target, event, body, options) {\n        var pub = new SIP.PublishContext(this, target, event, options);\n        this.transport.afterConnected(pub.publish.bind(pub, body));\n        return pub;\n    };\n    /**\n     * Send a message.\n     *\n     * @param {String} target\n     * @param {String} body\n     * @param {Object} [options]\n     *\n     * @throws {TypeError}\n     *\n     */\n    UA.prototype.message = function (target, body, options) {\n        if (body === undefined) {\n            throw new TypeError('Not enough arguments');\n        }\n        // There is no Message module, so it is okay that the UA handles defaults here.\n        options = Object.create(options || Object.prototype);\n        options.contentType || (options.contentType = 'text/plain');\n        options.body = body;\n        return this.request(SIP.C.MESSAGE, target, options);\n    };\n    UA.prototype.request = function (method, target, options) {\n        var req = new SIP.ClientContext(this, method, target, options);\n        this.transport.afterConnected(req.send.bind(req));\n        return req;\n    };\n    /**\n     * Gracefully close.\n     *\n     */\n    UA.prototype.stop = function () {\n        var session, subscription, applicant, publisher, ua = this;\n        function transactionsListener() {\n            if (ua.nistTransactionsCount === 0 && ua.nictTransactionsCount === 0) {\n                ua.removeListener('transactionDestroyed', transactionsListener);\n                ua.transport.disconnect();\n            }\n        }\n        this.logger.log('user requested closure...');\n        if (this.status === C.STATUS_USER_CLOSED) {\n            this.logger.warn('UA already closed');\n            return this;\n        }\n        // Close registerContext\n        this.logger.log('closing registerContext');\n        this.registerContext.close();\n        // Run  _terminate_ on every Session\n        for (session in this.sessions) {\n            this.logger.log('closing session ' + session);\n            this.sessions[session].terminate();\n        }\n        //Run _close_ on every confirmed Subscription\n        for (subscription in this.subscriptions) {\n            this.logger.log('unsubscribing from subscription ' + subscription);\n            this.subscriptions[subscription].close();\n        }\n        //Run _close_ on every early Subscription\n        for (subscription in this.earlySubscriptions) {\n            this.logger.log('unsubscribing from early subscription ' + subscription);\n            this.earlySubscriptions[subscription].close();\n        }\n        //Run _close_ on every Publisher\n        for (publisher in this.publishers) {\n            this.logger.log('unpublish ' + publisher);\n            this.publishers[publisher].close();\n        }\n        // Run  _close_ on every applicant\n        for (applicant in this.applicants) {\n            this.applicants[applicant].close();\n        }\n        this.status = C.STATUS_USER_CLOSED;\n        /*\n         * If the remaining transactions are all INVITE transactions, there is no need to\n         * wait anymore because every session has already been closed by this method.\n         * - locally originated sessions where terminated (CANCEL or BYE)\n         * - remotely originated sessions where rejected (4XX) or terminated (BYE)\n         * Remaining INVITE transactions belong tho sessions that where answered. This are in\n         * 'accepted' state due to timers 'L' and 'M' defined in [RFC 6026]\n         */\n        if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0) {\n            this.transport.disconnect();\n        }\n        else {\n            this.on('transactionDestroyed', transactionsListener);\n        }\n        if (typeof environment.removeEventListener === 'function') {\n            // Google Chrome Packaged Apps don't allow 'unload' listeners:\n            // unload is not available in packaged apps\n            if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {\n                environment.removeEventListener('unload', this.environListener);\n            }\n        }\n        return this;\n    };\n    /**\n     * Connect to the WS server if status = STATUS_INIT.\n     * Resume UA after being closed.\n     *\n     */\n    UA.prototype.start = function () {\n        // var server;\n        this.logger.log('user requested startup...');\n        if (this.status === C.STATUS_INIT) {\n            this.status = C.STATUS_STARTING;\n            if (!this.configuration.transportConstructor) {\n                throw new SIP.Exceptions.TransportError(\"Transport constructor not set\");\n            }\n            this.transport = new this.configuration.transportConstructor(this.getLogger('sip.transport'), this.configuration.transportOptions);\n            this.setTransportListeners();\n            this.emit('transportCreated', this.transport);\n            this.transport.connect();\n        }\n        else if (this.status === C.STATUS_USER_CLOSED) {\n            this.logger.log('resuming');\n            this.status = C.STATUS_READY;\n            this.transport.connect();\n        }\n        else if (this.status === C.STATUS_STARTING) {\n            this.logger.log('UA is in STARTING status, not opening new connection');\n        }\n        else if (this.status === C.STATUS_READY) {\n            this.logger.log('UA is in READY status, not resuming');\n        }\n        else {\n            this.logger.error('Connection is down. Auto-Recovery system is trying to connect');\n        }\n        if (this.configuration.autostop && typeof environment.addEventListener === 'function') {\n            // Google Chrome Packaged Apps don't allow 'unload' listeners:\n            // unload is not available in packaged apps\n            if (!(global.chrome && global.chrome.app && global.chrome.app.runtime)) {\n                this.environListener = this.stop.bind(this);\n                environment.addEventListener('unload', this.environListener);\n            }\n        }\n        return this;\n    };\n    /**\n     * Normalize a string into a valid SIP request URI\n     *\n     * @param {String} target\n     *\n     * @returns {SIP.URI|undefined}\n     */\n    UA.prototype.normalizeTarget = function (target) {\n        return SIP.Utils.normalizeTarget(target, this.configuration.hostportParams);\n    };\n    //===============================\n    //  Private (For internal use)\n    //===============================\n    UA.prototype.saveCredentials = function (credentials) {\n        this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};\n        this.cache.credentials[credentials.realm][credentials.uri] = credentials;\n        return this;\n    };\n    UA.prototype.getCredentials = function (request) {\n        var realm, credentials;\n        realm = request.ruri.host;\n        if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {\n            credentials = this.cache.credentials[realm][request.ruri];\n            credentials.method = request.method;\n        }\n        return credentials;\n    };\n    UA.prototype.getLogger = function (category, label) {\n        return this.log.getLogger(category, label);\n    };\n    //==============================\n    // Event Handlers\n    //==============================\n    UA.prototype.onTransportError = function () {\n        if (this.status === C.STATUS_USER_CLOSED) {\n            return;\n        }\n        if (!this.error || this.error !== C.NETWORK_ERROR) {\n            this.status = C.STATUS_NOT_READY;\n            this.error = C.NETWORK_ERROR;\n        }\n    };\n    /**\n     * Helper function. Sets transport listeners\n     * @private\n     */\n    UA.prototype.setTransportListeners = function () {\n        this.transport.on('connected', this.onTransportConnected.bind(this));\n        this.transport.on('message', this.onTransportReceiveMsg.bind(this));\n        this.transport.on('transportError', this.onTransportError.bind(this));\n    };\n    /**\n     * Transport connection event.\n     * @private\n     * @event\n     * @param {SIP.Transport} transport.\n     */\n    UA.prototype.onTransportConnected = function () {\n        if (this.configuration.register) {\n            this.configuration.authenticationFactory.initialize().then(function () {\n                this.registerContext.onTransportConnected();\n            }.bind(this));\n        }\n    };\n    /**\n     * Transport message receipt event.\n     * @private\n     * @event\n     * @param {String} message\n     */\n    UA.prototype.onTransportReceiveMsg = function (message) {\n        var transaction;\n        message = SIP.Parser.parseMessage(message, this);\n        if (this.status === SIP.UA.C.STATUS_USER_CLOSED && message instanceof SIP.IncomingRequest) {\n            this.logger.warn('UA received message when status = USER_CLOSED - aborting');\n            return;\n        }\n        // Do some sanity check\n        if (SIP.sanityCheck(message, this, this.transport)) {\n            if (message instanceof SIP.IncomingRequest) {\n                message.transport = this.transport;\n                this.receiveRequest(message);\n            }\n            else if (message instanceof SIP.IncomingResponse) {\n                /* Unike stated in 18.1.2, if a response does not match\n                * any transaction, it is discarded here and no passed to the core\n                * in order to be discarded there.\n                */\n                switch (message.method) {\n                    case SIP.C.INVITE:\n                        transaction = this.transactions.ict[message.via_branch];\n                        if (transaction) {\n                            transaction.receiveResponse(message);\n                        }\n                        break;\n                    case SIP.C.ACK:\n                        // Just in case ;-)\n                        break;\n                    default:\n                        transaction = this.transactions.nict[message.via_branch];\n                        if (transaction) {\n                            transaction.receiveResponse(message);\n                        }\n                        break;\n                }\n            }\n        }\n    };\n    /**\n     * new Transaction\n     * @private\n     * @param {SIP.Transaction} transaction.\n     */\n    UA.prototype.newTransaction = function (transaction) {\n        this.transactions[transaction.type][transaction.id] = transaction;\n        this.emit('newTransaction', { transaction: transaction });\n    };\n    /**\n     * destroy Transaction\n     * @private\n     * @param {SIP.Transaction} transaction.\n     */\n    UA.prototype.destroyTransaction = function (transaction) {\n        delete this.transactions[transaction.type][transaction.id];\n        this.emit('transactionDestroyed', {\n            transaction: transaction\n        });\n    };\n    //=========================\n    // receiveRequest\n    //=========================\n    /**\n     * Request reception\n     * @private\n     * @param {SIP.IncomingRequest} request.\n     */\n    UA.prototype.receiveRequest = function (request) {\n        var dialog, session, message, earlySubscription, method = request.method, replaces, replacedDialog, self = this;\n        function ruriMatches(uri) {\n            return uri && uri.user === request.ruri.user;\n        }\n        // Check that request URI points to us\n        if (!(ruriMatches(this.configuration.uri) ||\n            ruriMatches(this.contact.uri) ||\n            ruriMatches(this.contact.pub_gruu) ||\n            ruriMatches(this.contact.temp_gruu))) {\n            this.logger.warn('Request-URI does not point to us');\n            if (request.method !== SIP.C.ACK) {\n                request.reply_sl(404);\n            }\n            return;\n        }\n        // Check request URI scheme\n        if (request.ruri.scheme === SIP.C.SIPS) {\n            request.reply_sl(416);\n            return;\n        }\n        // Check transaction\n        if (SIP.Transactions.checkTransaction(this, request)) {\n            return;\n        }\n        /* RFC3261 12.2.2\n         * Requests that do not change in any way the state of a dialog may be\n         * received within a dialog (for example, an OPTIONS request).\n         * They are processed as if they had been received outside the dialog.\n         */\n        if (method === SIP.C.OPTIONS) {\n            new SIP.Transactions.NonInviteServerTransaction(request, this);\n            request.reply(200, null, [\n                'Allow: ' + SIP.UA.C.ALLOWED_METHODS.toString(),\n                'Accept: ' + C.ACCEPTED_BODY_TYPES\n            ]);\n        }\n        else if (method === SIP.C.MESSAGE) {\n            message = new SIP.ServerContext(this, request);\n            message.body = request.body;\n            message.content_type = request.getHeader('Content-Type') || 'text/plain';\n            request.reply(200, null);\n            this.emit('message', message);\n        }\n        else if (method !== SIP.C.INVITE &&\n            method !== SIP.C.ACK) {\n            // Let those methods pass through to normal processing for now.\n            new SIP.ServerContext(this, request);\n        }\n        // Initial Request\n        if (!request.to_tag) {\n            switch (method) {\n                case SIP.C.INVITE:\n                    replaces =\n                        this.configuration.replaces !== SIP.C.supported.UNSUPPORTED &&\n                            request.parseHeader('replaces');\n                    if (replaces) {\n                        replacedDialog = this.dialogs[replaces.call_id + replaces.replaces_to_tag + replaces.replaces_from_tag];\n                        if (!replacedDialog) {\n                            //Replaced header without a matching dialog, reject\n                            request.reply_sl(481, null);\n                            return;\n                        }\n                        else if (replacedDialog.owner.status === SIP.Session.C.STATUS_TERMINATED) {\n                            request.reply_sl(603, null);\n                            return;\n                        }\n                        else if (replacedDialog.state === SIP.Dialog.C.STATUS_CONFIRMED && replaces.early_only) {\n                            request.reply_sl(486, null);\n                            return;\n                        }\n                    }\n                    session = new SIP.InviteServerContext(this, request);\n                    session.replacee = replacedDialog && replacedDialog.owner;\n                    self.emit('invite', session);\n                    break;\n                case SIP.C.BYE:\n                    // Out of dialog BYE received\n                    request.reply(481);\n                    break;\n                case SIP.C.CANCEL:\n                    session = this.findSession(request);\n                    if (session) {\n                        session.receiveRequest(request);\n                    }\n                    else {\n                        this.logger.warn('received CANCEL request for a non existent session');\n                    }\n                    break;\n                case SIP.C.ACK:\n                    /* Absorb it.\n                     * ACK request without a corresponding Invite Transaction\n                     * and without To tag.\n                     */\n                    break;\n                case SIP.C.NOTIFY:\n                    if (this.configuration.allowLegacyNotifications && this.listeners('notify').length > 0) {\n                        request.reply(200, null);\n                        self.emit('notify', { request: request });\n                    }\n                    else {\n                        request.reply(481, 'Subscription does not exist');\n                    }\n                    break;\n                case SIP.C.REFER:\n                    this.logger.log('Received an out of dialog refer');\n                    if (this.configuration.allowOutOfDialogRefers) {\n                        this.logger.log('Allow out of dialog refers is enabled on the UA');\n                        var referContext = new SIP.ReferServerContext(this, request);\n                        var hasReferListener = this.listeners('outOfDialogReferRequested').length;\n                        if (hasReferListener) {\n                            this.emit('outOfDialogReferRequested', referContext);\n                        }\n                        else {\n                            this.logger.log('No outOfDialogReferRequest listeners, automatically accepting and following the out of dialog refer');\n                            referContext.accept({ followRefer: true });\n                        }\n                        break;\n                    }\n                    request.reply(405);\n                    break;\n                default:\n                    request.reply(405);\n                    break;\n            }\n        }\n        // In-dialog request\n        else {\n            dialog = this.findDialog(request);\n            if (dialog) {\n                if (method === SIP.C.INVITE) {\n                    new SIP.Transactions.InviteServerTransaction(request, this);\n                }\n                dialog.receiveRequest(request);\n            }\n            else if (method === SIP.C.NOTIFY) {\n                session = this.findSession(request);\n                earlySubscription = this.findEarlySubscription(request);\n                if (session) {\n                    session.receiveRequest(request);\n                }\n                else if (earlySubscription) {\n                    earlySubscription.receiveRequest(request);\n                }\n                else {\n                    this.logger.warn('received NOTIFY request for a non existent session or subscription');\n                    request.reply(481, 'Subscription does not exist');\n                }\n            }\n            /* RFC3261 12.2.2\n             * Request with to tag, but no matching dialog found.\n             * Exception: ACK for an Invite request for which a dialog has not\n             * been created.\n             */\n            else {\n                if (method !== SIP.C.ACK) {\n                    request.reply(481);\n                }\n            }\n        }\n    };\n    //=================\n    // Utils\n    //=================\n    /**\n     * Get the session to which the request belongs to, if any.\n     * @private\n     * @param {SIP.IncomingRequest} request.\n     * @returns {SIP.OutgoingSession|SIP.IncomingSession|null}\n     */\n    UA.prototype.findSession = function (request) {\n        return this.sessions[request.call_id + request.from_tag] ||\n            this.sessions[request.call_id + request.to_tag] ||\n            null;\n    };\n    /**\n     * Get the dialog to which the request belongs to, if any.\n     * @private\n     * @param {SIP.IncomingRequest}\n     * @returns {SIP.Dialog|null}\n     */\n    UA.prototype.findDialog = function (request) {\n        return this.dialogs[request.call_id + request.from_tag + request.to_tag] ||\n            this.dialogs[request.call_id + request.to_tag + request.from_tag] ||\n            null;\n    };\n    /**\n     * Get the subscription which has not been confirmed to which the request belongs to, if any\n     * @private\n     * @param {SIP.IncomingRequest}\n     * @returns {SIP.Subscription|null}\n     */\n    UA.prototype.findEarlySubscription = function (request) {\n        return this.earlySubscriptions[request.call_id + request.to_tag + request.getHeader('event')] || null;\n    };\n    function checkAuthenticationFactory(authenticationFactory) {\n        if (!(authenticationFactory instanceof Function)) {\n            return;\n        }\n        if (!authenticationFactory.initialize) {\n            authenticationFactory.initialize = function initialize() {\n                return SIP.Utils.Promise.resolve();\n            };\n        }\n        return authenticationFactory;\n    }\n    /**\n     * Configuration load.\n     * @private\n     * returns {Boolean}\n     */\n    UA.prototype.loadConfig = function (configuration) {\n        // Settings and default values\n        var parameter, value, checked_value, hostportParams, registrarServer, settings = {\n            /* Host address\n            * Value to be set in Via sent_by and host part of Contact FQDN\n            */\n            viaHost: SIP.Utils.createRandomToken(12) + '.invalid',\n            uri: new SIP.URI('sip', 'anonymous.' + SIP.Utils.createRandomToken(6), 'anonymous.invalid', null, null),\n            //Custom Configuration Settings\n            custom: {},\n            //Display name\n            displayName: '',\n            // Password\n            password: null,\n            // Registration parameters\n            registerExpires: 600,\n            register: true,\n            registrarServer: null,\n            // Transport related parameters\n            transportConstructor: __webpack_require__(29)(SIP),\n            transportOptions: {},\n            //string to be inserted into User-Agent request header\n            userAgentString: SIP.C.USER_AGENT,\n            // Session parameters\n            noAnswerTimeout: 60,\n            // Hacks\n            hackViaTcp: false,\n            hackIpInContact: false,\n            hackWssInTransport: false,\n            hackAllowUnregisteredOptionTags: false,\n            // Session Description Handler Options\n            sessionDescriptionHandlerFactoryOptions: {\n                constraints: {},\n                peerConnectionOptions: {}\n            },\n            contactName: SIP.Utils.createRandomToken(8),\n            contactTransport: 'ws',\n            forceRport: false,\n            //autostarting\n            autostart: true,\n            autostop: true,\n            //Reliable Provisional Responses\n            rel100: SIP.C.supported.UNSUPPORTED,\n            // DTMF type: 'info' or 'rtp' (RFC 4733)\n            // RTP Payload Spec: https://tools.ietf.org/html/rfc4733\n            // WebRTC Audio Spec: https://tools.ietf.org/html/rfc7874\n            dtmfType: SIP.C.dtmfType.INFO,\n            // Replaces header (RFC 3891)\n            // http://tools.ietf.org/html/rfc3891\n            replaces: SIP.C.supported.UNSUPPORTED,\n            sessionDescriptionHandlerFactory: __webpack_require__(30)(SIP).defaultFactory,\n            authenticationFactory: checkAuthenticationFactory(function authenticationFactory(ua) {\n                return new SIP.DigestAuthentication(ua);\n            }),\n            allowLegacyNotifications: false,\n            allowOutOfDialogRefers: false,\n        };\n        // Pre-Configuration\n        function aliasUnderscored(parameter, logger) {\n            var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n                return m[0] + '_' + m[1].toLowerCase();\n            });\n            if (parameter === underscored) {\n                return;\n            }\n            var hasParameter = configuration.hasOwnProperty(parameter);\n            if (configuration.hasOwnProperty(underscored)) {\n                logger.warn(underscored + ' is deprecated, please use ' + parameter);\n                if (hasParameter) {\n                    logger.warn(parameter + ' overriding ' + underscored);\n                }\n            }\n            configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n        }\n        var configCheck = this.getConfigurationCheck();\n        // Check Mandatory parameters\n        for (parameter in configCheck.mandatory) {\n            aliasUnderscored(parameter, this.logger);\n            if (!configuration.hasOwnProperty(parameter)) {\n                throw new SIP.Exceptions.ConfigurationError(parameter);\n            }\n            else {\n                value = configuration[parameter];\n                checked_value = configCheck.mandatory[parameter](value);\n                if (checked_value !== undefined) {\n                    settings[parameter] = checked_value;\n                }\n                else {\n                    throw new SIP.Exceptions.ConfigurationError(parameter, value);\n                }\n            }\n        }\n        // Check Optional parameters\n        for (parameter in configCheck.optional) {\n            aliasUnderscored(parameter, this.logger);\n            if (configuration.hasOwnProperty(parameter)) {\n                value = configuration[parameter];\n                // If the parameter value is an empty array, but shouldn't be, apply its default value.\n                if (value instanceof Array && value.length === 0) {\n                    continue;\n                }\n                // If the parameter value is null, empty string, or undefined then apply its default value.\n                if (value === null || value === \"\" || value === undefined) {\n                    continue;\n                }\n                // If it's a number with NaN value then also apply its default value.\n                // NOTE: JS does not allow \"value === NaN\", the following does the work:\n                else if (typeof (value) === 'number' && isNaN(value)) {\n                    continue;\n                }\n                checked_value = configCheck.optional[parameter](value);\n                if (checked_value !== undefined) {\n                    settings[parameter] = checked_value;\n                }\n                else {\n                    throw new SIP.Exceptions.ConfigurationError(parameter, value);\n                }\n            }\n        }\n        // Post Configuration Process\n        // Allow passing 0 number as displayName.\n        if (settings.displayName === 0) {\n            settings.displayName = '0';\n        }\n        // Instance-id for GRUU\n        if (!settings.instanceId) {\n            settings.instanceId = SIP.Utils.newUUID();\n        }\n        // sipjsId instance parameter. Static random tag of length 5\n        settings.sipjsId = SIP.Utils.createRandomToken(5);\n        // String containing settings.uri without scheme and user.\n        hostportParams = settings.uri.clone();\n        hostportParams.user = null;\n        settings.hostportParams = hostportParams.toRaw().replace(/^sip:/i, '');\n        /* Check whether authorizationUser is explicitly defined.\n         * Take 'settings.uri.user' value if not.\n         */\n        if (!settings.authorizationUser) {\n            settings.authorizationUser = settings.uri.user;\n        }\n        /* If no 'registrarServer' is set use the 'uri' value without user portion. */\n        if (!settings.registrarServer) {\n            registrarServer = settings.uri.clone();\n            registrarServer.user = null;\n            settings.registrarServer = registrarServer;\n        }\n        // User noAnswerTimeout\n        settings.noAnswerTimeout = settings.noAnswerTimeout * 1000;\n        // Via Host\n        if (settings.hackIpInContact) {\n            if (typeof settings.hackIpInContact === 'boolean') {\n                settings.viaHost = SIP.Utils.getRandomTestNetIP();\n            }\n            else if (typeof settings.hackIpInContact === 'string') {\n                settings.viaHost = settings.hackIpInContact;\n            }\n        }\n        // Contact transport parameter\n        if (settings.hackWssInTransport) {\n            settings.contactTransport = 'wss';\n        }\n        this.contact = {\n            pub_gruu: null,\n            temp_gruu: null,\n            uri: new SIP.URI('sip', settings.contactName, settings.viaHost, null, { transport: settings.contactTransport }),\n            toString: function (options) {\n                options = options || {};\n                var anonymous = options.anonymous || null, outbound = options.outbound || null, contact = '<';\n                if (anonymous) {\n                    contact += (this.temp_gruu || ('sip:anonymous@anonymous.invalid;transport=' + settings.contactTransport)).toString();\n                }\n                else {\n                    contact += (this.pub_gruu || this.uri).toString();\n                }\n                if (outbound) {\n                    contact += ';ob';\n                }\n                contact += '>';\n                return contact;\n            }\n        };\n        var skeleton = {};\n        // Fill the value of the configuration_skeleton\n        for (parameter in settings) {\n            skeleton[parameter] = settings[parameter];\n        }\n        Object.assign(this.configuration, skeleton);\n        this.logger.log('configuration parameters after validation:');\n        for (parameter in settings) {\n            switch (parameter) {\n                case 'uri':\n                case 'registrarServer':\n                case 'sessionDescriptionHandlerFactory':\n                    this.logger.log(' ' + parameter + ': ' + settings[parameter]);\n                    break;\n                case 'password':\n                    this.logger.log(' ' + parameter + ': ' + 'NOT SHOWN');\n                    break;\n                case 'transportConstructor':\n                    this.logger.log(' ' + parameter + ': ' + settings[parameter].name);\n                    break;\n                default:\n                    this.logger.log(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n            }\n        }\n        return;\n    };\n    /**\n     * Configuration checker.\n     * @private\n     * @return {Boolean}\n     */\n    UA.prototype.getConfigurationCheck = function () {\n        return {\n            mandatory: {},\n            optional: {\n                uri: function (uri) {\n                    var parsed;\n                    if (!(/^sip:/i).test(uri)) {\n                        uri = SIP.C.SIP + ':' + uri;\n                    }\n                    parsed = SIP.URI.parse(uri);\n                    if (!parsed) {\n                        return;\n                    }\n                    else if (!parsed.user) {\n                        return;\n                    }\n                    else {\n                        return parsed;\n                    }\n                },\n                transportConstructor: function (transportConstructor) {\n                    if (transportConstructor instanceof Function) {\n                        return transportConstructor;\n                    }\n                },\n                transportOptions: function (transportOptions) {\n                    if (typeof transportOptions === 'object') {\n                        return transportOptions;\n                    }\n                },\n                authorizationUser: function (authorizationUser) {\n                    if (SIP.Grammar.parse('\"' + authorizationUser + '\"', 'quoted_string') === -1) {\n                        return;\n                    }\n                    else {\n                        return authorizationUser;\n                    }\n                },\n                displayName: function (displayName) {\n                    if (SIP.Grammar.parse('\"' + displayName + '\"', 'displayName') === -1) {\n                        return;\n                    }\n                    else {\n                        return displayName;\n                    }\n                },\n                dtmfType: function (dtmfType) {\n                    switch (dtmfType) {\n                        case SIP.C.dtmfType.RTP:\n                            return SIP.C.dtmfType.RTP;\n                        case SIP.C.dtmfType.INFO:\n                        // Fall through\n                        default:\n                            return SIP.C.dtmfType.INFO;\n                    }\n                },\n                hackViaTcp: function (hackViaTcp) {\n                    if (typeof hackViaTcp === 'boolean') {\n                        return hackViaTcp;\n                    }\n                },\n                hackIpInContact: function (hackIpInContact) {\n                    if (typeof hackIpInContact === 'boolean') {\n                        return hackIpInContact;\n                    }\n                    else if (typeof hackIpInContact === 'string' && SIP.Grammar.parse(hackIpInContact, 'host') !== -1) {\n                        return hackIpInContact;\n                    }\n                },\n                hackWssInTransport: function (hackWssInTransport) {\n                    if (typeof hackWssInTransport === 'boolean') {\n                        return hackWssInTransport;\n                    }\n                },\n                hackAllowUnregisteredOptionTags: function (hackAllowUnregisteredOptionTags) {\n                    if (typeof hackAllowUnregisteredOptionTags === 'boolean') {\n                        return hackAllowUnregisteredOptionTags;\n                    }\n                },\n                contactTransport: function (contactTransport) {\n                    if (typeof contactTransport === 'string') {\n                        return contactTransport;\n                    }\n                },\n                forceRport: function (forceRport) {\n                    if (typeof forceRport === 'boolean') {\n                        return forceRport;\n                    }\n                },\n                instanceId: function (instanceId) {\n                    if (typeof instanceId !== 'string') {\n                        return;\n                    }\n                    if ((/^uuid:/i.test(instanceId))) {\n                        instanceId = instanceId.substr(5);\n                    }\n                    if (SIP.Grammar.parse(instanceId, 'uuid') === -1) {\n                        return;\n                    }\n                    else {\n                        return instanceId;\n                    }\n                },\n                noAnswerTimeout: function (noAnswerTimeout) {\n                    var value;\n                    if (SIP.Utils.isDecimal(noAnswerTimeout)) {\n                        value = Number(noAnswerTimeout);\n                        if (value > 0) {\n                            return value;\n                        }\n                    }\n                },\n                password: function (password) {\n                    return String(password);\n                },\n                rel100: function (rel100) {\n                    if (rel100 === SIP.C.supported.REQUIRED) {\n                        return SIP.C.supported.REQUIRED;\n                    }\n                    else if (rel100 === SIP.C.supported.SUPPORTED) {\n                        return SIP.C.supported.SUPPORTED;\n                    }\n                    else {\n                        return SIP.C.supported.UNSUPPORTED;\n                    }\n                },\n                replaces: function (replaces) {\n                    if (replaces === SIP.C.supported.REQUIRED) {\n                        return SIP.C.supported.REQUIRED;\n                    }\n                    else if (replaces === SIP.C.supported.SUPPORTED) {\n                        return SIP.C.supported.SUPPORTED;\n                    }\n                    else {\n                        return SIP.C.supported.UNSUPPORTED;\n                    }\n                },\n                register: function (register) {\n                    if (typeof register === 'boolean') {\n                        return register;\n                    }\n                },\n                registerExpires: function (registerExpires) {\n                    var value;\n                    if (SIP.Utils.isDecimal(registerExpires)) {\n                        value = Number(registerExpires);\n                        if (value > 0) {\n                            return value;\n                        }\n                    }\n                },\n                registrarServer: function (registrarServer) {\n                    var parsed;\n                    if (typeof registrarServer !== 'string') {\n                        return;\n                    }\n                    if (!/^sip:/i.test(registrarServer)) {\n                        registrarServer = SIP.C.SIP + ':' + registrarServer;\n                    }\n                    parsed = SIP.URI.parse(registrarServer);\n                    if (!parsed) {\n                        return;\n                    }\n                    else if (parsed.user) {\n                        return;\n                    }\n                    else {\n                        return parsed;\n                    }\n                },\n                userAgentString: function (userAgentString) {\n                    if (typeof userAgentString === 'string') {\n                        return userAgentString;\n                    }\n                },\n                autostart: function (autostart) {\n                    if (typeof autostart === 'boolean') {\n                        return autostart;\n                    }\n                },\n                autostop: function (autostop) {\n                    if (typeof autostop === 'boolean') {\n                        return autostop;\n                    }\n                },\n                sessionDescriptionHandlerFactory: function (sessionDescriptionHandlerFactory) {\n                    if (sessionDescriptionHandlerFactory instanceof Function) {\n                        return sessionDescriptionHandlerFactory;\n                    }\n                },\n                sessionDescriptionHandlerFactoryOptions: function (options) {\n                    if (typeof options === 'object') {\n                        return options;\n                    }\n                },\n                authenticationFactory: checkAuthenticationFactory,\n                allowLegacyNotifications: function (allowLegacyNotifications) {\n                    if (typeof allowLegacyNotifications === 'boolean') {\n                        return allowLegacyNotifications;\n                    }\n                },\n                custom: function (custom) {\n                    if (typeof custom === 'object') {\n                        return custom;\n                    }\n                },\n                contactName: function (contactName) {\n                    if (typeof contactName === 'string') {\n                        return contactName;\n                    }\n                },\n            }\n        };\n    };\n    UA.C = C;\n    SIP.UA = UA;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28)))\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\r\n} catch (e) {\r\n\t// This works if the window reference is available\r\n\tif (typeof window === \"object\") g = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * @fileoverview Transport\n */\n/**\n * @augments SIP\n * @class Transport\n * @param {Object} options\n */\nmodule.exports = function (SIP) {\n    var Transport, C = {\n        // Transport status codes\n        STATUS_CONNECTING: 0,\n        STATUS_OPEN: 1,\n        STATUS_CLOSING: 2,\n        STATUS_CLOSED: 3,\n    };\n    var WebSocket = (global.window || global).WebSocket;\n    /**\n     * Compute an amount of time in seconds to wait before sending another\n     * keep-alive.\n     * @returns {Number}\n     */\n    function computeKeepAliveTimeout(upperBound) {\n        var lowerBound = upperBound * 0.8;\n        return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n    }\n    Transport = function (logger, options) {\n        options = SIP.Utils.defaultOptions({}, options);\n        this.logger = logger;\n        this.ws = null;\n        this.server = null;\n        this.connectionPromise = null;\n        this.connectDeferredResolve = null;\n        this.connectionTimeout = null;\n        this.disconnectionPromise = null;\n        this.disconnectDeferredResolve = null;\n        this.boundOnOpen = null;\n        this.boundOnMessage = null;\n        this.boundOnClose = null;\n        this.boundOnError = null;\n        this.reconnectionAttempts = 0;\n        this.reconnectTimer = null;\n        // Keep alive\n        this.keepAliveInterval = null;\n        this.keepAliveDebounceTimeout = null;\n        this.status = C.STATUS_CONNECTING;\n        this.configuration = {};\n        this.loadConfig(options);\n    };\n    Transport.prototype = Object.create(SIP.Transport.prototype, {\n        /**\n        *\n        * @returns {Boolean}\n        */\n        isConnected: { writable: true, value: function isConnected() {\n                return this.status === C.STATUS_OPEN;\n            } },\n        /**\n         * Send a message.\n         * @param {SIP.OutgoingRequest|String} msg\n         * @param {Object} [options]\n         * @returns {Promise}\n         */\n        sendPromise: { writable: true, value: function sendPromise(msg, options) {\n                options = options || {};\n                if (!this.statusAssert(C.STATUS_OPEN, options.force)) {\n                    this.onError('unable to send message - WebSocket not open');\n                    return SIP.Utils.Promise.reject();\n                }\n                var message = msg.toString();\n                if (this.ws) {\n                    if (this.configuration.traceSip === true) {\n                        this.logger.log('sending WebSocket message:\\n\\n' + message + '\\n');\n                    }\n                    this.ws.send(message);\n                    return SIP.Utils.Promise.resolve({ msg: message });\n                }\n                else {\n                    this.onError('unable to send message - WebSocket does not exist');\n                    return SIP.Utils.Promise.reject();\n                }\n            } },\n        /**\n        * Disconnect socket.\n        */\n        disconnectPromise: { writable: true, value: function disconnectPromise(options) {\n                if (this.disconnectionPromise) {\n                    return this.disconnectionPromise;\n                }\n                options = options || {};\n                if (!this.statusTransition(C.STATUS_CLOSING, options.force)) {\n                    return SIP.Utils.Promise.reject('Failed status transition - attempted to disconnect a socket that was not open');\n                }\n                this.disconnectionPromise = new SIP.Utils.Promise(function (resolve, reject) {\n                    this.disconnectDeferredResolve = resolve;\n                    if (this.reconnectTimer) {\n                        SIP.Timers.clearTimeout(this.reconnectTimer);\n                        this.reconnectTimer = null;\n                    }\n                    if (this.ws) {\n                        this.stopSendingKeepAlives();\n                        this.logger.log('closing WebSocket ' + this.server.ws_uri);\n                        this.ws.close(options.code, options.reason);\n                    }\n                    else {\n                        reject('Attempted to disconnect but the websocket doesn\\'t exist');\n                    }\n                }.bind(this));\n                return this.disconnectionPromise;\n            } },\n        /**\n        * Connect socket.\n        */\n        connectPromise: { writable: true, value: function connectPromise(options) {\n                if (this.connectionPromise) {\n                    return this.connectionPromise;\n                }\n                options = options || {};\n                this.server = this.server || this.getNextWsServer(options.force);\n                this.connectionPromise = new SIP.Utils.Promise(function (resolve, reject) {\n                    if ((this.status === C.STATUS_OPEN || this.status === C.STATUS_CLOSING) && !options.force) {\n                        this.logger.warn('WebSocket ' + this.server.ws_uri + ' is already connected');\n                        reject('Failed status check - attempted to open a connection but already open/closing');\n                        return;\n                    }\n                    this.connectDeferredResolve = resolve;\n                    this.status = C.STATUS_CONNECTING;\n                    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);\n                    this.disposeWs();\n                    try {\n                        this.ws = new WebSocket(this.server.ws_uri, 'sip');\n                    }\n                    catch (e) {\n                        this.ws = null;\n                        this.status = C.STATUS_CLOSED; // force status to closed in error case\n                        this.onError('error connecting to WebSocket ' + this.server.ws_uri + ':' + e);\n                        reject('Failed to create a websocket');\n                        return;\n                    }\n                    if (!this.ws) {\n                        reject('Unexpected instance websocket not set');\n                        return;\n                    }\n                    this.connectionTimeout = SIP.Timers.setTimeout(function () {\n                        this.onError('took too long to connect - exceeded time set in configuration.connectionTimeout: ' + this.configuration.connectionTimeout + 's');\n                    }.bind(this), this.configuration.connectionTimeout * 1000);\n                    this.boundOnOpen = this.onOpen.bind(this);\n                    this.boundOnMessage = this.onMessage.bind(this);\n                    this.boundOnClose = this.onClose.bind(this);\n                    this.boundOnError = this.onError.bind(this);\n                    this.ws.addEventListener('open', this.boundOnOpen);\n                    this.ws.addEventListener('message', this.boundOnMessage);\n                    this.ws.addEventListener('close', this.boundOnClose);\n                    this.ws.addEventListener('error', this.boundOnError);\n                }.bind(this));\n                return this.connectionPromise;\n            } },\n        // Transport Event Handlers\n        /**\n        * @event\n        * @param {event} e\n        */\n        onOpen: { writable: true, value: function onOpen() {\n                this.status = C.STATUS_OPEN; // quietly force status to open\n                this.emit('connected');\n                SIP.Timers.clearTimeout(this.connectionTimeout);\n                this.logger.log('WebSocket ' + this.server.ws_uri + ' connected');\n                // Clear reconnectTimer since we are not disconnected\n                if (this.reconnectTimer !== null) {\n                    SIP.Timers.clearTimeout(this.reconnectTimer);\n                    this.reconnectTimer = null;\n                }\n                // Reset reconnectionAttempts\n                this.reconnectionAttempts = 0;\n                // Reset disconnection promise so we can disconnect from a fresh state\n                this.disconnectionPromise = null;\n                this.disconnectDeferredResolve = null;\n                // Start sending keep-alives\n                this.startSendingKeepAlives();\n                if (this.connectDeferredResolve) {\n                    this.connectDeferredResolve({ overrideEvent: true });\n                }\n                else {\n                    this.logger.warn('Unexpected websocket.onOpen with no connectDeferredResolve');\n                }\n            } },\n        /**\n        * @event\n        * @param {event} e\n        */\n        onClose: { writable: true, value: function onClose(e) {\n                this.logger.log('WebSocket disconnected (code: ' + e.code + (e.reason ? '| reason: ' + e.reason : '') + ')');\n                this.emit('disconnected', { code: e.code, reason: e.reason });\n                if (this.status !== C.STATUS_CLOSING) {\n                    this.logger.warn('WebSocket abrupt disconnection');\n                    this.emit('transportError');\n                }\n                this.stopSendingKeepAlives();\n                // Clean up connection variables so we can connect again from a fresh state\n                SIP.Timers.clearTimeout(this.connectionTimeout);\n                this.connectionTimeout = null;\n                this.connectionPromise = null;\n                this.connectDeferredResolve = null;\n                // Check whether the user requested to close.\n                if (this.disconnectDeferredResolve) {\n                    this.disconnectDeferredResolve({ overrideEvent: true });\n                    this.statusTransition(C.STATUS_CLOSED);\n                    this.disconnectDeferredResolve = null;\n                    return;\n                }\n                this.status = C.STATUS_CLOSED; // quietly force status to closed\n                this.reconnect();\n            } },\n        /**\n        * Removes event listeners and clears the instance ws\n        * @private\n        * @param {event} e\n        */\n        disposeWs: { writable: true, value: function disposeWs() {\n                if (this.ws) {\n                    this.ws.removeEventListener('open', this.boundOnOpen);\n                    this.ws.removeEventListener('message', this.boundOnMessage);\n                    this.ws.removeEventListener('close', this.boundOnClose);\n                    this.ws.removeEventListener('error', this.boundOnError);\n                    this.boundOnOpen = null;\n                    this.boundOnMessage = null;\n                    this.boundOnClose = null;\n                    this.boundOnError = null;\n                    this.ws = null;\n                }\n            } },\n        /**\n        * @event\n        * @param {event} e\n        */\n        onMessage: { writable: true, value: function onMessage(e) {\n                var data = e.data;\n                // CRLF Keep Alive response from server. Clear our keep alive timeout.\n                if (/^(\\r\\n)+$/.test(data)) {\n                    this.clearKeepAliveTimeout();\n                    if (this.configuration.traceSip === true) {\n                        this.logger.log('received WebSocket message with CRLF Keep Alive response');\n                    }\n                    return;\n                }\n                else if (!data) {\n                    this.logger.warn('received empty message, message discarded');\n                    return;\n                }\n                // WebSocket binary message.\n                else if (typeof data !== 'string') {\n                    try {\n                        data = String.fromCharCode.apply(null, new Uint8Array(data));\n                    }\n                    catch (err) {\n                        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');\n                        return;\n                    }\n                    if (this.configuration.traceSip === true) {\n                        this.logger.log('received WebSocket binary message:\\n\\n' + data + '\\n');\n                    }\n                }\n                // WebSocket text message.\n                else {\n                    if (this.configuration.traceSip === true) {\n                        this.logger.log('received WebSocket text message:\\n\\n' + data + '\\n');\n                    }\n                }\n                this.emit('message', data);\n            } },\n        /**\n        * @event\n        * @param {event} e\n        */\n        onError: { writable: true, value: function onError(e) {\n                this.logger.warn('Transport error: ' + e);\n                this.emit('transportError');\n            } },\n        /**\n        * Reconnection attempt logic.\n        * @private\n        */\n        reconnect: { writable: true, value: function reconnect() {\n                if (this.reconnectionAttempts > 0) {\n                    this.logger.log('Reconnection attempt ' + this.reconnectionAttempts + ' failed');\n                }\n                if (this.noAvailableServers()) {\n                    this.logger.warn('no available ws servers left - going to closed state');\n                    this.status = C.STATUS_CLOSED;\n                    this.emit('closed');\n                    this.resetServerErrorStatus();\n                    return;\n                }\n                if (this.isConnected()) {\n                    this.logger.warn('attempted to reconnect while connected - forcing disconnect');\n                    this.disconnect({ force: true });\n                }\n                this.reconnectionAttempts += 1;\n                if (this.reconnectionAttempts > this.configuration.maxReconnectionAttempts) {\n                    this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);\n                    this.logger.log('transport ' + this.server.ws_uri + ' failed | connection state set to \\'error\\'');\n                    this.server.isError = true;\n                    this.emit('transportError');\n                    this.server = this.getNextWsServer();\n                    this.reconnectionAttempts = 0;\n                    this.reconnect();\n                }\n                else {\n                    this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnectionAttempts + ')');\n                    this.reconnectTimer = SIP.Timers.setTimeout(function () {\n                        this.connect();\n                        this.reconnectTimer = null;\n                    }.bind(this), (this.reconnectionAttempts === 1) ? 0 : this.configuration.reconnectionTimeout * 1000);\n                }\n            } },\n        /**\n        * Resets the error state of all servers in the configuration\n        */\n        resetServerErrorStatus: { writable: true, value: function resetServerErrorStatus() {\n                var idx, length = this.configuration.wsServers.length;\n                for (idx = 0; idx < length; idx++) {\n                    this.configuration.wsServers[idx].isError = false;\n                }\n            } },\n        /**\n        * Retrieve the next server to which connect.\n        * @private\n        * @param {Boolean} force allows bypass of server error status checking\n        * @returns {Object} wsServer\n        */\n        getNextWsServer: { writable: true, value: function getNextWsServer(force) {\n                if (this.noAvailableServers()) {\n                    this.logger.warn('attempted to get next ws server but there are no available ws servers left');\n                    return;\n                }\n                // Order servers by weight\n                var idx, length, wsServer, candidates = [];\n                length = this.configuration.wsServers.length;\n                for (idx = 0; idx < length; idx++) {\n                    wsServer = this.configuration.wsServers[idx];\n                    if (wsServer.isError && !force) {\n                        continue;\n                    }\n                    else if (candidates.length === 0) {\n                        candidates.push(wsServer);\n                    }\n                    else if (wsServer.weight > candidates[0].weight) {\n                        candidates = [wsServer];\n                    }\n                    else if (wsServer.weight === candidates[0].weight) {\n                        candidates.push(wsServer);\n                    }\n                }\n                idx = Math.floor(Math.random() * candidates.length);\n                return candidates[idx];\n            } },\n        /**\n        * Checks all configuration servers, returns true if all of them have isError: true and false otherwise\n        * @private\n        * @returns {Boolean}\n        */\n        noAvailableServers: { writable: true, value: function noAvailableServers() {\n                var server;\n                for (server in this.configuration.wsServers) {\n                    if (!this.configuration.wsServers[server].isError) {\n                        return false;\n                    }\n                }\n                return true;\n            } },\n        //==============================\n        // KeepAlive Stuff\n        //==============================\n        /**\n         * Send a keep-alive (a double-CRLF sequence).\n         * @private\n         * @returns {Boolean}\n         */\n        sendKeepAlive: { writable: true, value: function sendKeepAlive() {\n                if (this.keepAliveDebounceTimeout) {\n                    // We already have an outstanding keep alive, do not send another.\n                    return;\n                }\n                this.keepAliveDebounceTimeout = SIP.Timers.setTimeout(function () {\n                    this.emit('keepAliveDebounceTimeout');\n                    this.clearKeepAliveTimeout();\n                }.bind(this), this.configuration.keepAliveDebounce * 1000);\n                return this.send('\\r\\n\\r\\n');\n            } },\n        clearKeepAliveTimeout: { writable: true, value: function clearKeepAliveTimeout() {\n                SIP.Timers.clearTimeout(this.keepAliveDebounceTimeout);\n                this.keepAliveDebounceTimeout = null;\n            } },\n        /**\n         * Start sending keep-alives.\n         * @private\n         */\n        startSendingKeepAlives: { writable: true, value: function startSendingKeepAlives() {\n                if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {\n                    this.keepAliveInterval = SIP.Timers.setInterval(function () {\n                        this.sendKeepAlive();\n                        this.startSendingKeepAlives();\n                    }.bind(this), computeKeepAliveTimeout(this.configuration.keepAliveInterval));\n                }\n            } },\n        /**\n         * Stop sending keep-alives.\n         * @private\n         */\n        stopSendingKeepAlives: { writable: true, value: function stopSendingKeepAlives() {\n                SIP.Timers.clearInterval(this.keepAliveInterval);\n                SIP.Timers.clearTimeout(this.keepAliveDebounceTimeout);\n                this.keepAliveInterval = null;\n                this.keepAliveDebounceTimeout = null;\n            } },\n        //==============================\n        // Status Stuff\n        //==============================\n        /**\n        * Checks given status against instance current status. Returns true if they match\n        * @private\n        * @param {Number} status\n        * @param {Boolean} [force]\n        * @returns {Boolean}\n        */\n        statusAssert: { writable: true, value: function statusAssert(status, force) {\n                if (status === this.status) {\n                    return true;\n                }\n                else {\n                    if (force) {\n                        this.logger.warn('Attempted to assert ' + Object.keys(C)[this.status] + ' as ' + Object.keys(C)[status] + '- continuing with option: \\'force\\'');\n                        return true;\n                    }\n                    else {\n                        this.logger.warn('Tried to assert ' + Object.keys(C)[status] + ' but is currently ' + Object.keys(C)[this.status]);\n                        return false;\n                    }\n                }\n            } },\n        /**\n        * Transitions the status. Checks for legal transition via assertion beforehand\n        * @private\n        * @param {Number} status\n        * @param {Boolean} [force]\n        * @returns {Boolean}\n        */\n        statusTransition: { writable: true, value: function statusTransition(status, force) {\n                this.logger.log('Attempting to transition status from ' + Object.keys(C)[this.status] + ' to ' + Object.keys(C)[status]);\n                if ((status === C.STATUS_OPEN && this.statusAssert(C.STATUS_CONNECTING, force)) ||\n                    (status === C.STATUS_CLOSING && this.statusAssert(C.STATUS_OPEN, force)) ||\n                    (status === C.STATUS_CLOSED && this.statusAssert(C.STATUS_CLOSING, force))) {\n                    this.status = status;\n                    return true;\n                }\n                else {\n                    this.logger.warn('Status transition failed - result: no-op - reason: either gave an nonexistent status or attempted illegal transition');\n                    return false;\n                }\n            } },\n        //==============================\n        // Configuration Handling\n        //==============================\n        /**\n         * Configuration load.\n         * @private\n         * returns {Boolean}\n         */\n        loadConfig: { writable: true, value: function loadConfig(configuration) {\n                var parameter, value, checked_value, settings = {\n                    wsServers: [{\n                            scheme: 'WSS',\n                            sip_uri: '<sip:edge.sip.onsip.com;transport=ws;lr>',\n                            weight: 0,\n                            ws_uri: 'wss://edge.sip.onsip.com',\n                            isError: false\n                        }],\n                    connectionTimeout: 5,\n                    maxReconnectionAttempts: 3,\n                    reconnectionTimeout: 4,\n                    keepAliveInterval: 0,\n                    keepAliveDebounce: 10,\n                    // Logging\n                    traceSip: false,\n                };\n                // Pre-Configuration\n                function aliasUnderscored(parameter, logger) {\n                    var underscored = parameter.replace(/([a-z][A-Z])/g, function (m) {\n                        return m[0] + '_' + m[1].toLowerCase();\n                    });\n                    if (parameter === underscored) {\n                        return;\n                    }\n                    var hasParameter = configuration.hasOwnProperty(parameter);\n                    if (configuration.hasOwnProperty(underscored)) {\n                        logger.warn(underscored + ' is deprecated, please use ' + parameter);\n                        if (hasParameter) {\n                            logger.warn(parameter + ' overriding ' + underscored);\n                        }\n                    }\n                    configuration[parameter] = hasParameter ? configuration[parameter] : configuration[underscored];\n                }\n                var configCheck = this.getConfigurationCheck();\n                // Check Mandatory parameters\n                for (parameter in configCheck.mandatory) {\n                    aliasUnderscored(parameter, this.logger);\n                    if (!configuration.hasOwnProperty(parameter)) {\n                        throw new SIP.Exceptions.ConfigurationError(parameter);\n                    }\n                    else {\n                        value = configuration[parameter];\n                        checked_value = configCheck.mandatory[parameter](value);\n                        if (checked_value !== undefined) {\n                            settings[parameter] = checked_value;\n                        }\n                        else {\n                            throw new SIP.Exceptions.ConfigurationError(parameter, value);\n                        }\n                    }\n                }\n                // Check Optional parameters\n                for (parameter in configCheck.optional) {\n                    aliasUnderscored(parameter, this.logger);\n                    if (configuration.hasOwnProperty(parameter)) {\n                        value = configuration[parameter];\n                        // If the parameter value is an empty array, but shouldn't be, apply its default value.\n                        if (value instanceof Array && value.length === 0) {\n                            continue;\n                        }\n                        // If the parameter value is null, empty string, or undefined then apply its default value.\n                        if (value === null || value === '' || value === undefined) {\n                            continue;\n                        }\n                        // If it's a number with NaN value then also apply its default value.\n                        // NOTE: JS does not allow \"value === NaN\", the following does the work:\n                        else if (typeof (value) === 'number' && isNaN(value)) {\n                            continue;\n                        }\n                        checked_value = configCheck.optional[parameter](value);\n                        if (checked_value !== undefined) {\n                            settings[parameter] = checked_value;\n                        }\n                        else {\n                            throw new SIP.Exceptions.ConfigurationError(parameter, value);\n                        }\n                    }\n                }\n                var skeleton = {};\n                // Fill the value of the configuration_skeleton\n                for (parameter in settings) {\n                    skeleton[parameter] = {\n                        value: settings[parameter],\n                    };\n                }\n                Object.defineProperties(this.configuration, skeleton);\n                this.logger.log('configuration parameters after validation:');\n                for (parameter in settings) {\n                    this.logger.log(' ' + parameter + ': ' + JSON.stringify(settings[parameter]));\n                }\n                return;\n            } },\n        /**\n         * Configuration checker.\n         * @private\n         * @return {Boolean}\n         */\n        getConfigurationCheck: { writable: true, value: function getConfigurationCheck() {\n                return {\n                    mandatory: {},\n                    optional: {\n                        //Note: this function used to call 'this.logger.error' but calling 'this' with anything here is invalid\n                        wsServers: function (wsServers) {\n                            var idx, length, url;\n                            /* Allow defining wsServers parameter as:\n                             *  String: \"host\"\n                             *  Array of Strings: [\"host1\", \"host2\"]\n                             *  Array of Objects: [{ws_uri:\"host1\", weight:1}, {ws_uri:\"host2\", weight:0}]\n                             *  Array of Objects and Strings: [{ws_uri:\"host1\"}, \"host2\"]\n                             */\n                            if (typeof wsServers === 'string') {\n                                wsServers = [{ ws_uri: wsServers }];\n                            }\n                            else if (wsServers instanceof Array) {\n                                length = wsServers.length;\n                                for (idx = 0; idx < length; idx++) {\n                                    if (typeof wsServers[idx] === 'string') {\n                                        wsServers[idx] = { ws_uri: wsServers[idx] };\n                                    }\n                                }\n                            }\n                            else {\n                                return;\n                            }\n                            if (wsServers.length === 0) {\n                                return false;\n                            }\n                            length = wsServers.length;\n                            for (idx = 0; idx < length; idx++) {\n                                if (!wsServers[idx].ws_uri) {\n                                    return;\n                                }\n                                if (wsServers[idx].weight && !Number(wsServers[idx].weight)) {\n                                    return;\n                                }\n                                url = SIP.Grammar.parse(wsServers[idx].ws_uri, 'absoluteURI');\n                                if (url === -1) {\n                                    return;\n                                }\n                                else if (['wss', 'ws', 'udp'].indexOf(url.scheme) < 0) {\n                                    return;\n                                }\n                                else {\n                                    wsServers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=' + url.scheme.replace(/^wss$/i, 'ws') + ';lr>';\n                                    if (!wsServers[idx].weight) {\n                                        wsServers[idx].weight = 0;\n                                    }\n                                    wsServers[idx].isError = false;\n                                    wsServers[idx].scheme = url.scheme.toUpperCase();\n                                }\n                            }\n                            return wsServers;\n                        },\n                        keepAliveInterval: function (keepAliveInterval) {\n                            var value;\n                            if (SIP.Utils.isDecimal(keepAliveInterval)) {\n                                value = Number(keepAliveInterval);\n                                if (value > 0) {\n                                    return value;\n                                }\n                            }\n                        },\n                        keepAliveDebounce: function (keepAliveDebounce) {\n                            var value;\n                            if (SIP.Utils.isDecimal(keepAliveDebounce)) {\n                                value = Number(keepAliveDebounce);\n                                if (value > 0) {\n                                    return value;\n                                }\n                            }\n                        },\n                        traceSip: function (traceSip) {\n                            if (typeof traceSip === 'boolean') {\n                                return traceSip;\n                            }\n                        },\n                        connectionTimeout: function (connectionTimeout) {\n                            var value;\n                            if (SIP.Utils.isDecimal(connectionTimeout)) {\n                                value = Number(connectionTimeout);\n                                if (value > 0) {\n                                    return value;\n                                }\n                            }\n                        },\n                        maxReconnectionAttempts: function (maxReconnectionAttempts) {\n                            var value;\n                            if (SIP.Utils.isDecimal(maxReconnectionAttempts)) {\n                                value = Number(maxReconnectionAttempts);\n                                if (value >= 0) {\n                                    return value;\n                                }\n                            }\n                        },\n                        reconnectionTimeout: function (reconnectionTimeout) {\n                            var value;\n                            if (SIP.Utils.isDecimal(reconnectionTimeout)) {\n                                value = Number(reconnectionTimeout);\n                                if (value > 0) {\n                                    return value;\n                                }\n                            }\n                        }\n                    }\n                };\n            } }\n    });\n    Transport.C = C;\n    SIP.Web.Transport = Transport;\n    return Transport;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28)))\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * @fileoverview SessionDescriptionHandler\n */\n/* SessionDescriptionHandler\n * @class PeerConnection helper Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n */\nmodule.exports = function (SIP) {\n    // Constructor\n    var SessionDescriptionHandler = function (logger, observer, options) {\n        // TODO: Validate the options\n        this.options = options || {};\n        this.logger = logger;\n        this.observer = observer;\n        this.dtmfSender = null;\n        this.shouldAcquireMedia = true;\n        this.CONTENT_TYPE = 'application/sdp';\n        this.C = {};\n        this.C.DIRECTION = {\n            NULL: null,\n            SENDRECV: \"sendrecv\",\n            SENDONLY: \"sendonly\",\n            RECVONLY: \"recvonly\",\n            INACTIVE: \"inactive\"\n        };\n        this.logger.log('SessionDescriptionHandlerOptions: ' + JSON.stringify(this.options));\n        this.direction = this.C.DIRECTION.NULL;\n        this.modifiers = this.options.modifiers || [];\n        if (!Array.isArray(this.modifiers)) {\n            this.modifiers = [this.modifiers];\n        }\n        var environment = global.window || global;\n        this.WebRTC = {\n            MediaStream: environment.MediaStream,\n            getUserMedia: environment.navigator.mediaDevices.getUserMedia.bind(environment.navigator.mediaDevices),\n            RTCPeerConnection: environment.RTCPeerConnection\n        };\n        this.iceGatheringDeferred = null;\n        this.iceGatheringTimeout = false;\n        this.iceGatheringTimer = null;\n        this.initPeerConnection(this.options.peerConnectionOptions);\n        this.constraints = this.checkAndDefaultConstraints(this.options.constraints);\n    };\n    /**\n     * @param {SIP.Session} session\n     * @param {Object} [options]\n     */\n    SessionDescriptionHandler.defaultFactory = function defaultFactory(session, options) {\n        var logger = session.ua.getLogger('sip.invitecontext.sessionDescriptionHandler', session.id);\n        var SessionDescriptionHandlerObserver = __webpack_require__(31);\n        var observer = new SessionDescriptionHandlerObserver(session, options);\n        return new SessionDescriptionHandler(logger, observer, options);\n    };\n    SessionDescriptionHandler.prototype = Object.create(SIP.SessionDescriptionHandler.prototype, {\n        // Functions the sesssion can use\n        /**\n         * Destructor\n         */\n        close: { writable: true, value: function () {\n                this.logger.log('closing PeerConnection');\n                // have to check signalingState since this.close() gets called multiple times\n                if (this.peerConnection && this.peerConnection.signalingState !== 'closed') {\n                    if (this.peerConnection.getSenders) {\n                        this.peerConnection.getSenders().forEach(function (sender) {\n                            if (sender.track) {\n                                sender.track.stop();\n                            }\n                        });\n                    }\n                    else {\n                        this.logger.warn('Using getLocalStreams which is deprecated');\n                        this.peerConnection.getLocalStreams().forEach(function (stream) {\n                            stream.getTracks().forEach(function (track) {\n                                track.stop();\n                            });\n                        });\n                    }\n                    if (this.peerConnection.getReceivers) {\n                        this.peerConnection.getReceivers().forEach(function (receiver) {\n                            if (receiver.track) {\n                                receiver.track.stop();\n                            }\n                        });\n                    }\n                    else {\n                        this.logger.warn('Using getRemoteStreams which is deprecated');\n                        this.peerConnection.getRemoteStreams().forEach(function (stream) {\n                            stream.getTracks().forEach(function (track) {\n                                track.stop();\n                            });\n                        });\n                    }\n                    this.resetIceGatheringComplete();\n                    this.peerConnection.close();\n                }\n            } },\n        /**\n         * Gets the local description from the underlying media implementation\n         * @param {Object} [options] Options object to be used by getDescription\n         * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints\n         * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer connection with the new options\n         * @param {Array} [modifiers] Array with one time use description modifiers\n         * @returns {Promise} Promise that resolves with the local description to be used for the session\n         */\n        getDescription: { writable: true, value: function (options, modifiers) {\n                options = options || {};\n                if (options.peerConnectionOptions) {\n                    this.initPeerConnection(options.peerConnectionOptions);\n                }\n                // Merge passed constraints with saved constraints and save\n                var newConstraints = Object.assign({}, this.constraints, options.constraints);\n                newConstraints = this.checkAndDefaultConstraints(newConstraints);\n                if (JSON.stringify(newConstraints) !== JSON.stringify(this.constraints)) {\n                    this.constraints = newConstraints;\n                    this.shouldAcquireMedia = true;\n                }\n                modifiers = modifiers || [];\n                if (!Array.isArray(modifiers)) {\n                    modifiers = [modifiers];\n                }\n                modifiers = modifiers.concat(this.modifiers);\n                return SIP.Utils.Promise.resolve()\n                    .then(function () {\n                    if (this.shouldAcquireMedia) {\n                        return this.acquire(this.constraints).then(function () {\n                            this.shouldAcquireMedia = false;\n                        }.bind(this));\n                    }\n                }.bind(this))\n                    .then(function () {\n                    return this.createOfferOrAnswer(options.RTCOfferOptions, modifiers);\n                }.bind(this))\n                    .then(function (description) {\n                    this.emit('getDescription', description);\n                    return {\n                        body: description.sdp,\n                        contentType: this.CONTENT_TYPE\n                    };\n                }.bind(this));\n            } },\n        /**\n         * Check if the Session Description Handler can handle the Content-Type described by a SIP Message\n         * @param {String} contentType The content type that is in the SIP Message\n         * @returns {boolean}\n         */\n        hasDescription: { writable: true, value: function hasDescription(contentType) {\n                return contentType === this.CONTENT_TYPE;\n            } },\n        /**\n         * The modifier that should be used when the session would like to place the call on hold\n         * @param {String} [sdp] The description that will be modified\n         * @returns {Promise} Promise that resolves with modified SDP\n         */\n        holdModifier: { writable: true, value: function holdModifier(description) {\n                if (!(/a=(sendrecv|sendonly|recvonly|inactive)/).test(description.sdp)) {\n                    description.sdp = description.sdp.replace(/(m=[^\\r]*\\r\\n)/g, '$1a=sendonly\\r\\n');\n                }\n                else {\n                    description.sdp = description.sdp.replace(/a=sendrecv\\r\\n/g, 'a=sendonly\\r\\n');\n                    description.sdp = description.sdp.replace(/a=recvonly\\r\\n/g, 'a=inactive\\r\\n');\n                }\n                return SIP.Utils.Promise.resolve(description);\n            } },\n        /**\n         * Set the remote description to the underlying media implementation\n         * @param {String} sessionDescription The description provided by a SIP message to be set on the media implementation\n         * @param {Object} [options] Options object to be used by getDescription\n         * @param {MediaStreamConstraints} [options.constraints] MediaStreamConstraints https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamConstraints\n         * @param {Object} [options.peerConnectionOptions] If this is set it will recreate the peer connection with the new options\n         * @param {Array} [modifiers] Array with one time use description modifiers\n         * @returns {Promise} Promise that resolves once the description is set\n         */\n        setDescription: { writable: true, value: function setDescription(sessionDescription, options, modifiers) {\n                var _this = this;\n                var self = this;\n                options = options || {};\n                if (options.peerConnectionOptions) {\n                    this.initPeerConnection(options.peerConnectionOptions);\n                }\n                modifiers = modifiers || [];\n                if (!Array.isArray(modifiers)) {\n                    modifiers = [modifiers];\n                }\n                modifiers = modifiers.concat(this.modifiers);\n                var description = {\n                    type: this.hasOffer('local') ? 'answer' : 'offer',\n                    sdp: sessionDescription\n                };\n                return SIP.Utils.Promise.resolve()\n                    .then(function () {\n                    // Media should be acquired in getDescription unless we need to do it sooner for some reason (FF61+)\n                    if (this.shouldAcquireMedia && this.options.alwaysAcquireMediaFirst) {\n                        return this.acquire(this.constraints).then(function () {\n                            this.shouldAcquireMedia = false;\n                        }.bind(this));\n                    }\n                }.bind(this))\n                    .then(function () {\n                    return SIP.Utils.reducePromises(modifiers, description);\n                })\n                    .catch(function (e) {\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"setDescription\", e, \"The modifiers did not resolve successfully\");\n                    _this.logger.error(error.message);\n                    self.emit('peerConnection-setRemoteDescriptionFailed', error);\n                    throw error;\n                })\n                    .then(function (modifiedDescription) {\n                    self.emit('setDescription', modifiedDescription);\n                    return self.peerConnection.setRemoteDescription(modifiedDescription);\n                })\n                    .catch(function (e) {\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    // Check the original SDP for video, and ensure that we have want to do audio fallback\n                    if ((/^m=video.+$/gm).test(sessionDescription) && !options.disableAudioFallback) {\n                        // Do not try to audio fallback again\n                        options.disableAudioFallback = true;\n                        // Remove video first, then do the other modifiers\n                        return _this.setDescription(sessionDescription, options, [SIP.Web.Modifiers.stripVideo].concat(modifiers));\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"setDescription\", e);\n                    _this.logger.error(error.error);\n                    _this.emit('peerConnection-setRemoteDescriptionFailed', error);\n                    throw error;\n                })\n                    .then(function setRemoteDescriptionSuccess() {\n                    if (self.peerConnection.getReceivers) {\n                        self.emit('setRemoteDescription', self.peerConnection.getReceivers());\n                    }\n                    else {\n                        self.emit('setRemoteDescription', self.peerConnection.getRemoteStreams());\n                    }\n                    self.emit('confirmed', self);\n                });\n            } },\n        /**\n         * Send DTMF via RTP (RFC 4733)\n         * @param {String} tones A string containing DTMF digits\n         * @param {Object} [options] Options object to be used by sendDtmf\n         * @returns {boolean} true if DTMF send is successful, false otherwise\n         */\n        sendDtmf: { writable: true, value: function sendDtmf(tones, options) {\n                if (!this.dtmfSender && this.hasBrowserGetSenderSupport()) {\n                    var senders = this.peerConnection.getSenders();\n                    if (senders.length > 0) {\n                        this.dtmfSender = senders[0].dtmf;\n                    }\n                }\n                if (!this.dtmfSender && this.hasBrowserTrackSupport()) {\n                    var streams = this.peerConnection.getLocalStreams();\n                    if (streams.length > 0) {\n                        var audioTracks = streams[0].getAudioTracks();\n                        if (audioTracks.length > 0) {\n                            this.dtmfSender = this.peerConnection.createDTMFSender(audioTracks[0]);\n                        }\n                    }\n                }\n                if (!this.dtmfSender) {\n                    return false;\n                }\n                try {\n                    this.dtmfSender.insertDTMF(tones, options.duration, options.interToneGap);\n                }\n                catch (e) {\n                    if (e.type === \"InvalidStateError\" || e.type === \"InvalidCharacterError\") {\n                        this.logger.error(e);\n                        return false;\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n                this.logger.log('DTMF sent via RTP: ' + tones.toString());\n                return true;\n            } },\n        getDirection: { writable: true, value: function getDirection() {\n                return this.direction;\n            } },\n        // Internal functions\n        createOfferOrAnswer: { writable: true, value: function createOfferOrAnswer(RTCOfferOptions, modifiers) {\n                var _this = this;\n                var self = this;\n                var methodName;\n                var pc = this.peerConnection;\n                RTCOfferOptions = RTCOfferOptions || {};\n                methodName = self.hasOffer('remote') ? 'createAnswer' : 'createOffer';\n                return pc[methodName](RTCOfferOptions)\n                    .catch(function (e) {\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"createOfferOrAnswer\", e, 'peerConnection-' + methodName + 'Failed');\n                    _this.emit('peerConnection-' + methodName + 'Failed', error);\n                    throw error;\n                })\n                    .then(function (sdp) {\n                    return SIP.Utils.reducePromises(modifiers, self.createRTCSessionDescriptionInit(sdp));\n                })\n                    .then(function (sdp) {\n                    self.resetIceGatheringComplete();\n                    return pc.setLocalDescription(sdp);\n                })\n                    .catch(function (e) {\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"createOfferOrAnswer\", e, 'peerConnection-SetLocalDescriptionFailed');\n                    _this.emit('peerConnection-SetLocalDescriptionFailed', error);\n                    throw error;\n                })\n                    .then(function onSetLocalDescriptionSuccess() {\n                    return self.waitForIceGatheringComplete();\n                })\n                    .then(function readySuccess() {\n                    var localDescription = self.createRTCSessionDescriptionInit(self.peerConnection.localDescription);\n                    return SIP.Utils.reducePromises(modifiers, localDescription);\n                })\n                    .then(function (localDescription) {\n                    self.setDirection(localDescription.sdp);\n                    return localDescription;\n                })\n                    .catch(function (e) {\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"createOfferOrAnswer\", e);\n                    _this.logger.error(error);\n                    throw error;\n                });\n            } },\n        // Creates an RTCSessionDescriptionInit from an RTCSessionDescription\n        createRTCSessionDescriptionInit: { writable: true, value: function createRTCSessionDescriptionInit(RTCSessionDescription) {\n                return {\n                    type: RTCSessionDescription.type,\n                    sdp: RTCSessionDescription.sdp\n                };\n            } },\n        addDefaultIceCheckingTimeout: { writable: true, value: function addDefaultIceCheckingTimeout(peerConnectionOptions) {\n                if (peerConnectionOptions.iceCheckingTimeout === undefined) {\n                    peerConnectionOptions.iceCheckingTimeout = 5000;\n                }\n                return peerConnectionOptions;\n            } },\n        addDefaultIceServers: { writable: true, value: function addDefaultIceServers(rtcConfiguration) {\n                if (!rtcConfiguration.iceServers) {\n                    rtcConfiguration.iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];\n                }\n                return rtcConfiguration;\n            } },\n        checkAndDefaultConstraints: { writable: true, value: function checkAndDefaultConstraints(constraints) {\n                var defaultConstraints = { audio: true, video: !this.options.alwaysAcquireMediaFirst };\n                constraints = constraints || defaultConstraints;\n                // Empty object check\n                if (Object.keys(constraints).length === 0 && constraints.constructor === Object) {\n                    return defaultConstraints;\n                }\n                return constraints;\n            } },\n        hasBrowserTrackSupport: { writable: true, value: function hasBrowserTrackSupport() {\n                return Boolean(this.peerConnection.addTrack);\n            } },\n        hasBrowserGetSenderSupport: { writable: true, value: function hasBrowserGetSenderSupport() {\n                return Boolean(this.peerConnection.getSenders);\n            } },\n        initPeerConnection: { writable: true, value: function initPeerConnection(options) {\n                var self = this;\n                options = options || {};\n                options = this.addDefaultIceCheckingTimeout(options);\n                options.rtcConfiguration = options.rtcConfiguration || {};\n                options.rtcConfiguration = this.addDefaultIceServers(options.rtcConfiguration);\n                this.logger.log('initPeerConnection');\n                if (this.peerConnection) {\n                    this.logger.log('Already have a peer connection for this session. Tearing down.');\n                    this.resetIceGatheringComplete();\n                    this.peerConnection.close();\n                }\n                this.peerConnection = new this.WebRTC.RTCPeerConnection(options.rtcConfiguration);\n                this.logger.log('New peer connection created');\n                if ('ontrack' in this.peerConnection) {\n                    this.peerConnection.addEventListener('track', function (e) {\n                        self.logger.log('track added');\n                        self.observer.trackAdded();\n                        self.emit('addTrack', e);\n                    });\n                }\n                else {\n                    this.logger.warn('Using onaddstream which is deprecated');\n                    this.peerConnection.onaddstream = function (e) {\n                        self.logger.log('stream added');\n                        self.emit('addStream', e);\n                    };\n                }\n                this.peerConnection.onicecandidate = function (e) {\n                    self.emit('iceCandidate', e);\n                    if (e.candidate) {\n                        self.logger.log('ICE candidate received: ' + (e.candidate.candidate === null ? null : e.candidate.candidate.trim()));\n                    }\n                    else if (e.candidate === null) {\n                        // indicates the end of candidate gathering\n                        self.logger.log('ICE candidate gathering complete');\n                        self.triggerIceGatheringComplete();\n                    }\n                };\n                this.peerConnection.onicegatheringstatechange = function () {\n                    self.logger.log('RTCIceGatheringState changed: ' + this.iceGatheringState);\n                    switch (this.iceGatheringState) {\n                        case 'gathering':\n                            self.emit('iceGathering', this);\n                            if (!self.iceGatheringTimer && options.iceCheckingTimeout) {\n                                self.iceGatheringTimeout = false;\n                                self.iceGatheringTimer = SIP.Timers.setTimeout(function () {\n                                    self.logger.log('RTCIceChecking Timeout Triggered after ' + options.iceCheckingTimeout + ' milliseconds');\n                                    self.iceGatheringTimeout = true;\n                                    self.triggerIceGatheringComplete();\n                                }, options.iceCheckingTimeout);\n                            }\n                            break;\n                        case 'complete':\n                            self.triggerIceGatheringComplete();\n                            break;\n                    }\n                };\n                this.peerConnection.oniceconnectionstatechange = function () {\n                    var stateEvent;\n                    switch (this.iceConnectionState) {\n                        case 'new':\n                            stateEvent = 'iceConnection';\n                            break;\n                        case 'checking':\n                            stateEvent = 'iceConnectionChecking';\n                            break;\n                        case 'connected':\n                            stateEvent = 'iceConnectionConnected';\n                            break;\n                        case 'completed':\n                            stateEvent = 'iceConnectionCompleted';\n                            break;\n                        case 'failed':\n                            stateEvent = 'iceConnectionFailed';\n                            break;\n                        case 'disconnected':\n                            stateEvent = 'iceConnectionDisconnected';\n                            break;\n                        case 'closed':\n                            stateEvent = 'iceConnectionClosed';\n                            break;\n                        default:\n                            self.logger.warn('Unknown iceConnection state:', this.iceConnectionState);\n                            return;\n                    }\n                    self.emit(stateEvent, this);\n                };\n            } },\n        acquire: { writable: true, value: function acquire(constraints) {\n                var _this = this;\n                // Default audio & video to true\n                constraints = this.checkAndDefaultConstraints(constraints);\n                return new SIP.Utils.Promise(function (resolve, reject) {\n                    /*\n                     * Make the call asynchronous, so that ICCs have a chance\n                     * to define callbacks to `userMediaRequest`\n                     */\n                    this.logger.log('acquiring local media');\n                    this.emit('userMediaRequest', constraints);\n                    if (constraints.audio || constraints.video) {\n                        this.WebRTC.getUserMedia(constraints)\n                            .then(function (streams) {\n                            this.observer.trackAdded();\n                            this.emit('userMedia', streams);\n                            resolve(streams);\n                        }.bind(this)).catch(function (e) {\n                            this.emit('userMediaFailed', e);\n                            reject(e);\n                        }.bind(this));\n                    }\n                    else {\n                        // Local streams were explicitly excluded.\n                        resolve([]);\n                    }\n                }.bind(this))\n                    .catch(function (e) {\n                    // TODO: This propogates downwards\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"acquire\", e, \"unable to acquire streams\");\n                    _this.logger.error(error.message);\n                    _this.logger.error(error.error);\n                    throw error;\n                })\n                    .then(function acquireSucceeded(streams) {\n                    this.logger.log('acquired local media streams');\n                    try {\n                        // Remove old tracks\n                        if (this.peerConnection.removeTrack) {\n                            this.peerConnection.getSenders().forEach(function (sender) {\n                                this.peerConnection.removeTrack(sender);\n                            }, this);\n                        }\n                        return streams;\n                    }\n                    catch (e) {\n                        return SIP.Utils.Promise.reject(e);\n                    }\n                }.bind(this))\n                    .catch(function (e) {\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"acquire\", e, \"error removing streams\");\n                    _this.logger.error(error.message);\n                    _this.logger.error(error.error);\n                    throw error;\n                })\n                    .then(function addStreams(streams) {\n                    try {\n                        streams = [].concat(streams);\n                        streams.forEach(function (stream) {\n                            if (this.peerConnection.addTrack) {\n                                stream.getTracks().forEach(function (track) {\n                                    this.peerConnection.addTrack(track, stream);\n                                }, this);\n                            }\n                            else {\n                                // Chrome 59 does not support addTrack\n                                this.peerConnection.addStream(stream);\n                            }\n                        }, this);\n                    }\n                    catch (e) {\n                        return SIP.Utils.Promise.reject(e);\n                    }\n                    return SIP.Utils.Promise.resolve();\n                }.bind(this))\n                    .catch(function (e) {\n                    if (e instanceof SIP.Exceptions.SessionDescriptionHandlerError) {\n                        throw e;\n                    }\n                    var error = new SIP.Exceptions.SessionDescriptionHandlerError(\"acquire\", e, \"error adding stream\");\n                    _this.logger.error(error.message);\n                    _this.logger.error(error.error);\n                    throw error;\n                });\n            } },\n        hasOffer: { writable: true, value: function hasOffer(where) {\n                var offerState = 'have-' + where + '-offer';\n                return this.peerConnection.signalingState === offerState;\n            } },\n        // ICE gathering state handling\n        isIceGatheringComplete: { writable: true, value: function isIceGatheringComplete() {\n                return this.peerConnection.iceGatheringState === 'complete' || this.iceGatheringTimeout;\n            } },\n        resetIceGatheringComplete: { writable: true, value: function resetIceGatheringComplete() {\n                this.iceGatheringTimeout = false;\n                if (this.iceGatheringTimer) {\n                    SIP.Timers.clearTimeout(this.iceGatheringTimer);\n                    this.iceGatheringTimer = null;\n                }\n                if (this.iceGatheringDeferred) {\n                    this.iceGatheringDeferred.reject();\n                    this.iceGatheringDeferred = null;\n                }\n            } },\n        setDirection: { writable: true, value: function setDirection(sdp) {\n                var match = sdp.match(/a=(sendrecv|sendonly|recvonly|inactive)/);\n                if (match === null) {\n                    this.direction = this.C.DIRECTION.NULL;\n                    this.observer.directionChanged();\n                    return;\n                }\n                var direction = match[1];\n                switch (direction) {\n                    case this.C.DIRECTION.SENDRECV:\n                    case this.C.DIRECTION.SENDONLY:\n                    case this.C.DIRECTION.RECVONLY:\n                    case this.C.DIRECTION.INACTIVE:\n                        this.direction = direction;\n                        break;\n                    default:\n                        this.direction = this.C.DIRECTION.NULL;\n                        break;\n                }\n                this.observer.directionChanged();\n            } },\n        triggerIceGatheringComplete: { writable: true, value: function triggerIceGatheringComplete() {\n                if (this.isIceGatheringComplete()) {\n                    this.emit('iceGatheringComplete', this);\n                    if (this.iceGatheringTimer) {\n                        SIP.Timers.clearTimeout(this.iceGatheringTimer);\n                        this.iceGatheringTimer = null;\n                    }\n                    if (this.iceGatheringDeferred) {\n                        this.iceGatheringDeferred.resolve();\n                        this.iceGatheringDeferred = null;\n                    }\n                }\n            } },\n        waitForIceGatheringComplete: { writable: true, value: function waitForIceGatheringComplete() {\n                if (this.isIceGatheringComplete()) {\n                    return SIP.Utils.Promise.resolve();\n                }\n                else if (!this.isIceGatheringDeferred) {\n                    this.iceGatheringDeferred = SIP.Utils.defer();\n                }\n                return this.iceGatheringDeferred.promise;\n            } }\n    });\n    return SessionDescriptionHandler;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28)))\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview SessionDescriptionHandlerObserver\n */\n/* SessionDescriptionHandlerObserver\n * @class SessionDescriptionHandler Observer Class.\n * @param {SIP.Session} session\n * @param {Object} [options]\n */\n// Constructor\nvar SessionDescriptionHandlerObserver = function (session, options) {\n    this.session = session || {};\n    this.options = options || {};\n};\nSessionDescriptionHandlerObserver.prototype = {\n    trackAdded: function () {\n        this.session.emit('trackAdded');\n    },\n    directionChanged: function () {\n        this.session.emit('directionChanged');\n    },\n};\nmodule.exports = SessionDescriptionHandlerObserver;\n\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * @fileoverview Incoming SIP Message Sanity Check\n */\n/**\n * SIP message sanity check.\n * @augments SIP\n * @function\n * @param {SIP.IncomingMessage} message\n * @param {SIP.UA} ua\n * @param {SIP.Transport} transport\n * @returns {Boolean}\n */\nmodule.exports = function (SIP) {\n    var sanityCheck, requests = [], responses = [], all = [];\n    // Reply\n    function reply(status_code, message, transport) {\n        var to, response = SIP.Utils.buildStatusLine(status_code), vias = message.getHeaders('via'), length = vias.length, idx = 0;\n        for (idx; idx < length; idx++) {\n            response += \"Via: \" + vias[idx] + \"\\r\\n\";\n        }\n        to = message.getHeader('To');\n        if (!message.to_tag) {\n            to += ';tag=' + SIP.Utils.newTag();\n        }\n        response += \"To: \" + to + \"\\r\\n\";\n        response += \"From: \" + message.getHeader('From') + \"\\r\\n\";\n        response += \"Call-ID: \" + message.call_id + \"\\r\\n\";\n        response += \"CSeq: \" + message.cseq + \" \" + message.method + \"\\r\\n\";\n        response += \"\\r\\n\";\n        transport.send(response);\n    }\n    /*\n     * Sanity Check for incoming Messages\n     *\n     * Requests:\n     *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme\n     *  - _rfc3261_16_3_4_ Receive a Request already sent by us\n     *   Does not look at via sent-by but at sipjsId, which is inserted as\n     *   a prefix in all initial requests generated by the ua\n     *  - _rfc3261_18_3_request_ Body Content-Length\n     *  - _rfc3261_8_2_2_2_ Merged Requests\n     *\n     * Responses:\n     *  - _rfc3261_8_1_3_3_ Multiple Via headers\n     *  - _rfc3261_18_1_2_ sent-by mismatch\n     *  - _rfc3261_18_3_response_ Body Content-Length\n     *\n     * All:\n     *  - Minimum headers in a SIP message\n     */\n    // Sanity Check functions for requests\n    function rfc3261_8_2_2_1(message, ua, transport) {\n        if (!message.ruri || message.ruri.scheme !== 'sip') {\n            reply(416, message, transport);\n            return false;\n        }\n    }\n    function rfc3261_16_3_4(message, ua, transport) {\n        if (!message.to_tag) {\n            if (message.call_id.substr(0, 5) === ua.configuration.sipjsId) {\n                reply(482, message, transport);\n                return false;\n            }\n        }\n    }\n    function rfc3261_18_3_request(message, ua, transport) {\n        var len = SIP.Utils.str_utf8_length(message.body), contentLength = message.getHeader('content-length');\n        if (len < contentLength) {\n            reply(400, message, transport);\n            return false;\n        }\n    }\n    function rfc3261_8_2_2_2(message, ua, transport) {\n        var tr, idx, fromTag = message.from_tag, call_id = message.call_id, cseq = message.cseq;\n        if (!message.to_tag) {\n            if (message.method === SIP.C.INVITE) {\n                tr = ua.transactions.ist[message.via_branch];\n                if (tr) {\n                    return;\n                }\n                else {\n                    for (idx in ua.transactions.ist) {\n                        tr = ua.transactions.ist[idx];\n                        if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n                            reply(482, message, transport);\n                            return false;\n                        }\n                    }\n                }\n            }\n            else {\n                tr = ua.transactions.nist[message.via_branch];\n                if (tr) {\n                    return;\n                }\n                else {\n                    for (idx in ua.transactions.nist) {\n                        tr = ua.transactions.nist[idx];\n                        if (tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {\n                            reply(482, message, transport);\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    // Sanity Check functions for responses\n    function rfc3261_8_1_3_3(message, ua) {\n        if (message.getHeaders('via').length > 1) {\n            ua.getLogger('sip.sanitycheck').warn('More than one Via header field present in the response. Dropping the response');\n            return false;\n        }\n    }\n    function rfc3261_18_1_2(message, ua) {\n        var viaHost = ua.configuration.viaHost;\n        if (message.via.host !== viaHost || message.via.port !== undefined) {\n            ua.getLogger('sip.sanitycheck').warn('Via sent-by in the response does not match UA Via host value. Dropping the response');\n            return false;\n        }\n    }\n    function rfc3261_18_3_response(message, ua) {\n        var len = SIP.Utils.str_utf8_length(message.body), contentLength = message.getHeader('content-length');\n        if (len < contentLength) {\n            ua.getLogger('sip.sanitycheck').warn('Message body length is lower than the value in Content-Length header field. Dropping the response');\n            return false;\n        }\n    }\n    // Sanity Check functions for requests and responses\n    function minimumHeaders(message, ua) {\n        var mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'], idx = mandatoryHeaders.length;\n        while (idx--) {\n            if (!message.hasHeader(mandatoryHeaders[idx])) {\n                ua.getLogger('sip.sanitycheck').warn('Missing mandatory header field : ' + mandatoryHeaders[idx] + '. Dropping the response');\n                return false;\n            }\n        }\n    }\n    requests.push(rfc3261_8_2_2_1);\n    requests.push(rfc3261_16_3_4);\n    requests.push(rfc3261_18_3_request);\n    requests.push(rfc3261_8_2_2_2);\n    responses.push(rfc3261_8_1_3_3);\n    responses.push(rfc3261_18_1_2);\n    responses.push(rfc3261_18_3_response);\n    all.push(minimumHeaders);\n    sanityCheck = function (message, ua, transport) {\n        var len, pass;\n        len = all.length;\n        while (len--) {\n            pass = all[len](message, ua, transport);\n            if (pass === false) {\n                return false;\n            }\n        }\n        if (message instanceof SIP.IncomingRequest) {\n            len = requests.length;\n            while (len--) {\n                pass = requests[len](message, ua, transport);\n                if (pass === false) {\n                    return false;\n                }\n            }\n        }\n        else if (message instanceof SIP.IncomingResponse) {\n            len = responses.length;\n            while (len--) {\n                pass = responses[len](message, ua, transport);\n                if (pass === false) {\n                    return false;\n                }\n            }\n        }\n        //Everything is OK\n        return true;\n    };\n    SIP.sanityCheck = sanityCheck;\n};\n\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar md5 = __webpack_require__(34);\n/**\n * @fileoverview SIP Digest Authentication\n */\n/**\n * SIP Digest Authentication.\n * @augments SIP.\n * @function Digest Authentication\n * @param {SIP.UA} ua\n */\nmodule.exports = function (Utils) {\n    var DigestAuthentication;\n    DigestAuthentication = function (ua) {\n        this.logger = ua.getLogger('sipjs.digestauthentication');\n        this.username = ua.configuration.authorizationUser;\n        this.password = ua.configuration.password;\n        this.cnonce = null;\n        this.nc = 0;\n        this.ncHex = '00000000';\n        this.response = null;\n    };\n    /**\n    * Performs Digest authentication given a SIP request and the challenge\n    * received in a response to that request.\n    * Returns true if credentials were successfully generated, false otherwise.\n    *\n    * @param {SIP.OutgoingRequest} request\n    * @param {Object} challenge\n    */\n    DigestAuthentication.prototype.authenticate = function (request, challenge) {\n        // Inspect and validate the challenge.\n        this.algorithm = challenge.algorithm;\n        this.realm = challenge.realm;\n        this.nonce = challenge.nonce;\n        this.opaque = challenge.opaque;\n        this.stale = challenge.stale;\n        if (this.algorithm) {\n            if (this.algorithm !== 'MD5') {\n                this.logger.warn('challenge with Digest algorithm different than \"MD5\", authentication aborted');\n                return false;\n            }\n        }\n        else {\n            this.algorithm = 'MD5';\n        }\n        if (!this.realm) {\n            this.logger.warn('challenge without Digest realm, authentication aborted');\n            return false;\n        }\n        if (!this.nonce) {\n            this.logger.warn('challenge without Digest nonce, authentication aborted');\n            return false;\n        }\n        // 'qop' can contain a list of values (Array). Let's choose just one.\n        if (challenge.qop) {\n            if (challenge.qop.indexOf('auth') > -1) {\n                this.qop = 'auth';\n            }\n            else if (challenge.qop.indexOf('auth-int') > -1) {\n                this.qop = 'auth-int';\n            }\n            else {\n                // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n                this.logger.warn('challenge without Digest qop different than \"auth\" or \"auth-int\", authentication aborted');\n                return false;\n            }\n        }\n        else {\n            this.qop = null;\n        }\n        // Fill other attributes.\n        this.method = request.method;\n        this.uri = request.ruri;\n        this.cnonce = Utils.createRandomToken(12);\n        this.nc += 1;\n        this.updateNcHex();\n        // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n        if (this.nc === 4294967296) {\n            this.nc = 1;\n            this.ncHex = '00000001';\n        }\n        // Calculate the Digest \"response\" value.\n        this.calculateResponse();\n        return true;\n    };\n    /**\n    * Generate Digest 'response' value.\n    * @private\n    */\n    DigestAuthentication.prototype.calculateResponse = function () {\n        var ha1, ha2;\n        // HA1 = MD5(A1) = MD5(username:realm:password)\n        ha1 = md5(this.username + \":\" + this.realm + \":\" + this.password);\n        if (this.qop === 'auth') {\n            // HA2 = MD5(A2) = MD5(method:digestURI)\n            ha2 = md5(this.method + \":\" + this.uri);\n            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n            this.response = md5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n        }\n        else if (this.qop === 'auth-int') {\n            // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n            ha2 = md5(this.method + \":\" + this.uri + \":\" + md5(this.body ? this.body : \"\"));\n            // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n            this.response = md5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n        }\n        else if (this.qop === null) {\n            // HA2 = MD5(A2) = MD5(method:digestURI)\n            ha2 = md5(this.method + \":\" + this.uri);\n            // response = MD5(HA1:nonce:HA2)\n            this.response = md5(ha1 + \":\" + this.nonce + \":\" + ha2);\n        }\n    };\n    /**\n    * Return the Proxy-Authorization or WWW-Authorization header value.\n    */\n    DigestAuthentication.prototype.toString = function () {\n        var auth_params = [];\n        if (!this.response) {\n            throw new Error('response field does not exist, cannot generate Authorization header');\n        }\n        auth_params.push('algorithm=' + this.algorithm);\n        auth_params.push('username=\"' + this.username + '\"');\n        auth_params.push('realm=\"' + this.realm + '\"');\n        auth_params.push('nonce=\"' + this.nonce + '\"');\n        auth_params.push('uri=\"' + this.uri + '\"');\n        auth_params.push('response=\"' + this.response + '\"');\n        if (this.opaque) {\n            auth_params.push('opaque=\"' + this.opaque + '\"');\n        }\n        if (this.qop) {\n            auth_params.push('qop=' + this.qop);\n            auth_params.push('cnonce=\"' + this.cnonce + '\"');\n            auth_params.push('nc=' + this.ncHex);\n        }\n        return 'Digest ' + auth_params.join(', ');\n    };\n    /**\n    * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n    * @private\n    */\n    DigestAuthentication.prototype.updateNcHex = function () {\n        var hex = Number(this.nc).toString(16);\n        this.ncHex = '00000000'.substr(0, 8 - hex.length) + hex;\n    };\n    return DigestAuthentication;\n};\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__webpack_require__(35));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working varialbes\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse {}\n}(this, function () {\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\t    /*\n\t     * Local polyfil of Object.create\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {};\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }())\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            var r = (function (m_w) {\n\t                var m_w = m_w;\n\t                var m_z = 0x3ade68b1;\n\t                var mask = 0xffffffff;\n\n\t                return function () {\n\t                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;\n\t                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;\n\t                    var result = ((m_z << 0x10) + m_w) & mask;\n\t                    result /= 0x100000000;\n\t                    result += 0.5;\n\t                    return result * (Math.random() > .5 ? 1 : -1);\n\t                }\n\t            });\n\n\t            for (var i = 0, rcache; i < nBytes; i += 4) {\n\t                var _r = r((rcache || Math.random()) * 0x100000000);\n\n\t                rcache = _r() * 0x3ade67b7;\n\t                words.push((_r() * 0x100000000) | 0);\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                var processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nvar Grammar = __webpack_require__(37);\nmodule.exports = function (SIP) {\n    return {\n        parse: function parseCustom(input, startRule) {\n            var options = { startRule: startRule, SIP: SIP };\n            try {\n                Grammar.parse(input, options);\n            }\n            catch (e) {\n                options.data = -1;\n            }\n            return options.data;\n        }\n    };\n};\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleIndices = { Contact: 119, Name_Addr_Header: 156, Record_Route: 176, Request_Response: 81, SIP_URI: 45, Subscription_State: 186, Supported: 191, Require: 182, Via: 194, absoluteURI: 84, Call_ID: 118, Content_Disposition: 130, Content_Length: 135, Content_Type: 136, CSeq: 146, displayName: 122, Event: 149, From: 151, host: 52, Max_Forwards: 154, Min_SE: 213, Proxy_Authenticate: 157, quoted_string: 40, Refer_To: 178, Replaces: 179, Session_Expires: 210, stun_URI: 217, To: 192, turn_URI: 223, uuid: 226, WWW_Authenticate: 209, challenge: 158, sipfrag: 230, Referred_By: 231 },\n      peg$startRuleIndex   = 119,\n\n      peg$consts = [\n        \"\\r\\n\",\n        peg$literalExpectation(\"\\r\\n\", false),\n        /^[0-9]/,\n        peg$classExpectation([[\"0\", \"9\"]], false, false),\n        /^[a-zA-Z]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false),\n        /^[0-9a-fA-F]/,\n        peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"], [\"A\", \"F\"]], false, false),\n        /^[\\0-\\xFF]/,\n        peg$classExpectation([[\"\\0\", \"\\xFF\"]], false, false),\n        /^[\"]/,\n        peg$classExpectation([\"\\\"\"], false, false),\n        \" \",\n        peg$literalExpectation(\" \", false),\n        \"\\t\",\n        peg$literalExpectation(\"\\t\", false),\n        /^[a-zA-Z0-9]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"]], false, false),\n        \";\",\n        peg$literalExpectation(\";\", false),\n        \"/\",\n        peg$literalExpectation(\"/\", false),\n        \"?\",\n        peg$literalExpectation(\"?\", false),\n        \":\",\n        peg$literalExpectation(\":\", false),\n        \"@\",\n        peg$literalExpectation(\"@\", false),\n        \"&\",\n        peg$literalExpectation(\"&\", false),\n        \"=\",\n        peg$literalExpectation(\"=\", false),\n        \"+\",\n        peg$literalExpectation(\"+\", false),\n        \"$\",\n        peg$literalExpectation(\"$\", false),\n        \",\",\n        peg$literalExpectation(\",\", false),\n        \"-\",\n        peg$literalExpectation(\"-\", false),\n        \"_\",\n        peg$literalExpectation(\"_\", false),\n        \".\",\n        peg$literalExpectation(\".\", false),\n        \"!\",\n        peg$literalExpectation(\"!\", false),\n        \"~\",\n        peg$literalExpectation(\"~\", false),\n        \"*\",\n        peg$literalExpectation(\"*\", false),\n        \"'\",\n        peg$literalExpectation(\"'\", false),\n        \"(\",\n        peg$literalExpectation(\"(\", false),\n        \")\",\n        peg$literalExpectation(\")\", false),\n        \"%\",\n        peg$literalExpectation(\"%\", false),\n        function() {return \" \"; },\n        function() {return ':'; },\n        /^[!-~]/,\n        peg$classExpectation([[\"!\", \"~\"]], false, false),\n        /^[\\x80-\\uFFFF]/,\n        peg$classExpectation([[\"\\x80\", \"\\uFFFF\"]], false, false),\n        /^[\\x80-\\xBF]/,\n        peg$classExpectation([[\"\\x80\", \"\\xBF\"]], false, false),\n        /^[a-f]/,\n        peg$classExpectation([[\"a\", \"f\"]], false, false),\n        \"`\",\n        peg$literalExpectation(\"`\", false),\n        \"<\",\n        peg$literalExpectation(\"<\", false),\n        \">\",\n        peg$literalExpectation(\">\", false),\n        \"\\\\\",\n        peg$literalExpectation(\"\\\\\", false),\n        \"[\",\n        peg$literalExpectation(\"[\", false),\n        \"]\",\n        peg$literalExpectation(\"]\", false),\n        \"{\",\n        peg$literalExpectation(\"{\", false),\n        \"}\",\n        peg$literalExpectation(\"}\", false),\n        function() {return \"*\"; },\n        function() {return \"/\"; },\n        function() {return \"=\"; },\n        function() {return \"(\"; },\n        function() {return \")\"; },\n        function() {return \">\"; },\n        function() {return \"<\"; },\n        function() {return \",\"; },\n        function() {return \";\"; },\n        function() {return \":\"; },\n        function() {return \"\\\"\"; },\n        /^[!-']/,\n        peg$classExpectation([[\"!\", \"'\"]], false, false),\n        /^[*-[]/,\n        peg$classExpectation([[\"*\", \"[\"]], false, false),\n        /^[\\]-~]/,\n        peg$classExpectation([[\"]\", \"~\"]], false, false),\n        function(contents) {\n                                return contents; },\n        /^[#-[]/,\n        peg$classExpectation([[\"#\", \"[\"]], false, false),\n        /^[\\0-\\t]/,\n        peg$classExpectation([[\"\\0\", \"\\t\"]], false, false),\n        /^[\\x0B-\\f]/,\n        peg$classExpectation([[\"\\x0B\", \"\\f\"]], false, false),\n        /^[\\x0E-\\x7F]/,\n        peg$classExpectation([[\"\\x0E\", \"\\x7F\"]], false, false),\n        function() {\n                                options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port);\n                                delete options.data.scheme;\n                                delete options.data.user;\n                                delete options.data.host;\n                                delete options.data.host_type;\n                                delete options.data.port;\n                              },\n        function() {\n                                options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n                                delete options.data.scheme;\n                                delete options.data.user;\n                                delete options.data.host;\n                                delete options.data.host_type;\n                                delete options.data.port;\n                                delete options.data.uri_params;\n\n                                if (options.startRule === 'SIP_URI') { options.data = options.data.uri;}\n                              },\n        \"sips\",\n        peg$literalExpectation(\"sips\", true),\n        \"sip\",\n        peg$literalExpectation(\"sip\", true),\n        function(uri_scheme) {\n                            options.data.scheme = uri_scheme; },\n        function() {\n                            options.data.user = decodeURIComponent(text().slice(0, -1));},\n        function() {\n                            options.data.password = text(); },\n        function() {\n                            options.data.host = text();\n                            return options.data.host; },\n        function() {\n                          options.data.host_type = 'domain';\n                          return text(); },\n        /^[a-zA-Z0-9_\\-]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"_\", \"-\"], false, false),\n        /^[a-zA-Z0-9\\-]/,\n        peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"0\", \"9\"], \"-\"], false, false),\n        function() {\n                            options.data.host_type = 'IPv6';\n                            return text(); },\n        \"::\",\n        peg$literalExpectation(\"::\", false),\n        function() {\n                          options.data.host_type = 'IPv6';\n                          return text(); },\n        function() {\n                            options.data.host_type = 'IPv4';\n                            return text(); },\n        \"25\",\n        peg$literalExpectation(\"25\", false),\n        /^[0-5]/,\n        peg$classExpectation([[\"0\", \"5\"]], false, false),\n        \"2\",\n        peg$literalExpectation(\"2\", false),\n        /^[0-4]/,\n        peg$classExpectation([[\"0\", \"4\"]], false, false),\n        \"1\",\n        peg$literalExpectation(\"1\", false),\n        /^[1-9]/,\n        peg$classExpectation([[\"1\", \"9\"]], false, false),\n        function(port) {\n                            port = parseInt(port.join(''));\n                            options.data.port = port;\n                            return port; },\n        \"transport=\",\n        peg$literalExpectation(\"transport=\", true),\n        \"udp\",\n        peg$literalExpectation(\"udp\", true),\n        \"tcp\",\n        peg$literalExpectation(\"tcp\", true),\n        \"sctp\",\n        peg$literalExpectation(\"sctp\", true),\n        \"tls\",\n        peg$literalExpectation(\"tls\", true),\n        function(transport) {\n                              if(!options.data.uri_params) options.data.uri_params={};\n                              options.data.uri_params['transport'] = transport.toLowerCase(); },\n        \"user=\",\n        peg$literalExpectation(\"user=\", true),\n        \"phone\",\n        peg$literalExpectation(\"phone\", true),\n        \"ip\",\n        peg$literalExpectation(\"ip\", true),\n        function(user) {\n                              if(!options.data.uri_params) options.data.uri_params={};\n                              options.data.uri_params['user'] = user.toLowerCase(); },\n        \"method=\",\n        peg$literalExpectation(\"method=\", true),\n        function(method) {\n                              if(!options.data.uri_params) options.data.uri_params={};\n                              options.data.uri_params['method'] = method; },\n        \"ttl=\",\n        peg$literalExpectation(\"ttl=\", true),\n        function(ttl) {\n                              if(!options.data.params) options.data.params={};\n                              options.data.params['ttl'] = ttl; },\n        \"maddr=\",\n        peg$literalExpectation(\"maddr=\", true),\n        function(maddr) {\n                              if(!options.data.uri_params) options.data.uri_params={};\n                              options.data.uri_params['maddr'] = maddr; },\n        \"lr\",\n        peg$literalExpectation(\"lr\", true),\n        function() {\n                              if(!options.data.uri_params) options.data.uri_params={};\n                              options.data.uri_params['lr'] = undefined; },\n        function(param, value) {\n                              if(!options.data.uri_params) options.data.uri_params = {};\n                              if (value === null){\n                                value = undefined;\n                              }\n                              else {\n                                value = value[1];\n                              }\n                              options.data.uri_params[param.toLowerCase()] = value;},\n        function(hname, hvalue) {\n                              hname = hname.join('').toLowerCase();\n                              hvalue = hvalue.join('');\n                              if(!options.data.uri_headers) options.data.uri_headers = {};\n                              if (!options.data.uri_headers[hname]) {\n                                options.data.uri_headers[hname] = [hvalue];\n                              } else {\n                                options.data.uri_headers[hname].push(hvalue);\n                              }},\n        function() {\n                              // lots of tests fail if this isn't guarded...\n                              if (options.startRule === 'Refer_To') {\n                                options.data.uri = new options.SIP.URI(options.data.scheme, options.data.user, options.data.host, options.data.port, options.data.uri_params, options.data.uri_headers);\n                                delete options.data.scheme;\n                                delete options.data.user;\n                                delete options.data.host;\n                                delete options.data.host_type;\n                                delete options.data.port;\n                                delete options.data.uri_params;\n                              }\n                            },\n        \"//\",\n        peg$literalExpectation(\"//\", false),\n        function() {\n                            options.data.scheme= text(); },\n        peg$literalExpectation(\"SIP\", true),\n        function() {\n                            options.data.sip_version = text(); },\n        \"INVITE\",\n        peg$literalExpectation(\"INVITE\", false),\n        \"ACK\",\n        peg$literalExpectation(\"ACK\", false),\n        \"VXACH\",\n        peg$literalExpectation(\"VXACH\", false),\n        \"OPTIONS\",\n        peg$literalExpectation(\"OPTIONS\", false),\n        \"BYE\",\n        peg$literalExpectation(\"BYE\", false),\n        \"CANCEL\",\n        peg$literalExpectation(\"CANCEL\", false),\n        \"REGISTER\",\n        peg$literalExpectation(\"REGISTER\", false),\n        \"SUBSCRIBE\",\n        peg$literalExpectation(\"SUBSCRIBE\", false),\n        \"NOTIFY\",\n        peg$literalExpectation(\"NOTIFY\", false),\n        \"REFER\",\n        peg$literalExpectation(\"REFER\", false),\n        \"PUBLISH\",\n        peg$literalExpectation(\"PUBLISH\", false),\n        function() {\n\n                            options.data.method = text();\n                            return options.data.method; },\n        function(status_code) {\n                          options.data.status_code = parseInt(status_code.join('')); },\n        function() {\n                          options.data.reason_phrase = text(); },\n        function() {\n                      options.data = text(); },\n        function() {\n                                var idx, length;\n                                length = options.data.multi_header.length;\n                                for (idx = 0; idx < length; idx++) {\n                                  if (options.data.multi_header[idx].parsed === null) {\n                                    options.data = null;\n                                    break;\n                                  }\n                                }\n                                if (options.data !== null) {\n                                  options.data = options.data.multi_header;\n                                } else {\n                                  options.data = -1;\n                                }},\n        function() {\n                                var header;\n                                if(!options.data.multi_header) options.data.multi_header = [];\n                                try {\n                                  header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                                  delete options.data.uri;\n                                  delete options.data.displayName;\n                                  delete options.data.params;\n                                } catch(e) {\n                                  header = null;\n                                }\n                                options.data.multi_header.push( { 'position': peg$currPos,\n                                                          'offset': location().start.offset,\n                                                          'parsed': header\n                                                        });},\n        function(displayName) {\n                                displayName = text().trim();\n                                if (displayName[0] === '\\\"') {\n                                  displayName = displayName.substring(1, displayName.length-1);\n                                }\n                                options.data.displayName = displayName; },\n        \"q\",\n        peg$literalExpectation(\"q\", true),\n        function(q) {\n                                if(!options.data.params) options.data.params = {};\n                                options.data.params['q'] = q; },\n        \"expires\",\n        peg$literalExpectation(\"expires\", true),\n        function(expires) {\n                                if(!options.data.params) options.data.params = {};\n                                options.data.params['expires'] = expires; },\n        function(delta_seconds) {\n                                return parseInt(delta_seconds.join('')); },\n        \"0\",\n        peg$literalExpectation(\"0\", false),\n        function() {\n                                return parseFloat(text()); },\n        function(param, value) {\n                                if(!options.data.params) options.data.params = {};\n                                if (value === null){\n                                  value = undefined;\n                                }\n                                else {\n                                  value = value[1];\n                                }\n                                options.data.params[param.toLowerCase()] = value;},\n        \"render\",\n        peg$literalExpectation(\"render\", true),\n        \"session\",\n        peg$literalExpectation(\"session\", true),\n        \"icon\",\n        peg$literalExpectation(\"icon\", true),\n        \"alert\",\n        peg$literalExpectation(\"alert\", true),\n        function() {\n                                    if (options.startRule === 'Content_Disposition') {\n                                      options.data.type = text().toLowerCase();\n                                    }\n                                  },\n        \"handling\",\n        peg$literalExpectation(\"handling\", true),\n        \"optional\",\n        peg$literalExpectation(\"optional\", true),\n        \"required\",\n        peg$literalExpectation(\"required\", true),\n        function(length) {\n                                options.data = parseInt(length.join('')); },\n        function() {\n                                options.data = text(); },\n        \"text\",\n        peg$literalExpectation(\"text\", true),\n        \"image\",\n        peg$literalExpectation(\"image\", true),\n        \"audio\",\n        peg$literalExpectation(\"audio\", true),\n        \"video\",\n        peg$literalExpectation(\"video\", true),\n        \"application\",\n        peg$literalExpectation(\"application\", true),\n        \"message\",\n        peg$literalExpectation(\"message\", true),\n        \"multipart\",\n        peg$literalExpectation(\"multipart\", true),\n        \"x-\",\n        peg$literalExpectation(\"x-\", true),\n        function(cseq_value) {\n                          options.data.value=parseInt(cseq_value.join('')); },\n        function(expires) {options.data = expires; },\n        function(event_type) {\n                               options.data.event = event_type.toLowerCase(); },\n        function() {\n                        var tag = options.data.tag;\n                          options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                          if (tag) {options.data.setParam('tag',tag)}\n                        },\n        \"tag\",\n        peg$literalExpectation(\"tag\", true),\n        function(tag) {options.data.tag = tag; },\n        function(forwards) {\n                          options.data = parseInt(forwards.join('')); },\n        function(min_expires) {options.data = min_expires; },\n        function() {\n                                options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                              },\n        \"digest\",\n        peg$literalExpectation(\"Digest\", true),\n        \"realm\",\n        peg$literalExpectation(\"realm\", true),\n        function(realm) { options.data.realm = realm; },\n        \"domain\",\n        peg$literalExpectation(\"domain\", true),\n        \"nonce\",\n        peg$literalExpectation(\"nonce\", true),\n        function(nonce) { options.data.nonce=nonce; },\n        \"opaque\",\n        peg$literalExpectation(\"opaque\", true),\n        function(opaque) { options.data.opaque=opaque; },\n        \"stale\",\n        peg$literalExpectation(\"stale\", true),\n        \"true\",\n        peg$literalExpectation(\"true\", true),\n        function() { options.data.stale=true; },\n        \"false\",\n        peg$literalExpectation(\"false\", true),\n        function() { options.data.stale=false; },\n        \"algorithm\",\n        peg$literalExpectation(\"algorithm\", true),\n        \"md5\",\n        peg$literalExpectation(\"MD5\", true),\n        \"md5-sess\",\n        peg$literalExpectation(\"MD5-sess\", true),\n        function(algorithm) {\n                              options.data.algorithm=algorithm.toUpperCase(); },\n        \"qop\",\n        peg$literalExpectation(\"qop\", true),\n        \"auth-int\",\n        peg$literalExpectation(\"auth-int\", true),\n        \"auth\",\n        peg$literalExpectation(\"auth\", true),\n        function(qop_value) {\n                                options.data.qop || (options.data.qop=[]);\n                                options.data.qop.push(qop_value.toLowerCase()); },\n        function(rack_value) {\n                          options.data.value=parseInt(rack_value.join('')); },\n        function() {\n                          var idx, length;\n                          length = options.data.multi_header.length;\n                          for (idx = 0; idx < length; idx++) {\n                            if (options.data.multi_header[idx].parsed === null) {\n                              options.data = null;\n                              break;\n                            }\n                          }\n                          if (options.data !== null) {\n                            options.data = options.data.multi_header;\n                          } else {\n                            options.data = -1;\n                          }},\n        function() {\n                          var header;\n                          if(!options.data.multi_header) options.data.multi_header = [];\n                          try {\n                            header = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                            delete options.data.uri;\n                            delete options.data.displayName;\n                            delete options.data.params;\n                          } catch(e) {\n                            header = null;\n                          }\n                          options.data.multi_header.push( { 'position': peg$currPos,\n                                                    'offset': location().start.offset,\n                                                    'parsed': header\n                                                  });},\n        function() {\n                      options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                    },\n        function() {\n                              if (!(options.data.replaces_from_tag && options.data.replaces_to_tag)) {\n                                options.data = -1;\n                              }\n                            },\n        function() {\n                              options.data = {\n                                call_id: options.data\n                              };\n                            },\n        \"from-tag\",\n        peg$literalExpectation(\"from-tag\", true),\n        function(from_tag) {\n                              options.data.replaces_from_tag = from_tag;\n                            },\n        \"to-tag\",\n        peg$literalExpectation(\"to-tag\", true),\n        function(to_tag) {\n                              options.data.replaces_to_tag = to_tag;\n                            },\n        \"early-only\",\n        peg$literalExpectation(\"early-only\", true),\n        function() {\n                              options.data.early_only = true;\n                            },\n        function(head, r) {return r;},\n        function(head, tail) { return list(head, tail); },\n        function(value) {\n                        if (options.startRule === 'Require') {\n                          options.data = value || [];\n                        }\n                      },\n        function(rseq_value) {\n                          options.data.value=parseInt(rseq_value.join('')); },\n        \"active\",\n        peg$literalExpectation(\"active\", true),\n        \"pending\",\n        peg$literalExpectation(\"pending\", true),\n        \"terminated\",\n        peg$literalExpectation(\"terminated\", true),\n        function() {\n                                options.data.state = text(); },\n        \"reason\",\n        peg$literalExpectation(\"reason\", true),\n        function(reason) {\n                                if (typeof reason !== 'undefined') options.data.reason = reason; },\n        function(expires) {\n                                if (typeof expires !== 'undefined') options.data.expires = expires; },\n        \"retry_after\",\n        peg$literalExpectation(\"retry_after\", true),\n        function(retry_after) {\n                                if (typeof retry_after !== 'undefined') options.data.retry_after = retry_after; },\n        \"deactivated\",\n        peg$literalExpectation(\"deactivated\", true),\n        \"probation\",\n        peg$literalExpectation(\"probation\", true),\n        \"rejected\",\n        peg$literalExpectation(\"rejected\", true),\n        \"timeout\",\n        peg$literalExpectation(\"timeout\", true),\n        \"giveup\",\n        peg$literalExpectation(\"giveup\", true),\n        \"noresource\",\n        peg$literalExpectation(\"noresource\", true),\n        \"invariant\",\n        peg$literalExpectation(\"invariant\", true),\n        function(value) {\n                        if (options.startRule === 'Supported') {\n                          options.data = value || [];\n                        }\n                      },\n        function() {\n                      var tag = options.data.tag;\n                        options.data = new options.SIP.NameAddrHeader(options.data.uri, options.data.displayName, options.data.params);\n                        if (tag) {options.data.setParam('tag',tag)}\n                      },\n        \"ttl\",\n        peg$literalExpectation(\"ttl\", true),\n        function(via_ttl_value) {\n                              options.data.ttl = via_ttl_value; },\n        \"maddr\",\n        peg$literalExpectation(\"maddr\", true),\n        function(via_maddr) {\n                              options.data.maddr = via_maddr; },\n        \"received\",\n        peg$literalExpectation(\"received\", true),\n        function(via_received) {\n                              options.data.received = via_received; },\n        \"branch\",\n        peg$literalExpectation(\"branch\", true),\n        function(via_branch) {\n                              options.data.branch = via_branch; },\n        \"rport\",\n        peg$literalExpectation(\"rport\", true),\n        function() {\n                              if(typeof response_port !== 'undefined')\n                                options.data.rport = response_port.join(''); },\n        function(via_protocol) {\n                              options.data.protocol = via_protocol; },\n        peg$literalExpectation(\"UDP\", true),\n        peg$literalExpectation(\"TCP\", true),\n        peg$literalExpectation(\"TLS\", true),\n        peg$literalExpectation(\"SCTP\", true),\n        function(via_transport) {\n                              options.data.transport = via_transport; },\n        function() {\n                              options.data.host = text(); },\n        function(via_sent_by_port) {\n                              options.data.port = parseInt(via_sent_by_port.join('')); },\n        function(ttl) {\n                              return parseInt(ttl.join('')); },\n        function(deltaSeconds) {\n                              if (options.startRule === 'Session_Expires') {\n                                options.data.deltaSeconds = deltaSeconds;\n                              }\n                            },\n        \"refresher\",\n        peg$literalExpectation(\"refresher\", false),\n        \"uas\",\n        peg$literalExpectation(\"uas\", false),\n        \"uac\",\n        peg$literalExpectation(\"uac\", false),\n        function(endpoint) {\n                              if (options.startRule === 'Session_Expires') {\n                                options.data.refresher = endpoint;\n                              }\n                            },\n        function(deltaSeconds) {\n                              if (options.startRule === 'Min_SE') {\n                                options.data = deltaSeconds;\n                              }\n                            },\n        \"stuns\",\n        peg$literalExpectation(\"stuns\", true),\n        \"stun\",\n        peg$literalExpectation(\"stun\", true),\n        function(scheme) {\n                              options.data.scheme = scheme; },\n        function(host) {\n                              options.data.host = host; },\n        \"?transport=\",\n        peg$literalExpectation(\"?transport=\", false),\n        \"turns\",\n        peg$literalExpectation(\"turns\", true),\n        \"turn\",\n        peg$literalExpectation(\"turn\", true),\n        function() {\n                              options.data.transport = transport; },\n        function() {\n                          options.data = text(); },\n        \"Referred-By\",\n        peg$literalExpectation(\"Referred-By\", false),\n        \"b\",\n        peg$literalExpectation(\"b\", false),\n        \"cid\",\n        peg$literalExpectation(\"cid\", false)\n      ],\n\n      peg$bytecode = [\n        peg$decode(\"2 \\\"\\\"6 7!\"),\n        peg$decode(\"4\\\"\\\"\\\"5!7#\"),\n        peg$decode(\"4$\\\"\\\"5!7%\"),\n        peg$decode(\"4&\\\"\\\"5!7'\"),\n        peg$decode(\";'.# &;(\"),\n        peg$decode(\"4(\\\"\\\"5!7)\"),\n        peg$decode(\"4*\\\"\\\"5!7+\"),\n        peg$decode(\"2,\\\"\\\"6,7-\"),\n        peg$decode(\"2.\\\"\\\"6.7/\"),\n        peg$decode(\"40\\\"\\\"5!71\"),\n        peg$decode(\"22\\\"\\\"6273.\\x89 &24\\\"\\\"6475.} &26\\\"\\\"6677.q &28\\\"\\\"6879.e &2:\\\"\\\"6:7;.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E\"),\n        peg$decode(\";).# &;,\"),\n        peg$decode(\"2F\\\"\\\"6F7G.} &2H\\\"\\\"6H7I.q &2J\\\"\\\"6J7K.e &2L\\\"\\\"6L7M.Y &2N\\\"\\\"6N7O.M &2P\\\"\\\"6P7Q.A &2R\\\"\\\"6R7S.5 &2T\\\"\\\"6T7U.) &2V\\\"\\\"6V7W\"),\n        peg$decode(\"%%2X\\\"\\\"6X7Y/5#;#/,$;#/#$+#)(#'#(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"%%$;$0#*;$&/,#; /#$+\\\")(\\\"'#&'#.\\\" &\\\"/=#$;$/&#0#*;$&&&#/'$8\\\":Z\\\" )(\\\"'#&'#\"),\n        peg$decode(\";..\\\" &\\\"\"),\n        peg$decode(\"%$;'.# &;(0)*;'.# &;(&/?#28\\\"\\\"6879/0$;//'$8#:[# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%%$;2/&#0#*;2&&&#/g#$%$;.0#*;.&/,#;2/#$+\\\")(\\\"'#&'#0=*%$;.0#*;.&/,#;2/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"4\\\\\\\"\\\"5!7].# &;3\"),\n        peg$decode(\"4^\\\"\\\"5!7_\"),\n        peg$decode(\"4`\\\"\\\"5!7a\"),\n        peg$decode(\";!.) &4b\\\"\\\"5!7c\"),\n        peg$decode(\"%$;).\\x95 &2F\\\"\\\"6F7G.\\x89 &2J\\\"\\\"6J7K.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O/\\x9E#0\\x9B*;).\\x95 &2F\\\"\\\"6F7G.\\x89 &2J\\\"\\\"6J7K.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O&&&#/\\\"!&,)\"),\n        peg$decode(\"%$;).\\x89 &2F\\\"\\\"6F7G.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O/\\x92#0\\x8F*;).\\x89 &2F\\\"\\\"6F7G.} &2L\\\"\\\"6L7M.q &2X\\\"\\\"6X7Y.e &2P\\\"\\\"6P7Q.Y &2H\\\"\\\"6H7I.M &2@\\\"\\\"6@7A.A &2d\\\"\\\"6d7e.5 &2R\\\"\\\"6R7S.) &2N\\\"\\\"6N7O&&&#/\\\"!&,)\"),\n        peg$decode(\"2T\\\"\\\"6T7U.\\xE3 &2V\\\"\\\"6V7W.\\xD7 &2f\\\"\\\"6f7g.\\xCB &2h\\\"\\\"6h7i.\\xBF &2:\\\"\\\"6:7;.\\xB3 &2D\\\"\\\"6D7E.\\xA7 &22\\\"\\\"6273.\\x9B &28\\\"\\\"6879.\\x8F &2j\\\"\\\"6j7k.\\x83 &;&.} &24\\\"\\\"6475.q &2l\\\"\\\"6l7m.e &2n\\\"\\\"6n7o.Y &26\\\"\\\"6677.M &2>\\\"\\\"6>7?.A &2p\\\"\\\"6p7q.5 &2r\\\"\\\"6r7s.) &;'.# &;(\"),\n        peg$decode(\"%$;).\\u012B &2F\\\"\\\"6F7G.\\u011F &2J\\\"\\\"6J7K.\\u0113 &2L\\\"\\\"6L7M.\\u0107 &2X\\\"\\\"6X7Y.\\xFB &2P\\\"\\\"6P7Q.\\xEF &2H\\\"\\\"6H7I.\\xE3 &2@\\\"\\\"6@7A.\\xD7 &2d\\\"\\\"6d7e.\\xCB &2R\\\"\\\"6R7S.\\xBF &2N\\\"\\\"6N7O.\\xB3 &2T\\\"\\\"6T7U.\\xA7 &2V\\\"\\\"6V7W.\\x9B &2f\\\"\\\"6f7g.\\x8F &2h\\\"\\\"6h7i.\\x83 &28\\\"\\\"6879.w &2j\\\"\\\"6j7k.k &;&.e &24\\\"\\\"6475.Y &2l\\\"\\\"6l7m.M &2n\\\"\\\"6n7o.A &26\\\"\\\"6677.5 &2p\\\"\\\"6p7q.) &2r\\\"\\\"6r7s/\\u0134#0\\u0131*;).\\u012B &2F\\\"\\\"6F7G.\\u011F &2J\\\"\\\"6J7K.\\u0113 &2L\\\"\\\"6L7M.\\u0107 &2X\\\"\\\"6X7Y.\\xFB &2P\\\"\\\"6P7Q.\\xEF &2H\\\"\\\"6H7I.\\xE3 &2@\\\"\\\"6@7A.\\xD7 &2d\\\"\\\"6d7e.\\xCB &2R\\\"\\\"6R7S.\\xBF &2N\\\"\\\"6N7O.\\xB3 &2T\\\"\\\"6T7U.\\xA7 &2V\\\"\\\"6V7W.\\x9B &2f\\\"\\\"6f7g.\\x8F &2h\\\"\\\"6h7i.\\x83 &28\\\"\\\"6879.w &2j\\\"\\\"6j7k.k &;&.e &24\\\"\\\"6475.Y &2l\\\"\\\"6l7m.M &2n\\\"\\\"6n7o.A &26\\\"\\\"6677.5 &2p\\\"\\\"6p7q.) &2r\\\"\\\"6r7s&&&#/\\\"!&,)\"),\n        peg$decode(\"%;//?#2P\\\"\\\"6P7Q/0$;//'$8#:t# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#24\\\"\\\"6475/0$;//'$8#:u# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2>\\\"\\\"6>7?/0$;//'$8#:v# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2T\\\"\\\"6T7U/0$;//'$8#:w# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2V\\\"\\\"6V7W/0$;//'$8#:x# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%2h\\\"\\\"6h7i/0#;//'$8\\\":y\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;//6#2f\\\"\\\"6f7g/'$8\\\":z\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;//?#2D\\\"\\\"6D7E/0$;//'$8#:{# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#22\\\"\\\"6273/0$;//'$8#:|# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//?#28\\\"\\\"6879/0$;//'$8#:}# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;//0#;&/'$8\\\":~\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;&/0#;//'$8\\\":~\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;=/T#$;G.) &;K.# &;F0/*;G.) &;K.# &;F&/,$;>/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"4\\x7F\\\"\\\"5!7\\x80.A &4\\x81\\\"\\\"5!7\\x82.5 &4\\x83\\\"\\\"5!7\\x84.) &;3.# &;.\"),\n        peg$decode(\"%%;//Q#;&/H$$;J.# &;K0)*;J.# &;K&/,$;&/#$+$)($'#(#'#(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"%;//]#;&/T$%$;J.# &;K0)*;J.# &;K&/\\\"!&,)/1$;&/($8$:\\x85$!!)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";..G &2L\\\"\\\"6L7M.; &4\\x86\\\"\\\"5!7\\x87./ &4\\x83\\\"\\\"5!7\\x84.# &;3\"),\n        peg$decode(\"%2j\\\"\\\"6j7k/J#4\\x88\\\"\\\"5!7\\x89.5 &4\\x8A\\\"\\\"5!7\\x8B.) &4\\x8C\\\"\\\"5!7\\x8D/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;N/M#28\\\"\\\"6879/>$;O.\\\" &\\\"/0$;S/'$8$:\\x8E$ )($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;N/d#28\\\"\\\"6879/U$;O.\\\" &\\\"/G$;S/>$;_/5$;l.\\\" &\\\"/'$8&:\\x8F& )(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\x90\\\"\\\"5$7\\x91.) &3\\x92\\\"\\\"5#7\\x93/' 8!:\\x94!! )\"),\n        peg$decode(\"%;P/]#%28\\\"\\\"6879/,#;R/#$+\\\")(\\\"'#&'#.\\\" &\\\"/6$2:\\\"\\\"6:7;/'$8#:\\x95# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"$;+.) &;-.# &;Q/2#0/*;+.) &;-.# &;Q&&&#\"),\n        peg$decode(\"2<\\\"\\\"6<7=.q &2>\\\"\\\"6>7?.e &2@\\\"\\\"6@7A.Y &2B\\\"\\\"6B7C.M &2D\\\"\\\"6D7E.A &22\\\"\\\"6273.5 &26\\\"\\\"6677.) &24\\\"\\\"6475\"),\n        peg$decode(\"%$;+._ &;-.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E0e*;+._ &;-.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E&/& 8!:\\x96! )\"),\n        peg$decode(\"%;T/J#%28\\\"\\\"6879/,#;^/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;U.) &;\\\\.# &;X/& 8!:\\x97! )\"),\n        peg$decode(\"%$%;V/2#2J\\\"\\\"6J7K/#$+\\\")(\\\"'#&'#0<*%;V/2#2J\\\"\\\"6J7K/#$+\\\")(\\\"'#&'#&/D#;W/;$2J\\\"\\\"6J7K.\\\" &\\\"/'$8#:\\x98# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"$4\\x99\\\"\\\"5!7\\x9A/,#0)*4\\x99\\\"\\\"5!7\\x9A&&&#\"),\n        peg$decode(\"%4$\\\"\\\"5!7%/?#$4\\x9B\\\"\\\"5!7\\x9C0)*4\\x9B\\\"\\\"5!7\\x9C&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%2l\\\"\\\"6l7m/?#;Y/6$2n\\\"\\\"6n7o/'$8#:\\x9D# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%%;Z/\\xB3#28\\\"\\\"6879/\\xA4$;Z/\\x9B$28\\\"\\\"6879/\\x8C$;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+-)(-'#(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0790 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/\\xA4#;Z/\\x9B$28\\\"\\\"6879/\\x8C$;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+,)(,'#(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u06F9 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/\\x8C#;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u067A &%2\\x9E\\\"\\\"6\\x9E7\\x9F/t#;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0613 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/\\\\#;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+&)(&'#(%'#($'#(#'#(\\\"'#&'#.\\u05C4 &%2\\x9E\\\"\\\"6\\x9E7\\x9F/D#;Z/;$28\\\"\\\"6879/,$;[/#$+$)($'#(#'#(\\\"'#&'#.\\u058D &%2\\x9E\\\"\\\"6\\x9E7\\x9F/,#;[/#$+\\\")(\\\"'#&'#.\\u056E &%2\\x9E\\\"\\\"6\\x9E7\\x9F/,#;Z/#$+\\\")(\\\"'#&'#.\\u054F &%;Z/\\x9B#2\\x9E\\\"\\\"6\\x9E7\\x9F/\\x8C$;Z/\\x83$28\\\"\\\"6879/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$++)(+'#(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u04C7 &%;Z/\\xAA#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x83$2\\x9E\\\"\\\"6\\x9E7\\x9F/t$;Z/k$28\\\"\\\"6879/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+*)(*'#()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0430 &%;Z/\\xB9#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x92$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/k$2\\x9E\\\"\\\"6\\x9E7\\x9F/\\\\$;Z/S$28\\\"\\\"6879/D$;Z/;$28\\\"\\\"6879/,$;[/#$+))()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u038A &%;Z/\\xC8#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xA1$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/z$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/S$2\\x9E\\\"\\\"6\\x9E7\\x9F/D$;Z/;$28\\\"\\\"6879/,$;[/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u02D5 &%;Z/\\xD7#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xB0$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x89$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/b$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/;$2\\x9E\\\"\\\"6\\x9E7\\x9F/,$;[/#$+')(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0211 &%;Z/\\xFE#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xD7$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xB0$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x89$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/b$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/;$2\\x9E\\\"\\\"6\\x9E7\\x9F/,$;Z/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#.\\u0126 &%;Z/\\u011C#%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xF5$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xCE$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\xA7$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/\\x80$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/Y$%28\\\"\\\"6879/,#;Z/#$+\\\")(\\\"'#&'#.\\\" &\\\"/2$2\\x9E\\\"\\\"6\\x9E7\\x9F/#$+()(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#/& 8!:\\xA0! )\"),\n        peg$decode(\"%;#/M#;#.\\\" &\\\"/?$;#.\\\" &\\\"/1$;#.\\\" &\\\"/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;Z/;#28\\\"\\\"6879/,$;Z/#$+#)(#'#(\\\"'#&'#.# &;\\\\\"),\n        peg$decode(\"%;]/o#2J\\\"\\\"6J7K/`$;]/W$2J\\\"\\\"6J7K/H$;]/?$2J\\\"\\\"6J7K/0$;]/'$8':\\xA1' )(''#(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%2\\xA2\\\"\\\"6\\xA27\\xA3/2#4\\xA4\\\"\\\"5!7\\xA5/#$+\\\")(\\\"'#&'#.\\x98 &%2\\xA6\\\"\\\"6\\xA67\\xA7/;#4\\xA8\\\"\\\"5!7\\xA9/,$;!/#$+#)(#'#(\\\"'#&'#.j &%2\\xAA\\\"\\\"6\\xAA7\\xAB/5#;!/,$;!/#$+#)(#'#(\\\"'#&'#.B &%4\\xAC\\\"\\\"5!7\\xAD/,#;!/#$+\\\")(\\\"'#&'#.# &;!\"),\n        peg$decode(\"%%;!.\\\" &\\\"/[#;!.\\\" &\\\"/M$;!.\\\" &\\\"/?$;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+%)(%'#($'#(#'#(\\\"'#&'#/' 8!:\\xAE!! )\"),\n        peg$decode(\"$%22\\\"\\\"6273/,#;`/#$+\\\")(\\\"'#&'#0<*%22\\\"\\\"6273/,#;`/#$+\\\")(\\\"'#&'#&\"),\n        peg$decode(\";a.A &;b.; &;c.5 &;d./ &;e.) &;f.# &;g\"),\n        peg$decode(\"%3\\xAF\\\"\\\"5*7\\xB0/a#3\\xB1\\\"\\\"5#7\\xB2.G &3\\xB3\\\"\\\"5#7\\xB4.; &3\\xB5\\\"\\\"5$7\\xB6./ &3\\xB7\\\"\\\"5#7\\xB8.# &;6/($8\\\":\\xB9\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xBA\\\"\\\"5%7\\xBB/I#3\\xBC\\\"\\\"5%7\\xBD./ &3\\xBE\\\"\\\"5\\\"7\\xBF.# &;6/($8\\\":\\xC0\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xC1\\\"\\\"5'7\\xC2/1#;\\x90/($8\\\":\\xC3\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xC4\\\"\\\"5$7\\xC5/1#;\\xF0/($8\\\":\\xC6\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xC7\\\"\\\"5&7\\xC8/1#;T/($8\\\":\\xC9\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%3\\xCA\\\"\\\"5\\\"7\\xCB/N#%2>\\\"\\\"6>7?/,#;6/#$+\\\")(\\\"'#&'#.\\\" &\\\"/'$8\\\":\\xCC\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;h/P#%2>\\\"\\\"6>7?/,#;i/#$+\\\")(\\\"'#&'#.\\\" &\\\"/)$8\\\":\\xCD\\\"\\\"! )(\\\"'#&'#\"),\n        peg$decode(\"%$;j/&#0#*;j&&&#/\\\"!&,)\"),\n        peg$decode(\"%$;j/&#0#*;j&&&#/\\\"!&,)\"),\n        peg$decode(\";k.) &;+.# &;-\"),\n        peg$decode(\"2l\\\"\\\"6l7m.e &2n\\\"\\\"6n7o.Y &24\\\"\\\"6475.M &28\\\"\\\"6879.A &2<\\\"\\\"6<7=.5 &2@\\\"\\\"6@7A.) &2B\\\"\\\"6B7C\"),\n        peg$decode(\"%26\\\"\\\"6677/n#;m/e$$%2<\\\"\\\"6<7=/,#;m/#$+\\\")(\\\"'#&'#0<*%2<\\\"\\\"6<7=/,#;m/#$+\\\")(\\\"'#&'#&/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;n/A#2>\\\"\\\"6>7?/2$;o/)$8#:\\xCE#\\\"\\\" )(#'#(\\\"'#&'#\"),\n        peg$decode(\"$;p.) &;+.# &;-/2#0/*;p.) &;+.# &;-&&&#\"),\n        peg$decode(\"$;p.) &;+.# &;-0/*;p.) &;+.# &;-&\"),\n        peg$decode(\"2l\\\"\\\"6l7m.e &2n\\\"\\\"6n7o.Y &24\\\"\\\"6475.M &26\\\"\\\"6677.A &28\\\"\\\"6879.5 &2@\\\"\\\"6@7A.) &2B\\\"\\\"6B7C\"),\n        peg$decode(\";\\x91.# &;r\"),\n        peg$decode(\"%;\\x90/G#;'/>$;s/5$;'/,$;\\x84/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";M.# &;t\"),\n        peg$decode(\"%;\\x7F/E#28\\\"\\\"6879/6$;u.# &;x/'$8#:\\xCF# )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;v.# &;w/J#%26\\\"\\\"6677/,#;\\x83/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%2\\xD0\\\"\\\"6\\xD07\\xD1/:#;\\x80/1$;w.\\\" &\\\"/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%24\\\"\\\"6475/,#;{/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;z/3#$;y0#*;y&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\";*.) &;+.# &;-\"),\n        peg$decode(\";+.\\x8F &;-.\\x89 &22\\\"\\\"6273.} &26\\\"\\\"6677.q &28\\\"\\\"6879.e &2:\\\"\\\"6:7;.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E\"),\n        peg$decode(\"%;|/e#$%24\\\"\\\"6475/,#;|/#$+\\\")(\\\"'#&'#0<*%24\\\"\\\"6475/,#;|/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%$;~0#*;~&/e#$%22\\\"\\\"6273/,#;}/#$+\\\")(\\\"'#&'#0<*%22\\\"\\\"6273/,#;}/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"$;~0#*;~&\"),\n        peg$decode(\";+.w &;-.q &28\\\"\\\"6879.e &2:\\\"\\\"6:7;.Y &2<\\\"\\\"6<7=.M &2>\\\"\\\"6>7?.A &2@\\\"\\\"6@7A.5 &2B\\\"\\\"6B7C.) &2D\\\"\\\"6D7E\"),\n        peg$decode(\"%%;\\\"/\\x87#$;\\\".G &;!.A &2@\\\"\\\"6@7A.5 &2F\\\"\\\"6F7G.) &2J\\\"\\\"6J7K0M*;\\\".G &;!.A &2@\\\"\\\"6@7A.5 &2F\\\"\\\"6F7G.) &2J\\\"\\\"6J7K&/#$+\\\")(\\\"'#&'#/& 8!:\\xD2! )\"),\n        peg$decode(\";\\x81.# &;\\x82\"),\n        peg$decode(\"%%;O/2#2:\\\"\\\"6:7;/#$+\\\")(\\\"'#&'#.\\\" &\\\"/,#;S/#$+\\\")(\\\"'#&'#.\\\" &\\\"\"),\n        peg$decode(\"$;+.\\x83 &;-.} &2B\\\"\\\"6B7C.q &2D\\\"\\\"6D7E.e &22\\\"\\\"6273.Y &28\\\"\\\"6879.M &2:\\\"\\\"6:7;.A &2<\\\"\\\"6<7=.5 &2>\\\"\\\"6>7?.) &2@\\\"\\\"6@7A/\\x8C#0\\x89*;+.\\x83 &;-.} &2B\\\"\\\"6B7C.q &2D\\\"\\\"6D7E.e &22\\\"\\\"6273.Y &28\\\"\\\"6879.M &2:\\\"\\\"6:7;.A &2<\\\"\\\"6<7=.5 &2>\\\"\\\"6>7?.) &2@\\\"\\\"6@7A&&&#\"),\n        peg$decode(\"$;y0#*;y&\"),\n        peg$decode(\"%3\\x92\\\"\\\"5#7\\xD3/q#24\\\"\\\"6475/b$$;!/&#0#*;!&&&#/L$2J\\\"\\\"6J7K/=$$;!/&#0#*;!&&&#/'$8%:\\xD4% )(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"2\\xD5\\\"\\\"6\\xD57\\xD6\"),\n        peg$decode(\"2\\xD7\\\"\\\"6\\xD77\\xD8\"),\n        peg$decode(\"2\\xD9\\\"\\\"6\\xD97\\xDA\"),\n        peg$decode(\"2\\xDB\\\"\\\"6\\xDB7\\xDC\"),\n        peg$decode(\"2\\xDD\\\"\\\"6\\xDD7\\xDE\"),\n        peg$decode(\"2\\xDF\\\"\\\"6\\xDF7\\xE0\"),\n        peg$decode(\"2\\xE1\\\"\\\"6\\xE17\\xE2\"),\n        peg$decode(\"2\\xE3\\\"\\\"6\\xE37\\xE4\"),\n        peg$decode(\"2\\xE5\\\"\\\"6\\xE57\\xE6\"),\n        peg$decode(\"2\\xE7\\\"\\\"6\\xE77\\xE8\"),\n        peg$decode(\"2\\xE9\\\"\\\"6\\xE97\\xEA\"),\n        peg$decode(\"%;\\x85.Y &;\\x86.S &;\\x88.M &;\\x89.G &;\\x8A.A &;\\x8B.; &;\\x8C.5 &;\\x8F./ &;\\x8D.) &;\\x8E.# &;6/& 8!:\\xEB! )\"),\n        peg$decode(\"%;\\x84/G#;'/>$;\\x92/5$;'/,$;\\x94/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\x93/' 8!:\\xEC!! )\"),\n        peg$decode(\"%;!/5#;!/,$;!/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(0G*;*.A &;+.; &;-.5 &;3./ &;4.) &;'.# &;(&/& 8!:\\xED! )\"),\n        peg$decode(\"%;\\xB6/Y#$%;A/,#;\\xB6/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xB6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;9/N#%2:\\\"\\\"6:7;/,#;9/#$+\\\")(\\\"'#&'#.\\\" &\\\"/'$8\\\":\\xEE\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;:.c &%;\\x98/Y#$%;A/,#;\\x98/#$+\\\")(\\\"'#&'#06*%;A/,#;\\x98/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/& 8!:\\xEF! )\"),\n        peg$decode(\"%;L.# &;\\x99/]#$%;B/,#;\\x9B/#$+\\\")(\\\"'#&'#06*%;B/,#;\\x9B/#$+\\\")(\\\"'#&'#&/'$8\\\":\\xF0\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\x9A.\\\" &\\\"/>#;@/5$;M/,$;?/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%%;6/Y#$%;./,#;6/#$+\\\")(\\\"'#&'#06*%;./,#;6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#.# &;H/' 8!:\\xF1!! )\"),\n        peg$decode(\";\\x9C.) &;\\x9D.# &;\\xA0\"),\n        peg$decode(\"%3\\xF2\\\"\\\"5!7\\xF3/:#;</1$;\\x9F/($8#:\\xF4#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\xF5\\\"\\\"5'7\\xF6/:#;</1$;\\x9E/($8#:\\xF7#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\xF8!! )\"),\n        peg$decode(\"%2\\xF9\\\"\\\"6\\xF97\\xFA/o#%2J\\\"\\\"6J7K/M#;!.\\\" &\\\"/?$;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+$)($'#(#'#(\\\"'#&'#.\\\" &\\\"/'$8\\\":\\xFB\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;6/J#%;</,#;\\xA1/#$+\\\")(\\\"'#&'#.\\\" &\\\"/)$8\\\":\\xFC\\\"\\\"! )(\\\"'#&'#\"),\n        peg$decode(\";6.) &;T.# &;H\"),\n        peg$decode(\"%;\\xA3/Y#$%;B/,#;\\xA4/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA4/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%3\\xFD\\\"\\\"5&7\\xFE.G &3\\xFF\\\"\\\"5'7\\u0100.; &3\\u0101\\\"\\\"5$7\\u0102./ &3\\u0103\\\"\\\"5%7\\u0104.# &;6/& 8!:\\u0105! )\"),\n        peg$decode(\";\\xA5.# &;\\xA0\"),\n        peg$decode(\"%3\\u0106\\\"\\\"5(7\\u0107/M#;</D$3\\u0108\\\"\\\"5(7\\u0109./ &3\\u010A\\\"\\\"5(7\\u010B.# &;6/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;6/Y#$%;A/,#;6/#$+\\\")(\\\"'#&'#06*%;A/,#;6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u010C!! )\"),\n        peg$decode(\"%;\\xA9/& 8!:\\u010D! )\"),\n        peg$decode(\"%;\\xAA/k#;;/b$;\\xAF/Y$$%;B/,#;\\xB0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xB0/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xAB.# &;\\xAC\"),\n        peg$decode(\"3\\u010E\\\"\\\"5$7\\u010F.S &3\\u0110\\\"\\\"5%7\\u0111.G &3\\u0112\\\"\\\"5%7\\u0113.; &3\\u0114\\\"\\\"5%7\\u0115./ &3\\u0116\\\"\\\"5+7\\u0117.# &;\\xAD\"),\n        peg$decode(\"3\\u0118\\\"\\\"5'7\\u0119./ &3\\u011A\\\"\\\"5)7\\u011B.# &;\\xAD\"),\n        peg$decode(\";6.# &;\\xAE\"),\n        peg$decode(\"%3\\u011C\\\"\\\"5\\\"7\\u011D/,#;6/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\";\\xAD.# &;6\"),\n        peg$decode(\"%;6/5#;</,$;\\xB1/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\";6.# &;H\"),\n        peg$decode(\"%;\\xB3/5#;./,$;\\x90/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u011E!! )\"),\n        peg$decode(\"%;\\x9E/' 8!:\\u011F!! )\"),\n        peg$decode(\"%;\\xB6/^#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/($8\\\":\\u0120\\\"!!)(\\\"'#&'#\"),\n        peg$decode(\"%%;7/e#$%2J\\\"\\\"6J7K/,#;7/#$+\\\")(\\\"'#&'#0<*%2J\\\"\\\"6J7K/,#;7/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/\\\"!&,)\"),\n        peg$decode(\"%;L.# &;\\x99/]#$%;B/,#;\\xB8/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xB8/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u0121\\\" )(\\\"'#&'#\"),\n        peg$decode(\";\\xB9.# &;\\xA0\"),\n        peg$decode(\"%3\\u0122\\\"\\\"5#7\\u0123/:#;</1$;6/($8#:\\u0124#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u0125!! )\"),\n        peg$decode(\"%;\\x9E/' 8!:\\u0126!! )\"),\n        peg$decode(\"%$;\\x9A0#*;\\x9A&/x#;@/o$;M/f$;?/]$$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/'$8%:\\u0127% )(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xBE\"),\n        peg$decode(\"%3\\u0128\\\"\\\"5&7\\u0129/k#;./b$;\\xC1/Y$$%;A/,#;\\xC1/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xC1/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#.# &;\\xBF\"),\n        peg$decode(\"%;6/k#;./b$;\\xC0/Y$$%;A/,#;\\xC0/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xC0/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;6/;#;</2$;6.# &;H/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xC2.G &;\\xC4.A &;\\xC6.; &;\\xC8.5 &;\\xC9./ &;\\xCA.) &;\\xCB.# &;\\xC0\"),\n        peg$decode(\"%3\\u012A\\\"\\\"5%7\\u012B/5#;</,$;\\xC3/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;I/' 8!:\\u012C!! )\"),\n        peg$decode(\"%3\\u012D\\\"\\\"5&7\\u012E/\\x97#;</\\x8E$;D/\\x85$;\\xC5/|$$%$;'/&#0#*;'&&&#/,#;\\xC5/#$+\\\")(\\\"'#&'#0C*%$;'/&#0#*;'&&&#/,#;\\xC5/#$+\\\")(\\\"'#&'#&/,$;E/#$+&)(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";t.# &;w\"),\n        peg$decode(\"%3\\u012F\\\"\\\"5%7\\u0130/5#;</,$;\\xC7/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;I/' 8!:\\u0131!! )\"),\n        peg$decode(\"%3\\u0132\\\"\\\"5&7\\u0133/:#;</1$;I/($8#:\\u0134#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0135\\\"\\\"5%7\\u0136/]#;</T$%3\\u0137\\\"\\\"5$7\\u0138/& 8!:\\u0139! ).4 &%3\\u013A\\\"\\\"5%7\\u013B/& 8!:\\u013C! )/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u013D\\\"\\\"5)7\\u013E/R#;</I$3\\u013F\\\"\\\"5#7\\u0140./ &3\\u0141\\\"\\\"5(7\\u0142.# &;6/($8#:\\u0143#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0144\\\"\\\"5#7\\u0145/\\x93#;</\\x8A$;D/\\x81$%;\\xCC/e#$%2D\\\"\\\"6D7E/,#;\\xCC/#$+\\\")(\\\"'#&'#0<*%2D\\\"\\\"6D7E/,#;\\xCC/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#/,$;E/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0146\\\"\\\"5(7\\u0147./ &3\\u0148\\\"\\\"5$7\\u0149.# &;6/' 8!:\\u014A!! )\"),\n        peg$decode(\"%;6/Y#$%;A/,#;6/#$+\\\")(\\\"'#&'#06*%;A/,#;6/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\xCF/G#;./>$;\\xCF/5$;./,$;\\x90/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u014B!! )\"),\n        peg$decode(\"%;\\xD1/]#$%;A/,#;\\xD1/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xD1/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014C\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\x99/]#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014D\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;L.O &;\\x99.I &%;@.\\\" &\\\"/:#;t/1$;?.\\\" &\\\"/#$+#)(#'#(\\\"'#&'#/]#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014E\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\xD4/]#$%;B/,#;\\xD5/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xD5/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u014F\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\x96/& 8!:\\u0150! )\"),\n        peg$decode(\"%3\\u0151\\\"\\\"5(7\\u0152/:#;</1$;6/($8#:\\u0153#! )(#'#(\\\"'#&'#.g &%3\\u0154\\\"\\\"5&7\\u0155/:#;</1$;6/($8#:\\u0156#! )(#'#(\\\"'#&'#.: &%3\\u0157\\\"\\\"5*7\\u0158/& 8!:\\u0159! ).# &;\\xA0\"),\n        peg$decode(\"%%;6/k#$%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#0<*%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#&/)$8\\\":\\u015B\\\"\\\"! )(\\\"'#&'#.\\\" &\\\"/' 8!:\\u015C!! )\"),\n        peg$decode(\"%;\\xD8/Y#$%;A/,#;\\xD8/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xD8/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\x99/Y#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%$;!/&#0#*;!&&&#/' 8!:\\u015D!! )\"),\n        peg$decode(\"%;\\xDB/Y#$%;B/,#;\\xDC/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xDC/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%3\\u015E\\\"\\\"5&7\\u015F.; &3\\u0160\\\"\\\"5'7\\u0161./ &3\\u0162\\\"\\\"5*7\\u0163.# &;6/& 8!:\\u0164! )\"),\n        peg$decode(\"%3\\u0165\\\"\\\"5&7\\u0166/:#;</1$;\\xDD/($8#:\\u0167#! )(#'#(\\\"'#&'#.} &%3\\xF5\\\"\\\"5'7\\xF6/:#;</1$;\\x9E/($8#:\\u0168#! )(#'#(\\\"'#&'#.P &%3\\u0169\\\"\\\"5+7\\u016A/:#;</1$;\\x9E/($8#:\\u016B#! )(#'#(\\\"'#&'#.# &;\\xA0\"),\n        peg$decode(\"3\\u016C\\\"\\\"5+7\\u016D.k &3\\u016E\\\"\\\"5)7\\u016F._ &3\\u0170\\\"\\\"5(7\\u0171.S &3\\u0172\\\"\\\"5'7\\u0173.G &3\\u0174\\\"\\\"5&7\\u0175.; &3\\u0176\\\"\\\"5*7\\u0177./ &3\\u0178\\\"\\\"5)7\\u0179.# &;6\"),\n        peg$decode(\";1.\\\" &\\\"\"),\n        peg$decode(\"%%;6/k#$%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#0<*%;A/2#;6/)$8\\\":\\u015A\\\"\\\"$ )(\\\"'#&'#&/)$8\\\":\\u015B\\\"\\\"! )(\\\"'#&'#.\\\" &\\\"/' 8!:\\u017A!! )\"),\n        peg$decode(\"%;L.# &;\\x99/]#$%;B/,#;\\xE1/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xE1/#$+\\\")(\\\"'#&'#&/'$8\\\":\\u017B\\\" )(\\\"'#&'#\"),\n        peg$decode(\";\\xB9.# &;\\xA0\"),\n        peg$decode(\"%;\\xE3/Y#$%;A/,#;\\xE3/#$+\\\")(\\\"'#&'#06*%;A/,#;\\xE3/#$+\\\")(\\\"'#&'#&/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\xEA/k#;./b$;\\xED/Y$$%;B/,#;\\xE4/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xE4/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\xE5.; &;\\xE6.5 &;\\xE7./ &;\\xE8.) &;\\xE9.# &;\\xA0\"),\n        peg$decode(\"%3\\u017C\\\"\\\"5#7\\u017D/:#;</1$;\\xF0/($8#:\\u017E#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u017F\\\"\\\"5%7\\u0180/:#;</1$;T/($8#:\\u0181#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0182\\\"\\\"5(7\\u0183/F#;</=$;\\\\.) &;Y.# &;X/($8#:\\u0184#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0185\\\"\\\"5&7\\u0186/:#;</1$;6/($8#:\\u0187#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u0188\\\"\\\"5%7\\u0189/O#%;</3#$;!0#*;!&/#$+\\\")(\\\"'#&'#.\\\" &\\\"/'$8\\\":\\u018A\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\xEB/G#;;/>$;6/5$;;/,$;\\xEC/#$+%)(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\x92\\\"\\\"5#7\\xD3.# &;6/' 8!:\\u018B!! )\"),\n        peg$decode(\"%3\\xB1\\\"\\\"5#7\\u018C.G &3\\xB3\\\"\\\"5#7\\u018D.; &3\\xB7\\\"\\\"5#7\\u018E./ &3\\xB5\\\"\\\"5$7\\u018F.# &;6/' 8!:\\u0190!! )\"),\n        peg$decode(\"%;\\xEE/D#%;C/,#;\\xEF/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;U.) &;\\\\.# &;X/& 8!:\\u0191! )\"),\n        peg$decode(\"%%;!.\\\" &\\\"/[#;!.\\\" &\\\"/M$;!.\\\" &\\\"/?$;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+%)(%'#($'#(#'#(\\\"'#&'#/' 8!:\\u0192!! )\"),\n        peg$decode(\"%%;!/?#;!.\\\" &\\\"/1$;!.\\\" &\\\"/#$+#)(#'#(\\\"'#&'#/' 8!:\\u0193!! )\"),\n        peg$decode(\";\\xBE\"),\n        peg$decode(\"%;\\x9E/^#$%;B/,#;\\xF3/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xF3/#$+\\\")(\\\"'#&'#&/($8\\\":\\u0194\\\"!!)(\\\"'#&'#\"),\n        peg$decode(\";\\xF4.# &;\\xA0\"),\n        peg$decode(\"%2\\u0195\\\"\\\"6\\u01957\\u0196/L#;</C$2\\u0197\\\"\\\"6\\u01977\\u0198.) &2\\u0199\\\"\\\"6\\u01997\\u019A/($8#:\\u019B#! )(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\x9E/^#$%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#06*%;B/,#;\\xA0/#$+\\\")(\\\"'#&'#&/($8\\\":\\u019C\\\"!!)(\\\"'#&'#\"),\n        peg$decode(\"%;6/5#;0/,$;\\xF7/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"$;2.) &;4.# &;.0/*;2.) &;4.# &;.&\"),\n        peg$decode(\"$;%0#*;%&\"),\n        peg$decode(\"%;\\xFA/;#28\\\"\\\"6879/,$;\\xFB/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u019D\\\"\\\"5%7\\u019E.) &3\\u019F\\\"\\\"5$7\\u01A0/' 8!:\\u01A1!! )\"),\n        peg$decode(\"%;\\xFC/J#%28\\\"\\\"6879/,#;^/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\\\.) &;X.# &;\\x82/' 8!:\\u01A2!! )\"),\n        peg$decode(\";\\\".S &;!.M &2F\\\"\\\"6F7G.A &2J\\\"\\\"6J7K.5 &2H\\\"\\\"6H7I.) &2N\\\"\\\"6N7O\"),\n        peg$decode(\"2L\\\"\\\"6L7M.\\x95 &2B\\\"\\\"6B7C.\\x89 &2<\\\"\\\"6<7=.} &2R\\\"\\\"6R7S.q &2T\\\"\\\"6T7U.e &2V\\\"\\\"6V7W.Y &2P\\\"\\\"6P7Q.M &2@\\\"\\\"6@7A.A &2D\\\"\\\"6D7E.5 &22\\\"\\\"6273.) &2>\\\"\\\"6>7?\"),\n        peg$decode(\"%;\\u0100/b#28\\\"\\\"6879/S$;\\xFB/J$%2\\u01A3\\\"\\\"6\\u01A37\\u01A4/,#;\\xEC/#$+\\\")(\\\"'#&'#.\\\" &\\\"/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%3\\u01A5\\\"\\\"5%7\\u01A6.) &3\\u01A7\\\"\\\"5$7\\u01A8/' 8!:\\u01A1!! )\"),\n        peg$decode(\"%;\\xEC/O#3\\xB1\\\"\\\"5#7\\xB2.6 &3\\xB3\\\"\\\"5#7\\xB4.* &$;+0#*;+&/'$8\\\":\\u01A9\\\" )(\\\"'#&'#\"),\n        peg$decode(\"%;\\u0104/\\x87#2F\\\"\\\"6F7G/x$;\\u0103/o$2F\\\"\\\"6F7G/`$;\\u0103/W$2F\\\"\\\"6F7G/H$;\\u0103/?$2F\\\"\\\"6F7G/0$;\\u0105/'$8):\\u01AA) )()'#(('#(''#(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;#/>#;#/5$;#/,$;#/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\u0103/,#;\\u0103/#$+\\\")(\\\"'#&'#\"),\n        peg$decode(\"%;\\u0103/5#;\\u0103/,$;\\u0103/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;\\x84/U#;'/L$;\\x92/C$;'/:$;\\x90/1$; .\\\" &\\\"/#$+&)(&'#(%'#($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\"%2\\u01AB\\\"\\\"6\\u01AB7\\u01AC.) &2\\u01AD\\\"\\\"6\\u01AD7\\u01AE/w#;0/n$;\\u0108/e$$%;B/2#;\\u0109.# &;\\xA0/#$+\\\")(\\\"'#&'#0<*%;B/2#;\\u0109.# &;\\xA0/#$+\\\")(\\\"'#&'#&/#$+$)($'#(#'#(\\\"'#&'#\"),\n        peg$decode(\";\\x99.# &;L\"),\n        peg$decode(\"%2\\u01AF\\\"\\\"6\\u01AF7\\u01B0/5#;</,$;\\u010A/#$+#)(#'#(\\\"'#&'#\"),\n        peg$decode(\"%;D/S#;,/J$2:\\\"\\\"6:7;/;$;,.# &;T/,$;E/#$+%)(%'#($'#(#'#(\\\"'#&'#\")\n      ],\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleIndices)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleIndex = peg$startRuleIndices[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$decode(s) {\n    var bc = new Array(s.length), i;\n\n    for (i = 0; i < s.length; i++) {\n      bc[i] = s.charCodeAt(i) - 32;\n    }\n\n    return bc;\n  }\n\n  function peg$parseRule(index) {\n    var bc    = peg$bytecode[index],\n        ip    = 0,\n        ips   = [],\n        end   = bc.length,\n        ends  = [],\n        stack = [],\n        params, i;\n\n    while (true) {\n      while (ip < end) {\n        switch (bc[ip]) {\n          case 0:\n            stack.push(peg$consts[bc[ip + 1]]);\n            ip += 2;\n            break;\n\n          case 1:\n            stack.push(void 0);\n            ip++;\n            break;\n\n          case 2:\n            stack.push(null);\n            ip++;\n            break;\n\n          case 3:\n            stack.push(peg$FAILED);\n            ip++;\n            break;\n\n          case 4:\n            stack.push([]);\n            ip++;\n            break;\n\n          case 5:\n            stack.push(peg$currPos);\n            ip++;\n            break;\n\n          case 6:\n            stack.pop();\n            ip++;\n            break;\n\n          case 7:\n            peg$currPos = stack.pop();\n            ip++;\n            break;\n\n          case 8:\n            stack.length -= bc[ip + 1];\n            ip += 2;\n            break;\n\n          case 9:\n            stack.splice(-2, 1);\n            ip++;\n            break;\n\n          case 10:\n            stack[stack.length - 2].push(stack.pop());\n            ip++;\n            break;\n\n          case 11:\n            stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));\n            ip += 2;\n            break;\n\n          case 12:\n            stack.push(input.substring(stack.pop(), peg$currPos));\n            ip++;\n            break;\n\n          case 13:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (stack[stack.length - 1]) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 14:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (stack[stack.length - 1] === peg$FAILED) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 15:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (stack[stack.length - 1] !== peg$FAILED) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 16:\n            if (stack[stack.length - 1] !== peg$FAILED) {\n              ends.push(end);\n              ips.push(ip);\n\n              end = ip + 2 + bc[ip + 1];\n              ip += 2;\n            } else {\n              ip += 2 + bc[ip + 1];\n            }\n\n            break;\n\n          case 17:\n            ends.push(end);\n            ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);\n\n            if (input.length > peg$currPos) {\n              end = ip + 3 + bc[ip + 1];\n              ip += 3;\n            } else {\n              end = ip + 3 + bc[ip + 1] + bc[ip + 2];\n              ip += 3 + bc[ip + 1];\n            }\n\n            break;\n\n          case 18:\n            ends.push(end);\n            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {\n              end = ip + 4 + bc[ip + 2];\n              ip += 4;\n            } else {\n              end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n              ip += 4 + bc[ip + 2];\n            }\n\n            break;\n\n          case 19:\n            ends.push(end);\n            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n            if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {\n              end = ip + 4 + bc[ip + 2];\n              ip += 4;\n            } else {\n              end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n              ip += 4 + bc[ip + 2];\n            }\n\n            break;\n\n          case 20:\n            ends.push(end);\n            ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);\n\n            if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {\n              end = ip + 4 + bc[ip + 2];\n              ip += 4;\n            } else {\n              end = ip + 4 + bc[ip + 2] + bc[ip + 3];\n              ip += 4 + bc[ip + 2];\n            }\n\n            break;\n\n          case 21:\n            stack.push(input.substr(peg$currPos, bc[ip + 1]));\n            peg$currPos += bc[ip + 1];\n            ip += 2;\n            break;\n\n          case 22:\n            stack.push(peg$consts[bc[ip + 1]]);\n            peg$currPos += peg$consts[bc[ip + 1]].length;\n            ip += 2;\n            break;\n\n          case 23:\n            stack.push(peg$FAILED);\n            if (peg$silentFails === 0) {\n              peg$fail(peg$consts[bc[ip + 1]]);\n            }\n            ip += 2;\n            break;\n\n          case 24:\n            peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];\n            ip += 2;\n            break;\n\n          case 25:\n            peg$savedPos = peg$currPos;\n            ip++;\n            break;\n\n          case 26:\n            params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);\n            for (i = 0; i < bc[ip + 3]; i++) {\n              params[i] = stack[stack.length - 1 - params[i]];\n            }\n\n            stack.splice(\n              stack.length - bc[ip + 2],\n              bc[ip + 2],\n              peg$consts[bc[ip + 1]].apply(null, params)\n            );\n\n            ip += 4 + bc[ip + 3];\n            break;\n\n          case 27:\n            stack.push(peg$parseRule(bc[ip + 1]));\n            ip += 2;\n            break;\n\n          case 28:\n            peg$silentFails++;\n            ip++;\n            break;\n\n          case 29:\n            peg$silentFails--;\n            ip++;\n            break;\n\n          default:\n            throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n        }\n      }\n\n      if (ends.length > 0) {\n        end = ends.pop();\n        ip = ips.pop();\n      } else {\n        break;\n      }\n    }\n\n    return stack[0];\n  }\n\n\n    options.data = {}; // Object to which header attributes will be assigned during parsing\n\n    function list (head, tail) {\n      return [head].concat(tail);\n    }\n\n\n  peg$result = peg$parseRule(peg$startRuleIndex);\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * @name SIP\n * @namespace\n */\n\nmodule.exports = function (SIP) {\n    var Modifiers;\n    function stripPayload(sdp, payload) {\n        var i;\n        var media_descs = [];\n        var current_media_desc;\n        var lines = sdp.split(/\\r\\n/);\n        for (i = 0; i < lines.length;) {\n            var line = lines[i];\n            if (/^m=(?:audio|video)/.test(line)) {\n                current_media_desc = {\n                    index: i,\n                    stripped: []\n                };\n                media_descs.push(current_media_desc);\n            }\n            else if (current_media_desc) {\n                var rtpmap = /^a=rtpmap:(\\d+) ([^/]+)\\//.exec(line);\n                if (rtpmap && payload === rtpmap[2]) {\n                    lines.splice(i, 1);\n                    current_media_desc.stripped.push(rtpmap[1]);\n                    continue; // Don't increment 'i'\n                }\n            }\n            i++;\n        }\n        for (i = 0; i < media_descs.length; i++) {\n            var mline = lines[media_descs[i].index].split(' ');\n            // Ignore the first 3 parameters of the mline. The codec information is after that\n            for (var j = 3; j < mline.length;) {\n                if (media_descs[i].stripped.indexOf(mline[j]) !== -1) {\n                    mline.splice(j, 1);\n                    continue;\n                }\n                j++;\n            }\n            lines[media_descs[i].index] = mline.join(' ');\n        }\n        return lines.join('\\r\\n');\n    }\n    function stripMediaDescription(sdp, description) {\n        var descriptionRegExp = new RegExp(\"m=\" + description + \".*$\", \"gm\");\n        var groupRegExp = new RegExp(\"^a=group:.*$\", \"gm\");\n        if (descriptionRegExp.test(sdp)) {\n            var midLineToRemove_1;\n            sdp = sdp.split(/^m=/gm).filter(function (section) {\n                if (section.substr(0, description.length) === description) {\n                    midLineToRemove_1 = section.match(/^a=mid:.*$/gm);\n                    if (midLineToRemove_1) {\n                        midLineToRemove_1 = midLineToRemove_1[0].match(/:.+$/g)[0].substr(1);\n                    }\n                    return false;\n                }\n                return true;\n            }).join('m=');\n            var groupLine = sdp.match(groupRegExp);\n            if (groupLine && groupLine.length === 1) {\n                groupLine = groupLine[0];\n                var groupRegExpReplace = new RegExp(\"\\ *\" + midLineToRemove_1 + \"[^\\ ]*\", \"g\");\n                groupLine = groupLine.replace(groupRegExpReplace, \"\");\n                sdp = sdp.split(groupRegExp).join(groupLine);\n            }\n        }\n        return sdp;\n    }\n    Modifiers = {\n        stripTcpCandidates: function (description) {\n            description.sdp = description.sdp.replace(/^a=candidate:\\d+ \\d+ tcp .*?\\r\\n/img, \"\");\n            return SIP.Utils.Promise.resolve(description);\n        },\n        stripTelephoneEvent: function (description) {\n            description.sdp = stripPayload(description.sdp, 'telephone-event');\n            return SIP.Utils.Promise.resolve(description);\n        },\n        cleanJitsiSdpImageattr: function (description) {\n            description.sdp = description.sdp.replace(/^(a=imageattr:.*?)(x|y)=\\[0-/gm, \"$1$2=[1:\");\n            return SIP.Utils.Promise.resolve(description);\n        },\n        stripG722: function (description) {\n            description.sdp = stripPayload(description.sdp, 'G722');\n            return SIP.Utils.Promise.resolve(description);\n        },\n        stripRtpPayload: function (payload) {\n            return function (description) {\n                description.sdp = stripPayload(description.sdp, payload);\n                return SIP.Utils.Promise.resolve(description);\n            };\n        },\n        stripVideo: function (description) {\n            description.sdp = stripMediaDescription(description.sdp, \"video\");\n            return SIP.Utils.Promise.resolve(description);\n        },\n        addMidLines: function (description) {\n            var sdp = description.sdp;\n            if (sdp.search(/^a=mid.*$/gm) === -1) {\n                var mlines_1 = sdp.match(/^m=.*$/gm);\n                sdp = sdp.split(/^m=.*$/gm);\n                mlines_1.forEach(function (elem, idx) {\n                    mlines_1[idx] = elem + '\\na=mid:' + idx;\n                });\n                sdp.forEach(function (elem, idx) {\n                    if (mlines_1[idx]) {\n                        sdp[idx] = elem + mlines_1[idx];\n                    }\n                });\n                sdp = sdp.join('');\n                description.sdp = sdp;\n            }\n            return SIP.Utils.Promise.resolve(description);\n        }\n    };\n    return Modifiers;\n};\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * @fileoverview Simple\n */\n/* Simple\n * @class Simple\n */\nmodule.exports = function (SIP) {\n    var C = {\n        STATUS_NULL: 0,\n        STATUS_NEW: 1,\n        STATUS_CONNECTING: 2,\n        STATUS_CONNECTED: 3,\n        STATUS_COMPLETED: 4\n    };\n    /*\n     * @param {Object} options\n     */\n    var Simple = function (options) {\n        /*\n         *  {\n         *    media: {\n         *      remote: {\n         *        audio: <DOM element>,\n         *        video: <DOM element>\n         *      },\n         *      local: {\n         *        video: <DOM element>\n         *      }\n         *    },\n         *    ua: {\n         *       <UA Configuration Options>\n         *    }\n         *  }\n         */\n        if (options.media.remote.video) {\n            this.video = true;\n        }\n        else {\n            this.video = false;\n        }\n        if (options.media.remote.audio) {\n            this.audio = true;\n        }\n        else {\n            this.audio = false;\n        }\n        if (!this.audio && !this.video) {\n            // Need to do at least audio or video\n            // Error\n            throw new Error('At least one remote audio or video element is required for Simple.');\n        }\n        this.options = options;\n        // https://stackoverflow.com/questions/7944460/detect-safari-browser\n        var browserUa = global.navigator.userAgent.toLowerCase();\n        var isSafari = false;\n        var isFirefox = false;\n        if (browserUa.indexOf('safari') > -1 && browserUa.indexOf('chrome') < 0) {\n            isSafari = true;\n        }\n        else if (browserUa.indexOf('firefox') > -1 && browserUa.indexOf('chrome') < 0) {\n            isFirefox = true;\n        }\n        var sessionDescriptionHandlerFactoryOptions = {};\n        if (isSafari) {\n            sessionDescriptionHandlerFactoryOptions.modifiers = [SIP.Web.Modifiers.stripG722];\n        }\n        if (isFirefox) {\n            sessionDescriptionHandlerFactoryOptions.alwaysAcquireMediaFirst = true;\n        }\n        if (!this.options.ua.uri) {\n            this.anonymous = true;\n        }\n        this.ua = new SIP.UA({\n            // User Configurable Options\n            uri: this.options.ua.uri,\n            authorizationUser: this.options.ua.authorizationUser,\n            password: this.options.ua.password,\n            displayName: this.options.ua.displayName,\n            // Undocumented \"Advanced\" Options\n            userAgentString: this.options.ua.userAgentString,\n            // Fixed Options\n            register: true,\n            sessionDescriptionHandlerFactoryOptions: sessionDescriptionHandlerFactoryOptions,\n            transportOptions: {\n                traceSip: this.options.ua.traceSip,\n                wsServers: this.options.ua.wsServers\n            }\n        });\n        this.state = C.STATUS_NULL;\n        this.logger = this.ua.getLogger('sip.simple');\n        this.ua.on('registered', function () {\n            this.emit('registered', this.ua);\n        }.bind(this));\n        this.ua.on('unregistered', function () {\n            this.emit('unregistered', this.ua);\n        }.bind(this));\n        this.ua.on('failed', function () {\n            this.emit('unregistered', this.ua);\n        }.bind(this));\n        this.ua.on('invite', function (session) {\n            // If there is already an active session reject the incoming session\n            if (this.state !== C.STATUS_NULL && this.state !== C.STATUS_COMPLETED) {\n                this.logger.warn('Rejecting incoming call. Simple only supports 1 call at a time');\n                session.reject();\n                return;\n            }\n            this.session = session;\n            this.setupSession();\n            this.emit('ringing', this.session);\n        }.bind(this));\n        this.ua.on('message', function (message) {\n            this.emit('message', message);\n        }.bind(this));\n        return this;\n    };\n    Simple.prototype = Object.create(SIP.EventEmitter.prototype);\n    Simple.C = C;\n    // Public\n    Simple.prototype.call = function (destination) {\n        if (!this.ua || !this.checkRegistration()) {\n            this.logger.warn('A registered UA is required for calling');\n            return;\n        }\n        if (this.state !== C.STATUS_NULL && this.state !== C.STATUS_COMPLETED) {\n            this.logger.warn('Cannot make more than a single call with Simple');\n            return;\n        }\n        // Safari hack, because you cannot call .play() from a non user action\n        if (this.options.media.remote.audio) {\n            this.options.media.remote.audio.autoplay = true;\n        }\n        if (this.options.media.remote.video) {\n            this.options.media.remote.video.autoplay = true;\n        }\n        if (this.options.media.local && this.options.media.local.video) {\n            this.options.media.local.video.autoplay = true;\n            this.options.media.local.video.volume = 0;\n        }\n        this.session = this.ua.invite(destination, {\n            sessionDescriptionHandlerOptions: {\n                constraints: {\n                    audio: this.audio,\n                    video: this.video\n                }\n            }\n        });\n        this.setupSession();\n        return this.session;\n    };\n    Simple.prototype.answer = function () {\n        if (this.state !== C.STATUS_NEW && this.state !== C.STATUS_CONNECTING) {\n            this.logger.warn('No call to answer');\n            return;\n        }\n        // Safari hack, because you cannot call .play() from a non user action\n        if (this.options.media.remote.audio) {\n            this.options.media.remote.audio.autoplay = true;\n        }\n        if (this.options.media.remote.video) {\n            this.options.media.remote.video.autoplay = true;\n        }\n        return this.session.accept({\n            sessionDescriptionHandlerOptions: {\n                constraints: {\n                    audio: this.audio,\n                    video: this.video\n                }\n            }\n        });\n        // emit call is active\n    };\n    Simple.prototype.reject = function () {\n        if (this.state !== C.STATUS_NEW && this.state !== C.STATUS_CONNECTING) {\n            this.logger.warn('Call is already answered');\n            return;\n        }\n        return this.session.reject();\n    };\n    Simple.prototype.hangup = function () {\n        if (this.state !== C.STATUS_CONNECTED && this.state !== C.STATUS_CONNECTING && this.state !== C.STATUS_NEW) {\n            this.logger.warn('No active call to hang up on');\n            return;\n        }\n        if (this.state !== C.STATUS_CONNECTED) {\n            return this.session.cancel();\n        }\n        else {\n            return this.session.bye();\n        }\n    };\n    Simple.prototype.hold = function () {\n        if (this.state !== C.STATUS_CONNECTED || this.session.local_hold) {\n            this.logger.warn('Cannot put call on hold');\n            return;\n        }\n        this.mute();\n        this.logger.log('Placing session on hold');\n        return this.session.hold();\n    };\n    Simple.prototype.unhold = function () {\n        if (this.state !== C.STATUS_CONNECTED || !this.session.local_hold) {\n            this.logger.warn('Cannot unhold a call that is not on hold');\n            return;\n        }\n        this.unmute();\n        this.logger.log('Placing call off hold');\n        return this.session.unhold();\n    };\n    Simple.prototype.mute = function () {\n        if (this.state !== C.STATUS_CONNECTED) {\n            this.logger.warn('An acitve call is required to mute audio');\n            return;\n        }\n        this.logger.log('Muting Audio');\n        this.toggleMute(true);\n        this.emit('mute', this);\n    };\n    Simple.prototype.unmute = function () {\n        if (this.state !== C.STATUS_CONNECTED) {\n            this.logger.warn('An active call is required to unmute audio');\n            return;\n        }\n        this.logger.log('Unmuting Audio');\n        this.toggleMute(false);\n        this.emit('unmute', this);\n    };\n    Simple.prototype.sendDTMF = function (tone) {\n        if (this.state !== C.STATUS_CONNECTED) {\n            this.logger.warn('An active call is required to send a DTMF tone');\n            return;\n        }\n        this.logger.log('Sending DTMF tone: ' + tone);\n        this.session.dtmf(tone);\n    };\n    Simple.prototype.message = function (destination, message) {\n        if (!this.ua || !this.checkRegistration()) {\n            this.logger.warn('A registered UA is required to send a message');\n            return;\n        }\n        if (!destination || !message) {\n            this.logger.warn('A destination and message are required to send a message');\n            return;\n        }\n        this.ua.message(destination, message);\n    };\n    // Private Helpers\n    Simple.prototype.checkRegistration = function () {\n        return (this.anonymous || (this.ua && this.ua.isRegistered()));\n    };\n    Simple.prototype.setupRemoteMedia = function () {\n        // If there is a video track, it will attach the video and audio to the same element\n        var pc = this.session.sessionDescriptionHandler.peerConnection;\n        var remoteStream;\n        if (pc.getReceivers) {\n            remoteStream = new global.window.MediaStream();\n            pc.getReceivers().forEach(function (receiver) {\n                var track = receiver.track;\n                if (track) {\n                    remoteStream.addTrack(track);\n                }\n            });\n        }\n        else {\n            remoteStream = pc.getRemoteStreams()[0];\n        }\n        if (this.video) {\n            this.options.media.remote.video.srcObject = remoteStream;\n            this.options.media.remote.video.play().catch(function () {\n                this.logger.log('play was rejected');\n            }.bind(this));\n        }\n        else if (this.audio) {\n            this.options.media.remote.audio.srcObject = remoteStream;\n            this.options.media.remote.audio.play().catch(function () {\n                this.logger.log('play was rejected');\n            }.bind(this));\n        }\n    };\n    Simple.prototype.setupLocalMedia = function () {\n        if (this.video && this.options.media.local && this.options.media.local.video) {\n            var pc = this.session.sessionDescriptionHandler.peerConnection;\n            var localStream;\n            if (pc.getSenders) {\n                localStream = new global.window.MediaStream();\n                pc.getSenders().forEach(function (sender) {\n                    var track = sender.track;\n                    if (track && track.kind === 'video') {\n                        localStream.addTrack(track);\n                    }\n                });\n            }\n            else {\n                localStream = pc.getLocalStreams()[0];\n            }\n            this.options.media.local.video.srcObject = localStream;\n            this.options.media.local.video.volume = 0;\n            this.options.media.local.video.play();\n        }\n    };\n    Simple.prototype.cleanupMedia = function () {\n        if (this.video) {\n            this.options.media.remote.video.srcObject = null;\n            this.options.media.remote.video.pause();\n            if (this.options.media.local && this.options.media.local.video) {\n                this.options.media.local.video.srcObject = null;\n                this.options.media.local.video.pause();\n            }\n        }\n        if (this.audio) {\n            this.options.media.remote.audio.srcObject = null;\n            this.options.media.remote.audio.pause();\n        }\n    };\n    Simple.prototype.setupSession = function () {\n        this.state = C.STATUS_NEW;\n        this.emit('new', this.session);\n        this.session.on('progress', this.onProgress.bind(this));\n        this.session.on('accepted', this.onAccepted.bind(this));\n        this.session.on('rejected', this.onEnded.bind(this));\n        this.session.on('failed', this.onFailed.bind(this));\n        this.session.on('terminated', this.onEnded.bind(this));\n    };\n    Simple.prototype.destroyMedia = function () {\n        this.session.sessionDescriptionHandler.close();\n    };\n    Simple.prototype.toggleMute = function (mute) {\n        var pc = this.session.sessionDescriptionHandler.peerConnection;\n        if (pc.getSenders) {\n            pc.getSenders().forEach(function (sender) {\n                if (sender.track) {\n                    sender.track.enabled = !mute;\n                }\n            });\n        }\n        else {\n            pc.getLocalStreams().forEach(function (stream) {\n                stream.getAudioTracks().forEach(function (track) {\n                    track.enabled = !mute;\n                });\n                stream.getVideoTracks().forEach(function (track) {\n                    track.enabled = !mute;\n                });\n            });\n        }\n    };\n    Simple.prototype.onAccepted = function () {\n        this.state = C.STATUS_CONNECTED;\n        this.emit('connected', this.session);\n        this.setupLocalMedia();\n        this.setupRemoteMedia();\n        this.session.sessionDescriptionHandler.on('addTrack', function () {\n            this.logger.log('A track has been added, triggering new remoteMedia setup');\n            this.setupRemoteMedia();\n        }.bind(this));\n        this.session.sessionDescriptionHandler.on('addStream', function () {\n            this.logger.log('A stream has been added, trigger new remoteMedia setup');\n            this.setupRemoteMedia();\n        }.bind(this));\n        this.session.on('hold', function () {\n            this.emit('hold', this.session);\n        }.bind(this));\n        this.session.on('unhold', function () {\n            this.emit('unhold', this.session);\n        }.bind(this));\n        this.session.on('dtmf', function (tone) {\n            this.emit('dtmf', tone);\n        }.bind(this));\n        this.session.on('bye', this.onEnded.bind(this));\n    };\n    Simple.prototype.onProgress = function () {\n        this.state = C.STATUS_CONNECTING;\n        this.emit('connecting', this.session);\n    };\n    Simple.prototype.onFailed = function () {\n        this.onEnded();\n    };\n    Simple.prototype.onEnded = function () {\n        this.state = C.STATUS_COMPLETED;\n        this.emit('ended', this.session);\n        this.cleanupMedia();\n    };\n    return Simple;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28)))\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nvar toplevel = global.window || global;\nfunction getPrefixedProperty(object, name) {\n    if (object == null) {\n        return;\n    }\n    var capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);\n    var prefixedNames = [name, 'webkit' + capitalizedName, 'moz' + capitalizedName];\n    for (var i in prefixedNames) {\n        var property = object[prefixedNames[i]];\n        if (property) {\n            return property.bind(object);\n        }\n    }\n}\nmodule.exports = {\n    WebSocket: toplevel.WebSocket,\n    Transport: __webpack_require__(10),\n    open: toplevel.open,\n    Promise: toplevel.Promise,\n    timers: toplevel,\n    // Console is not defined in ECMAScript, so just in case...\n    console: toplevel.console || {\n        debug: function () { },\n        log: function () { },\n        warn: function () { },\n        error: function () { }\n    },\n    addEventListener: getPrefixedProperty(toplevel, 'addEventListener'),\n    removeEventListener: getPrefixedProperty(toplevel, 'removeEventListener')\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(28)))\n\n/***/ })\n/******/ ]);\n});"},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js":function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/index.js!./deskapp/js/es6-promise.js":function(n,e,t){t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js")(t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/es6-promise.js"))},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/index.js!./deskapp/js/fetch.js":function(n,e,t){t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js")(t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/fetch.js"))},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/index.js!./deskapp/js/pubnub.4.20.1.js":function(n,e,t){t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js")(t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/pubnub.4.20.1.js"))},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/index.js!./deskapp/js/ringcentral-web-phone.js":function(n,e,t){t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js")(t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/ringcentral-web-phone.js"))},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/index.js!./deskapp/js/ringcentral.js":function(n,e,t){t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js")(t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/ringcentral.js"))},"../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/index.js!./deskapp/js/sip-0.11.6.js":function(n,e,t){t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/script-loader/addScript.js")(t("../../../../npm-global/lib/node_modules/@zohodesk/react-cli/node_modules/raw-loader/index.js!./deskapp/js/sip-0.11.6.js"))}}]);